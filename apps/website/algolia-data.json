[
  {
    "objectID": "docs-adoption-guide",
    "title": "Adoption Guide",
    "content": "Sruja Adoption Guide\n\nIs Sruja Right for Your Organization?\n\nQuick Self-Assessment\n\nAnswer these questions to determine if Sruja addresses your needs:\n\nArchitecture & Documentation Pain Points\n\n[ ] Do your architecture diagrams become outdated within weeks?\n[ ] Do engineers spend significant time maintaining documentation?\n[ ] Is there confusion about \"the latest architecture diagram\"?\n[ ] Do new engineers struggle to understand system architecture?\n[ ] Are architectural decisions lost when senior engineers leave?\n\nIf 3+ are \"Yes\" ‚Üí Sruja can help\n\nCompliance & Governance Needs\n\n[ ] Do you need to comply with regulations (HIPAA, SOC2, PCI-DSS, GDPR)?\n[ ] Are compliance audits time-consuming and risky?\n[ ] Do you struggle to prove architectural controls meet requirements?\n[ ] Are security policies documented but not enforced?\n[ ] Do you need to demonstrate compliance to auditors?\n\nIf 2+ are \"Yes\" ‚Üí Sruja's policy-as-code is valuable\n\nTechnical Architecture Challenges\n\n[ ] Do you have microservices that need governance?\n[ ] Are you experiencing architectural drift (implementation vs. design)?\n[ ] Do you need to enforce service boundaries and dependencies?\n[ ] Are circular dependencies causing issues?\n[ ] Do you need to generate infrastructure from architecture?\n\nIf 2+ are \"Yes\" ‚Üí Sruja's validation and enforcement help\n\nDevOps & Engineering Culture\n\n[ ] Do you use Git/GitOps workflows?\n[ ] Do you have CI/CD pipelines?\n[ ] Do you value \"everything as code\" (IaC, GitOps)?\n[ ] Do you want architecture changes in PR reviews?\n[ ] Do you need architecture to integrate with Terraform/Istio/etc.?\n\nIf 3+ are \"Yes\" ‚Üí Sruja fits your workflow\n\nOrganization Size & Maturity\n\nSruja is ideal for:\n\n‚úÖ Startups (10-50 engineers): Fast scaling, need consistency\n‚úÖ Scale-ups (50-200 engineers): Managing complexity, compliance needs\n‚úÖ Enterprises (200+ engineers): Governance, compliance, knowledge management\n\nSruja may not be ideal if:\n\n‚ùå You have < 5 engineers (overhead may outweigh benefits)\n‚ùå You don't use version control or CI/CD\n‚ùå You prefer visual-only tools (no code/DSL)\n‚ùå You have no compliance or governance requirements\n\nDecision Framework\n\nStep 1: Define Your Goals\n\nWhat problem are you trying to solve?\n\n| Goal                              | Sruja Benefit                            | Priority |\n| --------------------------------- | ---------------------------------------- | -------- |\n| Reduce documentation overhead | Architecture-as-code stays current       | High     |\n| Ensure compliance             | Policy-as-code with automated validation | High     |\n| Prevent architectural drift   | Automated validation in CI/CD            | Medium   |\n| Faster onboarding             | Living documentation in codebase         | Medium   |\n| Enforce service boundaries    | Layer and dependency validation          | Medium   |\n| Generate infrastructure       | Terraform/OpenTofu generation (roadmap)  | Low      |\n\nAction: Rank your top 3 goals. Sruja should address at least 2.\n\nStep 2: Calculate Value & ROI\n\nNote: Sruja is free and open source. This ROI calculation measures time savings and value, not purchase cost.\n\nQuick Value Calculator:\n\nExample (10 senior engineers, 20 new engineers/year):\n\nTime: 10 √ó 4 hours √ó 0.7 √ó 50 √ó $100 = $140k/year\nOnboarding: 20 √ó 2 √ó 0.5 √ó $150k √∑ 50 = $60k/year\nRisk: 1 failure avoided = $100k (one-time)\nTotal Value: $200k+ per year\n\nROI: Since Sruja is free, ROI is essentially infinite - you get value with zero cost.\n\nStep 3: Assess Technical Fit\n\nEvaluate your technical stack:\n\n| Technology                            | Sruja Integration              | Status               |\n| ------------------------------------- | ------------------------------ | -------------------- |\n| Git/GitHub/GitLab                 | Native integration             | ‚úÖ Available         |\n| CI/CD (GitHub Actions, GitLab CI) | Validation in pipelines        | ‚úÖ Available         |\n| Terraform/OpenTofu                | Infrastructure generation      | üöß Roadmap (Phase 2) |\n| Kubernetes/Istio                  | Service mesh config generation | üöß Roadmap (Phase 3) |\n| API Gateways (Kong, Apigee)       | Config generation              | üöß Roadmap (Phase 3) |\n| OPA (Open Policy Agent)           | Policy integration             | üöß Roadmap (Phase 2) |\n\nAction:\n\nIf you need Git/CI/CD integration ‚Üí ‚úÖ Ready now\nIf you need Terraform/Istio/OPA ‚Üí üöß On roadmap (see Roadmap Discussions) ‚Äî you can pilot with current features now\n\nEvaluation Process\n\nPhase 1: Discovery (Week 1)\n\nActivities:\n\nReview Sruja documentation\nTry Sruja Designer online\nInstall CLI: \nModel a simple existing system\n\nDeliverable: Understanding of Sruja capabilities\n\nPhase 2: Proof of Concept (Weeks 2-4)\n\nActivities:\n\nModel 1-2 real systems in Sruja\nIntegrate validation into CI/CD\nDocument architecture decisions as ADRs\nMeasure time savings\n\nSuccess Criteria:\n\n[ ] Can model systems accurately\n[ ] Validation catches real issues\n[ ] Team sees value\n[ ] Time savings measurable\n\nDeliverable: PoC report with value estimate\n\nPhase 3: Pilot (Months 2-3)\n\nActivities:\n\nRoll out to 1-2 teams\nEstablish best practices\nCreate internal documentation\nMeasure compliance improvements\n\nSuccess Criteria:\n\n[ ] Architecture stays current\n[ ] Compliance validation working\n[ ] Team adoption > 80%\n[ ] Positive value demonstrated\n\nDeliverable: Pilot report with go/no-go recommendation\n\nDecision Checklist\n\nMust-Have Requirements\n\n[ ] Problem Fit: Sruja addresses 2+ of your top goals\n[ ] Value Positive: Calculated value > $100k/year (or equivalent time savings)\n[ ] Technical Fit: Git/CI/CD integration available (or roadmap acceptable)\n[ ] Team Readiness: Team comfortable with code-based tools\n[ ] Leadership Support: Time allocated for adoption (no budget needed - Sruja is free)\n\nNice-to-Have Requirements\n\n[ ] Advanced features needed (Terraform, Istio, OPA)\n[ ] Compliance requirements (HIPAA, SOC2, PCI-DSS)\n[ ] Large team (100+ engineers)\n[ ] Microservices architecture\n\nDecision Matrix\n\n| Criteria           | Weight | Your Score (1-5) | Weighted Score |\n| ------------------ | ------ | ---------------- | -------------- |\n| Problem fit        | 30%    | \\\\\\           | \\\\\\         |\n| Value/ROI          | 25%    | \\\\\\           | \\\\\\         |\n| Technical fit      | 20%    | \\\\\\           | \\\\\\         |\n| Team readiness     | 15%    | \\\\\\           | \\\\\\         |\n| Leadership support | 10%    | \\\\\\           | \\\\\\         |\n| Total          | 100%   |                  | \\\\\\_/5.0 |\n\nDecision Rule:\n\n4.0: Strong fit ‚Üí Proceed with pilot\n3.5-4.0: Good fit ‚Üí Consider pilot\n< 3.5: Weak fit ‚Üí Reassess or wait\n\nCommon Concerns & Objections\n\n\"We already have architecture documentation\"\n\nResponse: Sruja doesn't replace documentation ‚Äî it makes it executable. Your documentation becomes code that:\n\nStays current (version-controlled)\nValidates automatically\nEnforces policies\nIntegrates with DevOps\n\n\"Our team isn't technical enough for a DSL\"\n\nResponse: Sruja's DSL is designed for all developers:\n\n1st-year CS students productive in 10 minutes\nProgressive disclosure (simple ‚Üí advanced)\nRich error messages guide users\nVS Code extension with full LSP support (autocomplete, go-to-definition, rename, find references, and more) - see VS Code Extension Guide\n\n\"We don't have compliance requirements\"\n\nResponse: Sruja provides value beyond compliance:\n\nFaster onboarding (50% reduction)\nReduced documentation time (20-30%)\nArchitectural validation (prevents drift)\nKnowledge preservation\n\n\"The roadmap features we need aren't ready\"\n\nResponse:\n\nCore features (validation, CI/CD) are available now\nRoadmap features (Terraform, Istio, OPA) are planned for Phase 2-3 (see Roadmap Discussions)\nYou can start with core features and add advanced later\nEarly adoption gives you influence on roadmap priorities\n\nSuccess Metrics\n\nTrack These KPIs\n\n| Metric                          | Baseline        | Target (3 months)     | Target (6 months)     |\n| ------------------------------- | --------------- | --------------------- | --------------------- |\n| Documentation time          | X hours/week    | X √ó 0.7 hours/week    | X √ó 0.5 hours/week    |\n| Onboarding time             | X weeks         | X √ó 0.7 weeks         | X √ó 0.5 weeks         |\n| Architecture freshness      | X% outdated     | < 10% outdated        | < 5% outdated         |\n| Compliance violations       | X per quarter   | X √ó 0.5 per quarter   | 0 per quarter         |\n| Architectural issues caught | X in production | X √ó 0.3 in production | X √ó 0.1 in production |\n\nNext Steps\n\nImmediate Actions\n\nComplete Self-Assessment (above)\nCalculate Value (Step 2)\nTry Sruja (see Getting Started)\nJoin Community (GitHub Discussions, Discord, etc.)\n\nDecision Timeline\n\nWeek 1: Self-assessment and value calculation\nWeek 2-4: Proof of concept\nMonth 2-3: Pilot program\nMonth 4+: Full rollout (if successful)\n\nResources\n\nGetting Started: Getting Started Guide\nExecutive Overview: Executive Overview\nAdoption Playbook: Adoption Playbook\nDecision Framework: Quick Decision Framework\n\nOpen Source & Community Support\n\nSruja is free and open source (Apache 2.0 licensed), developed by and for the community. You can:\n\nUse it freely: No licensing fees or restrictions\nContribute: Submit PRs, report issues, suggest features\nExtend it: Build custom validators, exporters, and integrations\nJoin the community: Participate in GitHub Discussions, share use cases, and learn from others\n\nProfessional Services\n\nWhile Sruja is open source and free to use, professional consulting services are available for organizations that need:\n\nImplementation support: Help rolling out Sruja across teams and systems\nBest practices guidance: Establish architectural governance patterns and workflows\nCustom integrations: Integrate Sruja with existing CI/CD, infrastructure, and monitoring tools\nTraining: Team training on Sruja DSL, validation patterns, and architectural modeling\nCustom development: Build custom validators, exporters, or platform integrations\n\nContact the team through GitHub Discussions to discuss your needs.\n\nFuture Platform Vision\n\nSruja is designed to evolve into a comprehensive platform for architectural governance:\n\nLive System Review: Compare actual runtime behavior against architectural models to detect drift and violations.\nGap Analysis: Automatically identify missing components, undocumented dependencies, and architectural gaps.\nContinuous Validation: Monitor production systems against architectural policies and constraints in real-time.\nCompliance Monitoring: Track and report on architectural compliance across services and deployments.\n\nThese capabilities are planned for future releases. The current open source foundation provides the building blocks for this evolution, and community feedback helps shape the roadmap.\n\nNote: This guide helps you evaluate whether Sruja is the right fit for your organization and how to adopt it successfully.\n\nReady to evaluate Sruja? Start with the Self-Assessment above.",
    "url": "https://sruja.ai/docs/adoption-guide",
    "type": "documentation",
    "category": "docs",
    "summary": "Complete guide to evaluating and adopting Sruja for your organization.",
    "weight": 21
  },
  {
    "objectID": "docs-adoption-playbook",
    "title": "Adoption Playbook",
    "content": "Adoption Playbook\n\nWeek 1: Baseline & CI\nCreate a minimal  covering core systems.\nAdd  and  to CI; fail on violations.\nExport docs: .\n\nWeek 2: Targets & Guardrails\nAdd  and  for critical paths.\nEncode  and ; publish to teams.\nIntroduce  for API/Data/Auth focus.\n\nWeek 3: Governance & Evolution\nAdd  pages for security/operability.\nTrack  and  for versioned evolution.\nWire linting to PR checks; require green builds.\n\nCI Example (GitHub Actions)\n\nSuccess Metrics\nReview cycle time ‚Üì\nIncident rate for architecture errors ‚Üì\nConsistency across services ‚Üë\n\nNote: Sruja is free and open source (Apache 2.0 licensed). Need help with implementation? Professional consulting services are available. Contact the team through GitHub Discussions to learn more.",
    "url": "https://sruja.ai/docs/adoption-playbook",
    "type": "documentation",
    "category": "docs",
    "summary": "Practical steps to roll out Sruja across teams and CI.",
    "weight": 22
  },
  {
    "objectID": "docs-beginner-path",
    "title": "Beginner Path",
    "content": "Beginner Path: Learn Sruja Without Overwhelm\n\nFollow this small-steps plan. Each step has a clear outcome, takes 10‚Äì30 minutes, and gives immediate feedback.\n\nStep 1: Getting Started (20‚Äì30 min)\nRead: /docs/getting-started\nOutcome: CLI installed, first model created\n\nStep 2: CLI Basics (20 min)\nTutorial: /tutorials/basic/cli-basics\nOutcome: Run lint, fmt, tree, export\n\nStep 3: DSL Basics (25‚Äì30 min)\nTutorial: /tutorials/basic/dsl-basics\nQuiz: /quizzes/dsl-basics\nOutcome: Understand systems, containers, components, relations\n\nStep 4: Validation & Linting (15‚Äì20 min)\nTutorial: /tutorials/basic/validation-linting\nChallenge: /challenges/missing-relations\nOutcome: Fix common modeling errors\n\nStep 5: Export Diagrams (15‚Äì20 min)\nTutorial: /tutorials/basic/export-diagrams\nOutcome: Generate diagrams (D2, SVG) and Markdown\n\nStep 6: Practice Micro‚ÄëChallenges (20‚Äì30 min)\nChallenges: \n  - /challenges/add-component\n  - /challenges/fix-relations\n  - /challenges/queue-worker\nOutcome: Build confidence with small tasks\n\nStep 7: Systems Thinking (20 min)\nTutorial: /tutorials/basic/systems-thinking\nOutcome: Think in flows, dependencies, and constraints\n\nTips to Avoid Overwhelm\nSmall steps: limit sessions to 20‚Äì30 minutes\nVisible outcomes: run a command or export a diagram every step\nOne concept at a time: model, then lint, then export\nUse checklists: follow /docs/CONTENTQUALITYCHECKLIST when writing\nAsk for help: Discord and Discussions links in README\n\nWhat‚Äôs Next\nCourse: /courses/system-design-101/module-1-fundamentals\nAdvanced tutorials: /tutorials/advanced/deployment-modeling\n\nNote: Sruja is free and open source (Apache 2.0 licensed). Join the community on Discord or GitHub Discussions for help and to contribute.",
    "url": "https://sruja.ai/docs/beginner-path",
    "type": "documentation",
    "category": "docs",
    "summary": "A 7‚Äëstep plan to learn Sruja without overwhelm.",
    "difficulty": "beginner",
    "weight": 2
  },
  {
    "objectID": "docs-cli",
    "title": "CLI Guide",
    "content": "CLI Guide\n\nThe  command-line interface is your primary tool for interacting with Sruja projects.\n\n<!--more-->\n\nCommands\n\nExports the architecture to various formats.\n\nUsage:\n\nSupported Formats:\n\n: Generates Markdown docs with diagrams.\n: Generates Mermaid diagram code.\n: Exports rendered SVG diagrams.\n: Exports structured JSON of the architecture.\n: Generates D2 diagram code.\n\nExample:\n\nDisplays the architecture structure as a tree in the terminal.\n\nUsage:\n\nOptions:\n\n: Output as JSON.\n: Show tree for a specific system.\n\nExample:\n\nFormats the Sruja file to a canonical style.\n\nUsage:\n\nValidates the Sruja file against rules and best practices.\n\nUsage:",
    "url": "https://sruja.ai/docs/cli",
    "type": "documentation",
    "category": "docs",
    "summary": "The sruja command-line interface is your primary tool for interacting with Sruja projects.",
    "weight": 50
  },
  {
    "objectID": "docs-community",
    "title": "Community",
    "content": "Sruja Community\n\nWelcome to the Sruja community! Sruja is an open source project built by and for developers who care about software architecture. Whether you're here to learn, contribute, or get help, we're glad you're here.\n\nJoin the Conversation\n\nüí¨ Discord\nJoin our Discord server for real-time chat, quick questions, and community discussions:\n\nJoin Discord\n\nDiscord is great for:\nGetting quick help with questions\nDiscussing ideas and use cases\nSharing your Sruja projects\nConnecting with other community members\n\nüí¨ GitHub Discussions\nFor longer-form discussions, feature requests, and Q&A:\n\nGitHub Discussions\n\nGitHub Discussions is ideal for:\nFeature proposals and RFCs\nTechnical discussions\nSharing tutorials and examples\nAsking detailed questions\n\nüêõ GitHub Issues\nFound a bug or have a feature request?\n\nOpen an Issue\n\nWays to Contribute\n\nSruja is an open source project, and we welcome contributions of all sizes! There are many ways to contribute, even if you're not a developer.\n\nNo Code Required\n\nDocumentation\nFix typos or improve clarity\nAdd examples and tutorials\nTranslate documentation\nWrite blog posts or courses\n\nTesting & Feedback\nTest new features and report bugs\nShare your use cases\nProvide feedback on design decisions\nHelp improve error messages\n\nCommunity\nAnswer questions in Discord or Discussions\nHelp newcomers get started\nShare your Sruja projects and experiences\n\nBeginner-Friendly Code\n\nSmall Improvements\nAdd test cases\nFix small bugs\nImprove error messages\nAdd examples to the  directory\nImprove CLI help text\n\nDocumentation Code\nAdd code examples\nUpdate API documentation\nCreate tutorials\n\nMore Advanced Contributions\n\nFeatures & Enhancements\nImplement new features\nAdd new export formats\nAdd validation rules\nImprove tooling and developer experience\n\nCore Development\nWork on the language parser\nEnhance the validation engine\nBuild platform integrations\nDevelop plugins and extensions\n\nGetting Started with Contributions\n\nüéØ First Time Contributing?\n\nStart here: Contribution Guide\n\nThis step-by-step guide walks you through:\nFinding your first issue\nSetting up your development environment\nMaking and submitting changes\nGetting help when stuck\n\nQuick Links\n\nüí° Contribution Ideas: Browse Good First Issues\nüêõ Find Issues: Good First Issues\nüìñ Full Guide: Contribution Guide\nüìù Content Guide: Documentation Style Guide\n\nContribution Workflow\n\nFork and Branch: Fork the repo and create a topic branch\nImplement: Make your changes and test locally\nCommit: Follow Conventional Commits\nPull Request: Open a PR with a clear description\nReview: Address feedback and iterate\nMerge: Once approved, your contribution is merged!\n\nFor detailed instructions, see the Contribution Guide.\n\nRoadmap & Transparency\n\nSruja is developed transparently with community input. Our roadmap is public and open for discussion.\n\nCurrent Roadmap\n\nView Roadmap Discussions\n\nThe roadmap outlines our path to v1.0, including:\n\nAdvanced Governance & Compliance: Policy as code, architectural guardrails\nProduction Reality & Data Flow: Service mesh integration, runtime verification\nExtensibility & Ecosystem: Plugin system, DevOps integrations\nPlatform Evolution: Live system review, gap detection, violation monitoring\n\nShaping the Roadmap\n\nYour feedback shapes the roadmap! We welcome:\nFeature requests via GitHub Discussions\nUse case sharing to prioritize features\nRFCs (Request for Comments) for major changes\nCommunity voting on priorities\n\nCommunity Expectations\n\nWe're committed to maintaining a welcoming and respectful community. When participating:\n\nBe respectful and constructive: Treat everyone with kindness\nProvide actionable feedback: Help others improve their contributions\nPrefer documented decisions: Link to ADRs or issues when relevant\nStart small: You can always contribute more later!\n\nRecognition\n\nWe value all contributions, big and small. Contributors are recognized through:\n\nGitHub contributor list\nRelease notes (for significant contributions)\nCommunity highlights in discussions\n\nProfessional Services\n\nWhile Sruja is open source and free to use, professional consulting services are available for organizations that need:\n\nImplementation support: Help rolling out Sruja across teams\nBest practices guidance: Establish architectural governance patterns\nCustom integrations: Integrate with existing CI/CD and infrastructure\nTraining: Team training on Sruja DSL and architectural modeling\nCustom development: Build custom validators, exporters, or integrations\n\nContact the team through GitHub Discussions to discuss your needs.\n\nResources\n\nDocumentation\nGetting Started: Install and create your first model\nConcepts: Learn Sruja's core concepts\nReference: Language syntax and patterns\nTutorials: Step-by-step guides\n\nDevelopment\nRepository: Code, issues, and discussions\n\nCommunity\nDiscord: Real-time chat\nGitHub Discussions: Longer-form discussions\nGitHub Issues: Bug reports and feature requests\n\nGet Involved Today\n\nReady to contribute? Here are some quick ways to get started:\n\nJoin Discord and introduce yourself\nStar the repository on GitHub to show your support\nFix a typo in the documentation\nAdd an example to the  directory\nShare your use case in GitHub Discussions\n\nEvery contribution, no matter how small, helps make Sruja better for everyone. Thank you for being part of the community!\n\nQuestions? Reach out on Discord or GitHub Discussions. We're here to help!",
    "url": "https://sruja.ai/docs/community",
    "type": "documentation",
    "category": "docs",
    "summary": "Join the Sruja community, contribute, and help shape the future of architecture-as-code.",
    "weight": 90
  },
  {
    "objectID": "docs-concepts/adr",
    "title": "Architecture Decision Records (ADR)",
    "content": "Architecture Decision Records (ADR)\n\nSruja allows you to capture Architecture Decision Records (ADRs) directly within your architecture model. This keeps the \"why\" close to the \"what\".\n\nSyntax\n\nDefining an ADR\n\nYou can define an ADR with a full body describing the context, decision, and consequences.\n\nLinking ADRs\n\nYou can link an ADR to the elements it affects (System, Container, Component) by referencing its ID inside the element's block.\n\nOptional Title\n\nThe title is optional if you are just referencing an ADR or if you want to define it later.\n\nFields\n\nID: Unique identifier (e.g., ).\nTitle: Short summary of the decision.\nStatus: Current status (e.g., , , ).\nContext: The problem statement and background.\nDecision: The choice made.\nConsequences: The pros, cons, and implications of the decision.",
    "url": "https://sruja.ai/docs/concepts/adr",
    "type": "documentation",
    "category": "concepts",
    "summary": "Capture architecture decisions directly in your model.",
    "weight": 51
  },
  {
    "objectID": "docs-concepts/architecture",
    "title": "Architecture",
    "content": "Architecture\n\nThe  block is the root element of a Sruja model. It represents the entire scope of what you are modeling.\n\nSyntax\n\nExplicit Block (Recommended for large projects)\n\nMinimal Example\n\nFor simple examples, you can use a minimal structure:\n\nPurpose\n\nScope Boundary: Everything inside is part of the model.\nNaming: Gives a name to the overall architecture.",
    "url": "https://sruja.ai/docs/concepts/architecture",
    "type": "documentation",
    "category": "concepts",
    "summary": "The architecture block is the root element of any Sruja model.",
    "weight": 10
  },
  {
    "objectID": "docs-concepts/behavior-and-depends-on",
    "title": "Behavior and depends_on",
    "content": "Behavior and depends_on\n\nUse  to document responsibilities; use  to note upstreams.\n\nSyntax\n\nGuidance\n\nKeep behavior bullets action‚Äëoriented and concise.\nUse  to surface operational and failure domains.\nMark external boundaries with  on systems.\n\nRelated\n\nfor runtime calls\nand metadata for classification",
    "url": "https://sruja.ai/docs/concepts/behavior-and-depends-on",
    "type": "documentation",
    "category": "concepts",
    "summary": "Describe component behavior and upstream dependencies explicitly.",
    "weight": 21
  },
  {
    "objectID": "docs-concepts/c4-model",
    "title": "The C4 Model",
    "content": "The C4 Model\n\nSruja is built on the C4 model, a hierarchical approach to software architecture diagrams. If you are new to architecture-as-code, it helps to understand these four levels of abstraction.\n\nThink of it like Google Maps for your code: you can zoom out to see the whole world (System Context), or zoom in to see individual streets (Code).\n\nThe 4 Levels\n\nSystem Context (Level 1)\n\n\"The Big Picture\"\n\nThis is the highest level of abstraction. It shows your software system as a single box, and how it interacts with users and other systems (like functional dependencies, email systems, or payment gateways).\n\nGoal: What is the system, who uses it, and how does it fit into the existing IT landscape?\nAudience: Everyone (Technical & Non-Technical).\n\nContainer (Level 2)\n\n\"The High-Level Technical Building Blocks\"\n\nNote: In C4, a \"Container\" is NOT a Docker container. It represents a deployable unit‚Äîsomething that runs separately. Examples include:\n\nA Single-Page Application (SPA)\nA Mobile App\nA Server-side API application\nA Database\nA File System\n\nGoal: What are the major technical choices? How do they communicate?\nAudience: Architects, Developers, Ops.\n\nComponent (Level 3)\n\n\"The Internals\"\n\nZooming into a Container to see the major structural building blocks. In an API, these might be your controllers, services, or repositories.\n\nGoal: How is the container structured?\nAudience: Developers.\n\nCode (Level 4)\n\n\"The Details\"\n\nThe actual classes, interfaces, and functions. Sruja focuses mainly on Levels 1, 2, and 3, as Level 4 is best managed by your IDE.\n\nKey Relationships\n\nThe power of C4 is in the Hierarchical nature.\n\nA System defines the boundary.\nContainers live inside a System.\nComponents live inside a Container.\n\nWhen you define a relationship at a lower level (e.g., ), Sruja automatically understands the relationship at higher levels (e.g.,  is implied).\n\nWhy use C4?\n\nShared Vocabulary: \"Component\" and \"Service\" often mean different things to different teams. C4 standardizes this.\nZoom Levels: Avoids the \"one giant messy diagram\" problem. You can view the system at the level of detail relevant to you.",
    "url": "https://sruja.ai/docs/concepts/c4-model",
    "type": "documentation",
    "category": "concepts",
    "summary": "Understand the core concepts behind Sruja's architecture modeling.",
    "weight": 1
  },
  {
    "objectID": "docs-concepts/change-and-snapshot",
    "title": "Change and Snapshot",
    "content": "Change and Snapshot\n\nUse  to describe modifications; use  to capture versioned states.\n\nSyntax\n\nGuidance\n\nKeep  titles action‚Äëoriented; include  where relevant.\nUse  with clear version strings and a short note.\nLink ADRs to  items for rationale.\n\nRelated\n\nfor decisions\nwhen changes affect runtime topology",
    "url": "https://sruja.ai/docs/concepts/change-and-snapshot",
    "type": "documentation",
    "category": "concepts",
    "summary": "Track architecture evolution and capture versioned snapshots.",
    "weight": 60
  },
  {
    "objectID": "docs-concepts/component",
    "title": "Component",
    "content": "Component\n\nA Component is a grouping of related functionality encapsulated behind a well-defined interface. Components reside inside Containers.\n\nSyntax\n\nExample",
    "url": "https://sruja.ai/docs/concepts/component",
    "type": "documentation",
    "category": "concepts",
    "summary": "A Component is a grouping of related functionality encapsulated behind a well-defined interface.",
    "weight": 13
  },
  {
    "objectID": "docs-concepts/container",
    "title": "Container",
    "content": "Container\n\nA Container represents an application or a data store. It is something that needs to be running in order for the overall software system to work.\n\nNote: In C4, \"Container\" does not mean a Docker container. It means a deployable unit like:\n\nServer-side web application (e.g., Java Spring, ASP.NET Core)\nClient-side web application (e.g., React, Angular)\nMobile app\nDatabase schema\nFile system\n\nSyntax\n\nExample\n\nScaling Configuration\n\nContainers can define horizontal scaling properties using the  block:\n\nScale Block Fields\n\n* (optional): Minimum number of replicas\n(optional): Maximum number of replicas\n* (optional): Scaling metric trigger (e.g., \"cpu > 80%\", \"memory > 90%\")\n\nThis helps document your auto-scaling strategy and can be used by deployment tools.",
    "url": "https://sruja.ai/docs/concepts/container",
    "type": "documentation",
    "category": "concepts",
    "summary": "A Container represents an application or a data store.",
    "weight": 14
  },
  {
    "objectID": "docs-concepts/contracts-constraints-conventions",
    "title": "Constraints and Conventions",
    "content": "Constraints and Conventions\n\nUse these blocks to formalize architectural limits and team agreements.\n\nSyntax\n\nSruja uses flat syntax - all declarations are top-level, no wrapper blocks needed:\n\nGuidance\n\nUse  for firm boundaries (security, compliance, architecture).\nCapture team  to improve consistency across services.\n\nRelated\n\nfor governance documents\nfor rationale behind constraints",
    "url": "https://sruja.ai/docs/concepts/contracts-constraints-conventions",
    "type": "documentation",
    "category": "concepts",
    "summary": "Specify architectural constraints and shared conventions.",
    "weight": 43
  },
  {
    "objectID": "docs-concepts/datastore",
    "title": "DataStore",
    "content": "DataStore\n\nA DataStore represents a database, file system, or any other system that stores data. It is a specialized type of Container.\n\nSyntax\n\nExample",
    "url": "https://sruja.ai/docs/concepts/datastore",
    "type": "documentation",
    "category": "concepts",
    "summary": "A DataStore represents a database, file system, or any other system that stores data.",
    "weight": 16
  },
  {
    "objectID": "docs-concepts/deployment",
    "title": "Deployment",
    "content": "Deployment\n\nThe Deployment view allows you to map your software containers to infrastructure. This corresponds to the C4 Deployment Diagram.\n\nDeployment Node\n\nA Deployment Node is something like physical hardware, a virtual machine, a Docker container, a Kubernetes pod, etc. Nodes can be nested.\n\nSyntax\n\nInfrastructure Node\n\nAn Infrastructure Node represents infrastructure software that isn't one of your containers (e.g., DNS, Load Balancer, External Database Service).\n\nSyntax\n\nContainer Instance\n\nA Container Instance represents a runtime instance of one of your defined Containers running on a Deployment Node.\n\nSyntax\n\nExample",
    "url": "https://sruja.ai/docs/concepts/deployment",
    "type": "documentation",
    "category": "concepts",
    "summary": "The Deployment view allows you to map your software containers to infrastructure.",
    "weight": 33
  },
  {
    "objectID": "docs-concepts/layering",
    "title": "Layering",
    "content": "Layering\n\nLayering keeps your architecture modular. Higher layers depend on lower ones, not the other way around.\n\nAllowed Direction\n\nViolation Example\n\nThis causes a layer violation. Fix by:\n\nInverting the dependency (WebApp depends on an interface exposed by API)\nUsing events/messages instead of direct upward calls\n\nSee Also\n\nScenario\nValidation",
    "url": "https://sruja.ai/docs/concepts/layering",
    "type": "documentation",
    "category": "concepts",
    "summary": "Keep dependencies flowing downward: Web ‚Üí API ‚Üí DB.",
    "weight": 30
  },
  {
    "objectID": "docs-concepts/metadata-and-tags",
    "title": "Metadata & Tags",
    "content": "Metadata & Tags\n\nSruja allows you to attach additional information to your elements using Metadata and Tags.\n\nTags\n\nTags are simple string labels that can be used for filtering, styling, or categorization.\n\nSyntax\n\nMetadata\n\nMetadata allows you to attach key-value pairs to elements. This is useful for storing information like team ownership, cost centers, links to other docs, etc.\n\nSyntax\n\nTechnology\n\nMost elements (Container, Component, etc.) support a  field to specify the tech stack.\n\nSyntax\n\nSee Also\n\nValidation",
    "url": "https://sruja.ai/docs/concepts/metadata-and-tags",
    "type": "documentation",
    "category": "concepts",
    "summary": "Attach additional information to your elements using Metadata and Tags.",
    "weight": 41
  },
  {
    "objectID": "docs-concepts/overview",
    "title": "Overview",
    "content": "Overview\n\nUse  to provide a concise system description shown in docs/exports.\n\nSyntax\n\nGuidance\n\nKeep summary short and practical; avoid marketing language.\nUse  at architecture root; prefer  inside elements for details.",
    "url": "https://sruja.ai/docs/concepts/overview",
    "type": "documentation",
    "category": "concepts",
    "summary": "Summarize systems with high‚Äëlevel context for readers and diagrams.",
    "weight": 12
  },
  {
    "objectID": "docs-concepts/person",
    "title": "Person",
    "content": "Person\n\nA Person represents a human user of your software system (e.g., \"Customer\", \"Admin\", \"Employee\").\n\nSyntax\n\nExample",
    "url": "https://sruja.ai/docs/concepts/person",
    "type": "documentation",
    "category": "concepts",
    "summary": "A Person represents a human user of your software system.",
    "weight": 15
  },
  {
    "objectID": "docs-concepts/policy",
    "title": "Policy",
    "content": "Policy\n\nPolicies define architectural rules, standards, and constraints that your system must follow. They help enforce best practices, compliance requirements, and organizational standards directly in your architecture model.\n\nSyntax\n\nSimple Policy\n\nPolicy with Category and Enforcement\n\nPolicy Fields\n\n*: Unique identifier for the policy (e.g., , )\n: Human-readable description of the policy\n(optional): Policy category (e.g., \"security\", \"compliance\", \"performance\")\n(optional): Enforcement level (\"required\", \"recommended\", \"optional\")\n(optional): Detailed description within the policy body\n(optional): Additional metadata key-value pairs\n\nExample: Security Policies\n\nExample: Compliance Policies\n\nExample: Observability Policies\n\nPolicy Categories\n\nCommon policy categories include:\n\n: Security standards and practices\n: Regulatory and legal requirements\n: Performance standards and SLAs\n: Monitoring, logging, and metrics requirements\n: Architectural patterns and principles\n: Data handling and privacy requirements\n\nEnforcement Levels\n\n: Policy must be followed (non-negotiable)\n: Policy should be followed (best practice)\n: Policy is a guideline (suggested)\n\nBenefits\n\nDocumentation: Policies are part of your architecture, not separate documents\nValidation: Can be validated against actual implementations\nCommunication: Clear standards for development teams\nCompliance: Track regulatory and organizational requirements\nGovernance*: Enforce architectural decisions and patterns\n\nNote on Rules\n\nThe  keyword inside policies is not yet implemented. For now, policies serve as documentation and can be validated manually or through external tooling.\n\nSee Also\n\nArchitecture\nSystem\nRequirements\nADR",
    "url": "https://sruja.ai/docs/concepts/policy",
    "type": "documentation",
    "category": "concepts",
    "summary": "Define architectural rules and constraints that must be followed.",
    "weight": 50
  },
  {
    "objectID": "docs-concepts/properties",
    "title": "Properties",
    "content": "Properties\n\nUse  for structured metadata beyond  labels.\n\nSyntax\n\nGuidance\n\nPrefer simple strings; use clear keys like , , .\nKeep sensitive values out of source; use references or IDs.",
    "url": "https://sruja.ai/docs/concepts/properties",
    "type": "documentation",
    "category": "concepts",
    "summary": "Attach arbitrary key‚Äëvalue metadata to elements using `properties`.",
    "weight": 40
  },
  {
    "objectID": "docs-concepts/queue",
    "title": "Queue",
    "content": "Queue\n\nA Queue represents a message queue, topic, or event stream. It is a specialized type of Container used for asynchronous communication.\n\nSyntax\n\nExample",
    "url": "https://sruja.ai/docs/concepts/queue",
    "type": "documentation",
    "category": "concepts",
    "summary": "A Queue represents a message queue, topic, or event stream.",
    "weight": 34
  },
  {
    "objectID": "docs-concepts/relations",
    "title": "Relations",
    "content": "Relations\n\nRelations describe how elements interact with each other. They are the lines connecting the boxes in your diagram.\n\nSyntax\n\nOr with a technology/protocol:\n\nExample\n\nUse clear, unique IDs to reference relation endpoints.\n\nSee Also\n\nScenario\nValidation",
    "url": "https://sruja.ai/docs/concepts/relations",
    "type": "documentation",
    "category": "concepts",
    "summary": "Relations describe how elements interact with each other.",
    "weight": 20
  },
  {
    "objectID": "docs-concepts/requirements",
    "title": "Requirements",
    "content": "Requirements\n\nUse  to capture functional, performance, security, and constraint requirements. Requirements are declared at the architecture root only.\n\nSyntax\n\nGuidance\n\nKeep requirement titles concise and testable.\nReference requirements in ADRs and scenarios where relevant.\nValidate with  to surface unmet or conflicting requirements.\nDeclarations at system/container/component level are deprecated and ignored by exporters and UI.\n\nRelated\n\nfor behavior walkthroughs\nfor targets and windows\nfor decision records",
    "url": "https://sruja.ai/docs/concepts/requirements",
    "type": "documentation",
    "category": "concepts",
    "summary": "Model functional and non‚Äëfunctional requirements directly in Sruja DSL.",
    "weight": 31
  },
  {
    "objectID": "docs-concepts/scale",
    "title": "Scale",
    "content": "Scale\n\nUse  to capture expected capacity, concurrency, or throughput ranges.\n\nSyntax\n\nGuidance\n\nChoose a single clear  per block (e.g., , , ).\nUse realistic bounds to guide design and SLOs.\nPair with  and  to encode targets.\n\nRelated\n\nfor availability/latency/errorRate/throughput targets\nfor performance expectations",
    "url": "https://sruja.ai/docs/concepts/scale",
    "type": "documentation",
    "category": "concepts",
    "summary": "Express capacity ranges and metrics for components and systems.",
    "weight": 32
  },
  {
    "objectID": "docs-concepts/scenario",
    "title": "Scenario",
    "content": "Scenario\n\nScenarios describe behavioral flows as ordered steps. They focus on interactions rather than data pipelines.\n\nSyntax\n\nScenario vs Flow\n\nSruja supports two similar constructs for modeling interactions:\n\n*: Models behavioral flows - what happens when a user interacts with the system (user stories, use cases)\n: Models data flows - how data moves through the system (Data Flow Diagrams, DFD-style)\n\nBoth use the same syntax with relations between elements, but serve different purposes:\n\nWhen to use:*\n\nUse  for user journeys, business processes, and behavioral flows\nUse  for data pipelines, ETL processes, and system-to-system data flows\n\nTips\n\nKeep step labels short and action‚Äëoriented.\nUse fully qualified names when referring outside the current context.\nUse  for behavior; use  for data flows; use relations for structure.\n\nSee Also\n\nLayering\nValidation",
    "url": "https://sruja.ai/docs/concepts/scenario",
    "type": "documentation",
    "category": "concepts",
    "summary": "Describe behavioral flows as steps between elements.",
    "weight": 22
  },
  {
    "objectID": "docs-concepts/slo",
    "title": "Service Level Objectives (SLO)",
    "content": "Service Level Objectives (SLO)\n\nService Level Objectives (SLOs) define measurable targets for system performance and reliability. Sruja allows you to document SLOs directly in your architecture model, keeping performance requirements close to your design.\n\nSyntax\n\nSLOs can be defined at the system or container level:\n\nSLO Types\n\nAvailability\n\nMeasures system uptime and reliability.\n\n*: Target availability percentage (e.g., \"99.9%\")\n: Time window for measurement (e.g., \"30 days\", \"1 week\")\n(optional): Current measured availability\n\nLatency\n\nMeasures response time percentiles.\n\n: 95th percentile latency target\n: 99th percentile latency target\n: Time window for measurement\n(optional): Current measured latency percentiles\n\nError Rate\n\nMeasures the rate of errors or failures.\n\n: Target error rate (e.g., \"< 0.1%\", \"0.01%\")\n: Time window for measurement\n(optional): Current measured error rate\n\nThroughput\n\nMeasures the rate of requests or operations.\n\n: Target throughput (e.g., \"1000 req/s\", \"50 ops/min\")\n: Time window for measurement\n(optional): Current measured throughput\n\nExample\n\nBenefits\n\nDocumentation: SLOs are part of your architecture, not separate documents\nValidation: Can be validated against actual metrics\nCommunication: Clear performance expectations for stakeholders\nPlanning*: Helps with capacity planning and resource allocation\n\nSee Also\n\nContainer\nSystem\nMetadata & Tags",
    "url": "https://sruja.ai/docs/concepts/slo",
    "type": "documentation",
    "category": "concepts",
    "summary": "Define performance and reliability targets for your systems.",
    "weight": 52
  },
  {
    "objectID": "docs-concepts/style-block",
    "title": "Style Block",
    "content": "Style Block\n\nUse  to set global visual defaults across diagrams and exports.\n\nSyntax\n\nGuidance\n\nUse a small, consistent palette; prefer semantic colors.\nOverride globally here; adjust per‚Äëview in  when needed.\n\nRelated\n\nfor per‚Äëview styling\nand core element types",
    "url": "https://sruja.ai/docs/concepts/style-block",
    "type": "documentation",
    "category": "concepts",
    "summary": "Define global rendering styles for elements and relations.",
    "weight": 42
  },
  {
    "objectID": "docs-concepts/system",
    "title": "System",
    "content": "System\n\nA System represents a software system, which is the highest level of abstraction in the C4 model. A system delivers value to its users, whether they are human or other systems.\n\nSyntax\n\nExample",
    "url": "https://sruja.ai/docs/concepts/system",
    "type": "documentation",
    "category": "concepts",
    "summary": "A System represents a software system, the highest level of abstraction in the C4 model.",
    "weight": 11
  },
  {
    "objectID": "docs-concepts/validation",
    "title": "Validation",
    "content": "Validation\n\nSruja validates your model to catch issues early.\n\nCommon Checks\n\nUnique IDs within scope\nValid references (relations connect existing elements)\nCycles (informational; feedback loops are valid)\nLayering violations (dependencies must flow downward)\nExternal boundary checks\nSimplicity guidance (non‚Äëblocking)\n\nExample\n\nRun  locally or in CI to enforce these rules.\n\nSee Also\n\nLayering\nScenario",
    "url": "https://sruja.ai/docs/concepts/validation",
    "type": "documentation",
    "category": "concepts",
    "summary": "Automatic checks: IDs, references, cycles, layering, externals.",
    "weight": 35
  },
  {
    "objectID": "docs-concepts/views",
    "title": "Views",
    "content": "Views\n\nDefine  to customize what elements appear and how they render.\n\nSyntax\n\nGuidance\n\nUse  to spotlight critical paths; use  to reduce noise.\nKeep view names descriptive (e.g., \"API Focus\", \"Data Flow\").\nUse view  for legibility: color important relations, reshape data stores.\n\nRelated\n\nfor edges\nblock for global defaults",
    "url": "https://sruja.ai/docs/concepts/views",
    "type": "documentation",
    "category": "concepts",
    "summary": "Create focused visualizations using includes, excludes, and per‚Äëview styles.",
    "weight": 36
  },
  {
    "objectID": "docs-decision-framework",
    "title": "Decision Framework",
    "content": "Sruja Decision Framework: Quick Reference\n\n5-Minute Decision Matrix\n\nStep 1: Problem Fit (2 minutes)\n\nDo you have these problems?\n\n| Problem                                           | Yes/No | Priority |\n| ------------------------------------------------- | ------ | -------- |\n| Architecture docs become outdated quickly         | ‚òê      | High     |\n| Engineers spend too much time on documentation    | ‚òê      | High     |\n| Compliance audits are risky/time-consuming        | ‚òê      | High     |\n| New engineers struggle to understand architecture | ‚òê      | Medium   |\n| Architectural drift (design vs. implementation)   | ‚òê      | Medium   |\n| Need to enforce service boundaries                | ‚òê      | Medium   |\n\nDecision: If 3+ \"Yes\" with High priority ‚Üí Proceed to Step 2\n\nStep 2: Value Quick Check (2 minutes)\n\nNote: Sruja is free and open source. This calculates value and time savings, not purchase cost.\n\nQuick Value Calculator:\n\nExample (10 senior engineers, 20 new engineers/year):\n\nTime: 10 √ó 4 hours √ó 0.7 √ó 50 √ó $100 = $140k/year\nOnboarding: 20 √ó 2 √ó 0.5 √ó $150k √∑ 50 = $60k/year\nRisk: 1 failure avoided = $100k (one-time)\nTotal Value: $200k+ per year\n\nDecision: If value > $100k/year ‚Üí Proceed to Step 3 (Since Sruja is free, ROI is essentially infinite)\n\nStep 3: Technical Fit (1 minute)\n\nCheck your stack:\n\n| Technology              | Needed? | Sruja Status         |\n| ----------------------- | ------- | -------------------- |\n| Git/GitHub/GitLab       | ‚òê       | ‚úÖ Available         |\n| CI/CD Pipeline          | ‚òê       | ‚úÖ Available         |\n| Terraform/OpenTofu      | ‚òê       | üöß Roadmap (Phase 2) |\n| Kubernetes/Istio        | ‚òê       | üöß Roadmap (Phase 3) |\n| Compliance (HIPAA/SOC2) | ‚òê       | ‚úÖ Available         |\n\nDecision:\n\nIf Git + CI/CD available ‚Üí Ready now\nIf need Terraform/Istio ‚Üí On roadmap - you can pilot with current features now\n\nDecision Tree\n\nGo/No-Go Checklist\n\nMust-Have (All Required)\n\n[ ] Problem exists: 3+ problems from Step 1\n[ ] Value positive: > $50k/year in time savings (or equivalent)\n[ ] Git available: Version control in place\n[ ] Team ready: Comfortable with code-based tools\n[ ] Time allocated: Team can invest time in adoption (no budget needed - Sruja is free)\n\nNice-to-Have (Optional)\n\n[ ] Compliance requirements (HIPAA, SOC2, PCI-DSS)\n[ ] Large team (50+ engineers)\n[ ] Microservices architecture\n[ ] Advanced features needed (Terraform, Istio)\n\nDecision Rule:\n\n‚úÖ All Must-Haves ‚Üí GO (Proceed with pilot)\n‚ö†Ô∏è 3-4 Must-Haves ‚Üí MAYBE (Consider pilot)\n‚ùå < 3 Must-Haves ‚Üí NO-GO (Reassess later)\n\nEvaluation Timeline\n\nOption A: Quick Evaluation (1-2 weeks)\n\nDay 1: Try Sruja Designer online\nWeek 1: Install CLI, model one system\nWeek 2: Integrate validation into CI/CD\nDecision: Go/No-Go for pilot\n\nOption B: Full Evaluation (1 month)\n\nWeek 1: Discovery and self-assessment\nWeek 2: Proof of concept (model 2 systems)\nWeek 3: Measure value and team feedback\nWeek 4: Decision and planning\n\nRisk Assessment\n\nLow Risk Scenarios ‚úÖ\n\nSmall team (< 20 engineers)\nGit/CI/CD already in place\nTeam comfortable with code-based tools\nClear value (> $100k/year in time savings)\n\nMedium Risk Scenarios ‚ö†Ô∏è\n\nLarge team (100+ engineers) ‚Üí Need change management\nNo CI/CD ‚Üí Need to set up first\nTeam resistant to new tools ‚Üí Need training/support\nValue borderline ($50-100k/year) ‚Üí Need careful measurement\n\nHigh Risk Scenarios ‚ùå\n\nNo version control ‚Üí Not ready for Sruja\nTeam not technical ‚Üí May need training first\nValue negative (no time savings) ‚Üí May not be worth adoption effort\nNo leadership support ‚Üí Will fail\n\nCommon Decision Points\n\n\"Should we pilot or go full rollout?\"\n\nPilot if:\n\nTeam size > 50 engineers\nUncertain about value/time savings\nNeed to prove value first\nWant to minimize adoption risk\n\nFull rollout if:\n\nSmall team (< 20 engineers)\nClear value (> $200k/year in time savings)\nStrong leadership support\nUrgent compliance needs\n\n\"Should we wait for roadmap features?\"\n\nStart now if:\n\nCore features (validation, CI/CD) meet your needs\nYou can add advanced features later\nYou want to influence roadmap\n\nWait if:\n\nYou absolutely need Terraform/Istio integration (on roadmap)\nNo immediate pain points\nTeam not ready for adoption\n\nQuick Reference: Key Metrics\n\n| Metric                     | Target        | How to Measure              |\n| -------------------------- | ------------- | --------------------------- |\n| Documentation time     | -70%          | Track hours/week            |\n| Onboarding time        | -50%          | Track weeks to productivity |\n| Architecture freshness | > 95% current | Review update frequency     |\n| Compliance violations  | 0             | Track audit findings        |\n| Architectural issues   | -90%          | Track production issues     |\n\nNext Steps\n\nIf GO Decision:\n\nWeek 1: Install and try Sruja\nWeek 2-4: Proof of concept\nMonth 2-3: Pilot program\nMonth 4+: Full rollout\n\nIf NO-GO Decision:\n\nReassess in 6 months: Team maturity may change\nMonitor roadmap: Advanced features may address needs\nConsider alternatives: May have different requirements\n\nIf MAYBE Decision:\n\nStart small: Model one system\nMeasure results: Track time savings\nRe-evaluate: After 1-2 months\n\nRelated Resources\n\nAdoption Guide: Complete Adoption Guide\nExecutive Overview: Executive Overview\nGetting Started: Getting Started Guide\nAdoption Playbook: Adoption Playbook\n\nGetting Help with Implementation\n\nOpen Source Community: Sruja is free and open source (Apache 2.0 licensed). Join the community on GitHub Discussions for support, questions, and contributions.\n\nProfessional Services: Need help with adoption, integration, or custom requirements? Professional consulting services are available to help organizations:\n\nImplement Sruja across teams and systems\nEstablish architectural governance practices\nIntegrate with existing CI/CD and infrastructure toolchains\nDevelop custom validators and exporters\nPlan migration from existing documentation tools\n\nContact the team through GitHub Discussions to discuss your needs.\n\nFuture Platform Vision\n\nSruja is designed to evolve into a comprehensive platform for architectural governance:\n\nLive System Review: Compare actual runtime behavior against architectural models to detect drift and violations.\nGap Analysis: Automatically identify missing components, undocumented dependencies, and architectural gaps.\nContinuous Validation: Monitor production systems against architectural policies and constraints in real-time.\nCompliance Monitoring: Track and report on architectural compliance across services and deployments.\n\nThese capabilities are planned for future releases. The current open source foundation provides the building blocks for this evolution.\n\nNote: Sruja is free and open source - no purchase required. This framework helps you evaluate whether Sruja is the right fit for your organization.\n\nUse this framework to make an informed decision in 5 minutes.",
    "url": "https://sruja.ai/docs/decision-framework",
    "type": "documentation",
    "category": "docs",
    "summary": "5-minute decision matrix to determine if Sruja is right for your organization.",
    "weight": 20
  },
  {
    "objectID": "docs-examples",
    "title": "Usage Examples",
    "content": "Examples & Patterns\n\nTheory is good, but code is better. Below are production-grade Sruja models that you can copy, paste, and adapt.\n\nEvery example here follows our \"FAANG-level\" quality standards:\n\nClear Requirements: Functional & Non-functional.\nProper Hierarchies: Context -> Container -> Component.\nReal Tech Stacks: No generic \"Database\" boxes.\n\nBanking System (Fintech)\n\n[!NOTE]\nIdeally Suited For: Highly regulated industries requiring audit trails, security policies, and strict latency SLAs.\n\nScenario: A regional bank needs to modernize its legacy mainframe interactions while providing a slick mobile experience.\n\nWhy review this example?\n\nSecurity: Uses  blocks for PCI-DSS.\nHybrid Cloud: Connects modern Cloud Containers to an on-premise \"Mainframe\" System.\nComplexity: Models the \"Legacy Core\" vs \"Modern Interface\" pattern often seen in enterprise.\n\nüëâ Deep Dive this Architecture using our Course\n\nGlobal E-Commerce Platform\n\n[!NOTE]\nIdeally Suited For: High-scale B2C applications. Focuses on caching, asynchronous processing, and eventual consistency.\n\nScenario: An Amazon-like store preparing for Black Friday traffic spikes.\n\nWhy review this example?\n\nScalability: Explains how to handle high reads (Product Catalog) vs transactional writes (Checkout).\nAsync Messaging: Shows usages of Queues/Topics () to decouple services.\nCaching: Strategic placement of Redis caches.\n\nWhat Next?\n\nNew to Sruja? Try the First Architecture Tutorial.\nNeed more depth? Check out the full Content Library.",
    "url": "https://sruja.ai/docs/examples",
    "type": "documentation",
    "category": "docs",
    "summary": "Production-ready architectures. Learn how to model Fintech, E-Commerce, and SaaS systems with Sruja.",
    "weight": 80
  },
  {
    "objectID": "docs-getting-started",
    "title": "Getting Started",
    "content": "Your First Architecture\n\nWelcome to the future of system design.\n\nSruja allows you to define your software architecture as code. No more dragging boxes around. No more outdated PNGs on a wiki. You write code, Sruja draws the maps.\n\nInstallation\n\nInstall the Sruja CLI to compile, validate, and export your diagrams.\n\nMac / Linux\n\nFrom Source (Go)\n\nVerify installation:\n\nHello, World!\n\nLet's model a simple web application. Create a file named .\n\nThe Code\n\nCopy and paste this into your file:\n\nGenerate the Diagram\n\nRun this command in your terminal:\n\nYou have just created a Diagram-as-Code artifact! You can paste the content of  into Mermaid Live Editor to see it, or use the VS Code extension to preview it instantly.\n\n[!TIP]\nVS Code User?\nInstall the Sruja VS Code Extension for real-time preview, autocomplete, and syntax highlighting.\n\nUnderstanding the Basics\n\nLet's break down what just happened.\n\n*: Defines the types of elements available in your model. This provides:\n    - Early Validation: Catches typos in element types before runtime\n    - Better Tooling: Enables autocomplete, validation, and refactoring in your IDE\n    - Documentation: Makes available element types explicit and self-documenting\n    - Organization: Separates structure definition from instantiation\n: The root block where you instantiate your architecture. This is where you define your actual systems, containers, and relationships.\n: Creates custom perspectives from your model. Different views for different audiences (executives, architects, developers).\n: A high-level collection of software (C4 Level 1).\n: A deployable application (e.g., Docker container, Lambda, Database).\n: The magic arrow. This defines a relationship. Sruja (and the C4 model) cares deeply about how things talk to each other.\n\nWhat Now?\n\nYou have the tools. Now get the skills.\n\nüéì Learn the Core: Take the System Design 101 course to move beyond \"Hello World\".\nüèó See Real Patterns: Copy production-ready code from Examples.\nüõ† Master the CLI: Learn how to validate constraints in CLI Basics*.",
    "url": "https://sruja.ai/docs/getting-started",
    "type": "documentation",
    "category": "docs",
    "summary": "From zero to architecture in 5 minutes. Install Sruja and deploy your first diagram.",
    "difficulty": "beginner",
    "weight": 1
  },
  {
    "objectID": "docs-how-sruja-works",
    "title": "How Sruja Works",
    "content": "How Sruja Works\n\nSruja is built on a modern, modular architecture designed to bring Architecture-as-Code to every part of your development lifecycle‚Äîfrom your IDE to your CI/CD pipeline and documentation site.\n\nThe Sruja Platform\n\nThe platform consists of several key components working together:\n\nCore Engine: The heart of Sruja, written in Go. It handles parsing, validation, and analysis.\nCLI: The command-line interface for local development and CI/CD integration.\nWASM Module: The core engine compiled to WebAssembly, enabling Sruja to run in the browser and VS Code.\nLanguage Service: Provides IDE features like syntax highlighting, auto-completion, and diagnostics.\nStudio & Viewer: Web-based tools for visualizing and interacting with your architecture.\n\nArchitecture Diagram\n\nExplore the Sruja architecture itself using the interactive viewer below. This diagram is defined in Sruja DSL!\n\nKey Components\n\nCore Engine (Go)\n\nThe [](https://github.com/sruja-ai/sruja/tree/main/pkg/engine) and [](https://github.com/sruja-ai/sruja/tree/main/pkg/language) packages form the foundation. They define the DSL grammar, parse input files into an AST (Abstract Syntax Tree), and run validation rules (like cycle detection and layer enforcement).\n\nWebAssembly (WASM)\n\nTo ensure a consistent experience across all tools, we compile the Go engine to WebAssembly ([](https://github.com/sruja-ai/sruja/tree/main/cmd/wasm)). This allows the exact same parsing and validation logic to run in:\n\nSruja Designer: For instant feedback in the browser.\nVS Code Extension: For local preview without needing a binary.\nDocumentation Site: For embedding interactive diagrams in documentation (like the one above!).\n\nCLI & CI/CD\n\nThe  CLI ([](https://github.com/sruja-ai/sruja/tree/main/cmd/sruja)) is a static binary that wraps the core engine. It's designed for:\n\nLocal Development: , , .\nCI/CD:  to enforce architectural quality in your pipelines.\nExport:  to export architecture to JSON format.\nImport:  to import architecture from JSON format.",
    "url": "https://sruja.ai/docs/how-sruja-works",
    "type": "documentation",
    "category": "docs",
    "weight": 3
  },
  {
    "objectID": "docs-intro",
    "title": "Introduction",
    "content": "Introduction\n\nSruja is an open source architecture-as-code tool. It helps teams define, validate, and evolve their software architecture using a text-based language (DSL).\n\nWhy Sruja?\n\nMost teams document architecture in static diagrams (Miro, LucidChart, Visio) or inconsistent Wiki pages. These suffer from:\n\nDrift: The code changes, but the diagram doesn't.\nInconsistency: Every architect draws \"boxes and arrows\" differently.\nNo Validation: You can't \"test\" a PNG image for broken dependencies.\n\nSruja treats Architecture like Code:\n\nVersion Control: Commit your architecture to Git.\nValidation: CI/CD checks for circular dependencies and rule violations.\nConsistency: Based on the C4 Model for clear, hierarchical abstractions.\n\nWho is Sruja For?\n\nStudents & Learners\n\nLearn system design with production-ready examples from fintech, healthcare, and e-commerce\nHands-on courses covering fundamentals to advanced patterns\nReal-world scenarios that prepare you for interviews and real projects\n\nSoftware Architects\n\nEnforce architectural standards with policy-as-code\nPrevent architectural drift through automated validation\nScale governance across multiple teams without manual reviews\nDocument decisions with ADRs (Architecture Decision Records)\n\nProduct Teams\n\nLink requirements to architecture - see how features map to technical components\nTrack SLOs and metrics alongside your architecture\nAlign technical decisions with business goals and user needs\nCommunicate architecture to stakeholders with clear, visual diagrams\n\nDevOps Engineers\n\nIntegrate into CI/CD - validate architecture on every commit\nAutomate documentation generation from architecture files\nModel deployments - Blue/Green, Canary, multi-region strategies\nTrack infrastructure - map logical architecture to physical deployment\n\nExample\n\nHere's a simple example to get you started:\n\nFor production-ready examples with real-world patterns, see our Examples page featuring:\n\nBanking systems (fintech)\nE-commerce platforms\nHealthcare platforms (HIPAA-compliant)\nMulti-tenant SaaS platforms\n\nNext Steps\n\nNew to Sruja? Start with Getting Started\nWant to learn? Explore our Courses and Tutorials\nNeed examples? Check out Real-World Examples\nReady to build? Try the Sruja Designer for interactive visualization",
    "url": "https://sruja.ai/docs/intro",
    "type": "documentation",
    "category": "docs",
    "weight": 0
  },
  {
    "objectID": "docs-reference/cheatsheet",
    "title": "Sruja Cheatsheet",
    "content": "import LiveSrujaBlockWrapper from '@/features/playground/components/LiveSrujaBlockWrapper.astro'\n\nSruja Cheatsheet\n\nElements\n\nComponent\n\nScenario\n\nDeployment\n\nTry It Live\n\n<LiveSrujaBlockWrapper initialDsl={\"specification {\\n  person = kind \\\"Person\\\"\\n  system = kind \\\"System\\\"\\n  container = kind \\\"Container\\\"\\n  datastore = kind \\\"Datastore\\\"\\n}\\n\\nmodel {\\n  User = person \\\"User\\\"\\n  App = system \\\"App\\\" {\\n    Web = container \\\"Web\\\"\\n    API = container \\\"API\\\"\\n    DB = datastore \\\"DB\\\"\\n  }\\n  User -> App.Web \\\"Uses\\\"\\n  App.Web -> App.API \\\"Calls\\\"\\n  App.API -> App.DB \\\"Reads/Writes\\\"\\n}\"} />",
    "url": "https://sruja.ai/docs/reference/cheatsheet",
    "type": "documentation",
    "category": "reference",
    "summary": "Quick syntax and common patterns for fast modeling.",
    "weight": 52
  },
  {
    "objectID": "docs-reference/patterns",
    "title": "Architecture Patterns",
    "content": "Architecture Patterns\n\nRequest/Response\n\nEvent-Driven\n\nSaga\n\nCQRS\n\nRAG (Retrieval-Augmented Generation)\n\nSee  for a production-ready model.\n\nAgentic Orchestration\n\nSee  for a complete agent graph.",
    "url": "https://sruja.ai/docs/reference/patterns",
    "type": "documentation",
    "category": "reference",
    "summary": "Reusable patterns: request/response, event-driven, saga, CQRS.",
    "weight": 53
  },
  {
    "objectID": "docs-reference/syntax",
    "title": "Syntax Reference",
    "content": "Syntax Reference\n\nElements\n\nRelations\n\nMetadata\n\nDeployment",
    "url": "https://sruja.ai/docs/reference/syntax",
    "type": "documentation",
    "category": "reference",
    "summary": "Core constructs and fields for Sruja DSL.",
    "weight": 51
  },
  {
    "objectID": "docs-style-guide",
    "title": "Documentation Style Guide",
    "content": "Documentation Style Guide\n\nGoals\nAlign with the Di√°taxis framework: Tutorials, How‚Äëto Guides, Reference, Explanation\nImprove clarity, consistency, and task‚Äëorientation\nRaise quality to industry standards (Stripe, React, Kubernetes, MDN)\n\nFront Matter\nRequired: , \nRecommended: , , , , , \n\nHeadings\nUse Title Case for H1/H2/H3\nKeep headings unique; avoid duplicates within a page\n\nCode Blocks\nAlways specify language fences: , , , , , , , , \nPrefer copy‚Äëready commands; avoid interactive prompts where possible\n\nAdmonitions\nUse standard callouts: Note, Tip, Warning\nKeep callouts short and action‚Äëoriented\n\nLinks\nPrefer descriptive link text (not raw URLs)\nCross‚Äëlink to Reference and Examples when teaching a concept or task\n\nImages & Diagrams\nInclude small screenshots or diagram previews for expected outcomes\nUse alt text that describes the intent and context\n\nTutorials\nStructure: Overview ‚Üí Prerequisites ‚Üí Steps ‚Üí Outcome ‚Üí Troubleshooting ‚Üí Next Steps\nInclude at least one end‚Äëto‚Äëend task with an expected output\n\nHow‚Äëto Guides\nTask‚Äëoriented and concise\nStructure: Purpose ‚Üí Steps ‚Üí Validation ‚Üí References\n\nReference\nPrecise, complete, and skimmable tables/lists\nAvoid narrative; link outward to tutorials for workflows\n\nExplanation\nConceptual background, rationale, trade‚Äëoffs\nLink to reference for details and to tutorials for practice\n\nQuality Gates\nMarkdown lint for headings, lists, links\nLink checking for external and internal links\nOptional accessibility lint (alt text, heading levels)\n\nReview Checklist\nFront matter present and complete\nHeadings consistent and unique\nCode fences have language tags\nCross‚Äëlinks added to relevant Reference/Examples\nOutcome preview or screenshot included where appropriate",
    "url": "https://sruja.ai/docs/style-guide",
    "type": "documentation",
    "category": "docs",
    "summary": "Standards for tutorials, how‚Äëtos, reference, and explanation.",
    "weight": 100
  },
  {
    "objectID": "docs-vscode-extension",
    "title": "VS Code Extension",
    "content": "VS Code Extension\n\nThe Sruja VS Code extension provides comprehensive language support for  files with full LSP (Language Server Protocol) features powered by WebAssembly.\n\nInstallation\n\nFrom VS Code Marketplace\n\nOpen VS Code\nGo to Extensions ( or )\nSearch for \"Sruja\"\nClick Install on \"Sruja DSL Language Support\"\n\nFrom VSIX File\n\nDownload the  file from GitHub Releases\nIn VS Code, go to Extensions\nClick the  menu ‚Üí \"Install from VSIX...\"\nSelect the downloaded  file\n\nFeatures\n\nThe extension provides a complete LSP implementation with the following features:\n\n‚ú® Core LSP Features\n\nDiagnostics (Errors & Warnings)\n\nReal-time error detection as you type\nSyntax errors highlighted immediately\nValidation errors (duplicate IDs, invalid references, etc.)\nHover over errors to see detailed messages\n\nHover Information\n\nHover over any symbol to see its definition\nShows system/container/component information\nDisplays labels and descriptions\n\nUsage: Hover your mouse over any identifier\n\nAutocomplete (IntelliSense)\n\nKeyword suggestions (, , , etc.)\nSymbol completion (suggests existing systems, containers, components)\nContext-aware suggestions\n\nUsage: Type  (or  on Mac) to trigger autocomplete\n\nGo to Definition\n\nNavigate to symbol definitions with  or \nWorks with qualified names (e.g., )\nSupports both root and child paths in FQNs\n\nUsage:\n\n- Go to definition\n(Mac) or  (Windows/Linux) - Go to definition\n- Go to implementation\n\nFind All References\n\nFind all places where a symbol is used\nShows references in relations and qualified names\nOpens in the References panel\n\nUsage:\n\n- Find all references\nRight-click ‚Üí \"Find All References\"\n\nRename Symbol\n\nRename a symbol and all its references\nUpdates both definitions and usages\nHandles qualified names correctly\n\nUsage:\n\n- Rename symbol\nRight-click ‚Üí \"Rename Symbol\"\n\nDocument Symbols (Outline)\n\nView all symbols in the current file\nNavigate quickly through your architecture\nShows hierarchy: systems ‚Üí containers ‚Üí components\n\nUsage:\n\n(Mac) or  (Windows/Linux) - Go to symbol in file\nView ‚Üí Outline\n\nWorkspace Symbols\n\nSearch for symbols across all open files\nQuick navigation to any symbol in your workspace\n\nUsage:\n\n(Mac) or  (Windows/Linux) - Go to symbol in workspace\n\nCode Formatting\n\nFormat your Sruja DSL code\nConsistent indentation and spacing\n\nUsage:\n\n(Windows/Linux) or  (Mac) - Format document\nRight-click ‚Üí \"Format Document\"\n\nüé® Additional Features\n\nSyntax Highlighting\n\nColor-coded keywords, strings, and identifiers\nMakes code easier to read and understand\n\nPreview Architecture\n\nGenerate visual previews of your architecture\nOpens in VS Code's markdown preview\n\nUsage:\n\nRight-click on a  file ‚Üí \"Preview Sruja Architecture\"\nOr use the command palette:  ‚Üí \"Sruja: Preview Architecture\"\n\nKeyboard Shortcuts\n\n| Feature                   | Mac                  | Windows/Linux         |\n| ------------------------- | -------------------- | --------------------- |\n| Go to Definition          |  or  |  or  |\n| Find All References       |           |            |\n| Rename Symbol             |                  |                   |\n| Go to Symbol in File      |         |         |\n| Go to Symbol in Workspace |               |               |\n| Format Document           |      |          |\n| Trigger Autocomplete      |           |           |\n\nConfiguration\n\nThe extension supports the following settings:\n\nFormatting Options\n\n(default: ) - Enable automatic formatting\n(default: ) - Number of spaces per indentation level\n(default: ) - Use spaces instead of tabs\n\nTo configure:\n\nOpen Settings ( or )\nSearch for \"Sruja\"\nAdjust the formatting options as needed\n\nDebugging\n\nIf you encounter issues with the extension:\n\nCheck Output Channel\n\nOpen Output panel: \nSelect \"Sruja WASM LSP\" from the dropdown\nCheck for error messages or initialization issues\n\nDebug Command\n\nOpen Command Palette:  (Mac) or  (Windows/Linux)\nRun: \"Sruja: Debug WASM LSP\"\nThis will test all LSP functions and show results in the output channel\n\nCommon Issues\n\nExtension not working?\n\nCheck the \"Sruja WASM LSP\" output channel for errors\nEnsure WASM files are present (should be installed automatically)\nTry reloading the window:  ‚Üí \"Developer: Reload Window\"\n\nLSP features not responding?\n\nCheck if the file has a  extension\nVerify the language mode is set to \"Sruja\" (bottom-right of VS Code)\nRun the debug command to see which functions are failing\n\nRename not working?\n\nMake sure you're clicking on a valid symbol (not a keyword)\nCheck the output channel for error messages\nTry the debug command to test rename functionality\n\nArchitecture\n\nThe extension uses WebAssembly (WASM) for all LSP functionality, which means:\n\n‚úÖ No CLI dependency - Works without installing the Sruja CLI\n‚úÖ Fast - WASM provides near-native performance\n‚úÖ Portable - Same code runs in browser and VS Code\n‚úÖ Self-contained - All functionality bundled in the extension\n\nThe LSP implementation is powered by the same Go codebase that runs the CLI, compiled to WASM for use in Node.js environments.\n\nWhat's Next?\n\nLearn the DSL: Check out the Syntax Reference\nSee Examples: Browse Example Architectures\nGet Help: Join Discord or GitHub Discussions\n\nContributing\n\nFound a bug or have a feature request?\n\nReport Issues: GitHub Issues\nSuggest Features: GitHub Discussions\nContribute Code: See Contribution Guide",
    "url": "https://sruja.ai/docs/vscode-extension",
    "type": "documentation",
    "category": "docs",
    "summary": "Full-featured Language Server Protocol (LSP) support for Sruja DSL in VS Code.",
    "weight": 15
  },
  {
    "objectID": "blog-2025-12-03-welcome",
    "title": "Sruja Team",
    "content": "We‚Äôve migrated the Learn site to Docusaurus v3.9. You‚Äôll find docs, tutorials, and course materials here, with MDX components that open examples directly in Studio.\n\n<!-- truncate -->",
    "url": "https://sruja.ai/blogs/2025-12-03-welcome",
    "type": "blog",
    "tags": ["release", "site", "docs"],
    "pubDate": "2025-12-03",
    "authors": [
      {
        "name": "Sruja Team",
        "url": "https://sruja.ai"
      }
    ]
  },
  {
    "objectID": "course-advanced-architects/course-overview",
    "title": "Quick Start for Seasoned Software Architects",
    "content": "Quick Start for Seasoned Software Architects\n\nFor senior architects who need to enforce standards across large organizations.\n\nThis 5-minute course teaches you how to use Sruja to codify architectural policies, prevent drift, and scale governance across multiple teams‚Äîwithout slowing down development.\n\nWhy This Course?\n\nAs organizations grow, architectural standards become critical but hard to enforce. This course shows you how to:\n\n‚úÖ Codify policies as executable rules\n‚úÖ Prevent architectural drift automatically\n‚úÖ Scale governance across 100+ engineers\n‚úÖ Enforce standards in CI/CD without manual reviews\n‚úÖ Track compliance across services and teams\n\nWhat You'll Learn\n\nPolicy as Code: Write architectural rules that run in CI/CD\nConstraint Enforcement: Prevent violations before they reach production\nGovernance Patterns: Real-world patterns for large organizations\nCompliance Automation: Track and report on architectural compliance\nTeam Scaling: How to roll out governance without friction\n\nWho This Course Is For\n\nSenior/staff architects leading multiple teams\nEngineering managers responsible for architectural standards\nPlatform teams building developer tooling\nArchitects at companies with 50+ engineers\nAnyone implementing architecture governance\n\nPrerequisites\n\nExperience with software architecture at scale\nFamiliarity with CI/CD pipelines\nBasic understanding of Sruja syntax (or complete Getting Started first)\n\nEstimated Time\n\n5 minutes ‚Äî Quick, actionable lessons you can apply immediately.\n\nCourse Structure\n\nModule 1: Policy as Code (5 minutes)\nLearn to codify architectural standards as executable policies that run in CI/CD.\n\nYou'll learn:\nHow to write constraints and conventions\nHow to enforce layer boundaries\nHow to prevent common violations\nHow to integrate with CI/CD pipelines\n\nLearning Outcomes\n\nBy the end of this course, you'll be able to:\n\n‚úÖ Write architectural policies as code\n‚úÖ Enforce standards automatically in CI/CD\n‚úÖ Prevent architectural drift before it happens\n‚úÖ Scale governance across large teams\n‚úÖ Track compliance across services\n\nReal-World Application\n\nThis course uses patterns from:\nMicroservices governance at scale\nMulti-team architecture standards\nCompliance requirements (HIPAA, SOC 2)\nService boundary enforcement\nDependency management policies\n\nReady to scale your architecture governance? Let's go! üöÄ",
    "url": "https://sruja.ai/courses/advanced-architects/course-overview",
    "type": "course",
    "category": "advanced-architects",
    "summary": "5-minute masterclass: Enforce architectural standards, prevent drift, and scale governance across teams.",
    "weight": 0
  },
  {
    "objectID": "course-advanced-architects/module-1-policy-as-code/lesson-1",
    "title": "Lesson 1: Writing Constraints and Conventions",
    "content": "Lesson 1: Writing Constraints and Conventions\n\nThe Problem: Architectural Drift\n\nAs teams grow, architectural standards drift. Services violate boundaries, dependencies become circular, and compliance requirements are missed. Manual reviews don't scale.\n\nExample violations:\n\nFrontend directly accessing database (violates layer boundaries)\nServices in wrong layers (business logic in presentation layer)\nCircular dependencies between services\nMissing compliance controls (HIPAA, SOC 2)\n\nSolution: Policy as Code\n\nSruja lets you codify architectural standards as constraints and conventions that are:\n\n‚úÖ Version-controlled with your code\n‚úÖ Validated automatically in CI/CD\n‚úÖ Enforced consistently across teams\n‚úÖ Tracked and reported on\n\nWriting Constraints\n\nConstraints define hard rules that must be followed. Violations block CI/CD.\n\nWriting Conventions\n\nConventions define best practices and naming standards. They're warnings, not blockers.\n\nReal-World Example: Multi-Team Governance\n\nHere's how a large organization enforces standards across teams:\n\nEnforcing in CI/CD\n\nAdd validation to your CI/CD pipeline:\n\nResult: Violations block merges automatically.\n\nKey Takeaways\n\nConstraints = Hard rules that block CI/CD\nConventions = Best practices that warn\nVersion control policies with code\nAutomate enforcement in CI/CD\nScale governance across teams\n\nNext Steps\n\nTry writing constraints for your organization\nIntegrate validation into your CI/CD pipeline\nTrack compliance across services\nIterate based on team feedback\n\nYou now know how to codify architectural policies. Let's enforce them automatically!",
    "url": "https://sruja.ai/courses/advanced-architects/module-1-policy-as-code/lesson-1",
    "type": "course",
    "category": "advanced-architects",
    "summary": "Codify architectural rules as executable constraints that prevent violations.",
    "weight": 1
  },
  {
    "objectID": "course-advanced-architects/module-1-policy-as-code/lesson-2",
    "title": "Lesson 2: Enforcing Policies in CI/CD",
    "content": "Lesson 2: Enforcing Policies in CI/CD\n\nThe Goal: Automatic Enforcement\n\nPolicies are useless if they're not enforced. This lesson shows you how to integrate Sruja validation into CI/CD so violations are caught before they reach production.\n\nBasic CI/CD Integration\n\nGitHub Actions\n\nGitLab CI\n\nAdvanced: Policy Violation Reporting\n\nGenerate compliance reports in CI/CD:\n\nMulti-Repository Governance\n\nFor organizations with multiple repositories, create a shared policy file:\n\nPre-commit Hooks\n\nCatch violations before they're committed:\n\nIntegration with PR Reviews\n\nAdd architecture validation as a required check:\n\nResult: PRs can't be merged until architecture is valid.\n\nMonitoring Compliance\n\nTrack compliance over time:\n\nKey Takeaways\n\nIntegrate early ‚Äî Validate in CI/CD, not manually\nFail fast ‚Äî Block merges on violations\nReport compliance ‚Äî Track metrics over time\nShare policies ‚Äî Use central policy files for multi-repo orgs\nPre-commit hooks ‚Äî Catch issues before they're committed\n\nReal-World Pattern\n\nLarge organization pattern:\n\nNext Steps\n\nSet up CI/CD validation for your architecture\nCreate shared policy files for your organization\nAdd pre-commit hooks for faster feedback\nTrack compliance metrics over time\n\nYou now know how to enforce policies automatically. Governance at scale! üöÄ",
    "url": "https://sruja.ai/courses/advanced-architects/module-1-policy-as-code/lesson-2",
    "type": "course",
    "category": "advanced-architects",
    "summary": "Integrate architectural validation into your CI/CD pipeline to prevent violations automatically.",
    "weight": 2
  },
  {
    "objectID": "course-advanced-architects/module-1-policy-as-code/module-overview",
    "title": "Module Overview: Policy as Code",
    "content": "Module Overview: Policy as Code\n\nTurn architectural standards into executable code that runs in CI/CD.\n\nThis module teaches you how to write architectural policies as code, enforce them automatically, and scale governance across large organizations.\n\nLearning Goals\n\nWrite constraints and conventions in Sruja\nEnforce layer boundaries and service dependencies\nPrevent architectural violations in CI/CD\nTrack compliance across services and teams\n\nWhy Policy as Code?\n\nTraditional approach:\nManual code reviews\nArchitecture decision documents (ADRs) that get outdated\nInconsistent enforcement across teams\nCompliance audits are manual and risky\n\nPolicy as Code approach:\nAutomated validation in CI/CD\nPolicies version-controlled with code\nConsistent enforcement across all teams\nCompliance reports generated automatically\n\nWhat You'll Build\n\nBy the end of this module, you'll have:\n\n‚úÖ A policy file that enforces architectural standards\n‚úÖ CI/CD integration that blocks violations\n‚úÖ Compliance tracking across services\n‚úÖ Patterns you can apply to your organization\n\nEstimated Time\n\n5 minutes ‚Äî Quick, focused lessons.\n\nPrerequisites\n\nBasic Sruja syntax (see Getting Started)\nFamiliarity with CI/CD (GitHub Actions, GitLab CI, etc.)\nUnderstanding of architectural governance challenges\n\nChecklist\n\n[ ] Understand how to write constraints\n[ ] Know how to enforce conventions\n[ ] Can integrate policies into CI/CD\n[ ] Can track compliance across services",
    "url": "https://sruja.ai/courses/advanced-architects/module-1-policy-as-code/module-overview",
    "type": "course",
    "category": "advanced-architects",
    "summary": "Codify architectural standards as executable policies that prevent violations automatically.",
    "weight": 0
  },
  {
    "objectID": "course-agentic-ai/course-overview",
    "title": "Agentic AI with Sruja",
    "content": "Agentic AI with Sruja\n\nLearn to design agent-based AI systems with clear boundaries, interfaces, and governance using Sruja DSL.",
    "url": "https://sruja.ai/courses/agentic-ai/course-overview",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Model agent systems, RAG pipelines, and governance with Sruja DSL.",
    "description": "A practical course on architecting agentic AI systems using Sruja: foundations, RAG, orchestration, and production governance.",
    "difficulty": "advanced",
    "topic": "ai"
  },
  {
    "objectID": "course-agentic-ai/module-1-fundamentals/lesson-1",
    "title": "What is Agentic AI?",
    "content": "What is Agentic AI?\n\nTraditional LLM applications often follow a linear chain: Prompt -> LLM -> Output. Agentic AI breaks this linearity by introducing a control loop where the model decides what to do next.\n\nThe Control Loop\n\nAn agent typically operates in a loop:\n\nObserve: Read input or environment state.\nReason: Decide on an action (using an LLM).\nAct: Execute the action (call a tool).\nReflect: Observe the result of the action.\nRepeat: Continue until the goal is met.\n\nAgent vs. Chain\n\n| Feature              | Chain (e.g., LangChain Runnable)        | Agent                         |\n| :------------------- | :-------------------------------------- | :---------------------------- |\n| Control Flow     | Hardcoded by developer                  | Determined dynamically by LLM |\n| Flexibility      | Rigid, predictable                      | Adaptive, handles ambiguity   |\n| Failure Recovery | Often brittle (fails if one step fails) | Can self-correct and retry    |\n| Complexity       | Lower                                   | Higher (requires guardrails)  |\n\nWhy Sruja for Agents?\n\nModeling agents is complex because relationships are often dynamic. Sruja helps by:\n\nVisualizing Dependencies: Showing which agents use which tools.\nDefining Boundaries: separating the cognitive engine (LLM) from the execution layer (Tools).\nDocumenting Flows: Tracing the decision loop.",
    "url": "https://sruja.ai/courses/agentic-ai/module-1-fundamentals/lesson-1",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Defining Agentic AI and its shift from static chains to dynamic loops.",
    "difficulty": "intermediate",
    "weight": 10,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-agentic-ai/module-1-fundamentals/lesson-2",
    "title": "Core Components: Agents, Tools, Memory",
    "content": "Core Components\n\nEvery agentic system consists of a few fundamental building blocks.\n\nThe Agent (The Brain)\n\nThe core logic that orchestrates the workflow. It holds the \"system prompt\" or persona and manages the context window.\n\nTools (The Hands)\n\nCapabilities exposed to the agent. These can be:\n\nAPIs: Weather, Stock Prices, Internal Databases.\nFunctions: Calculator, Code Interpreter.\nRetrievers: RAG search against vector databases.\n\nMemory (The Context)\n\nShort-term Memory: The current conversation history and scratchpad of thoughts.\nLong-term Memory: Vector databases or persistent storage for recalling past interactions.\n\nModeling in Sruja\n\nWe can map these components to Sruja elements:\n\nAgent ->  or \nTool ->  or external \nMemory ->",
    "url": "https://sruja.ai/courses/agentic-ai/module-1-fundamentals/lesson-2",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Deep dive into the anatomy of an AI agent.",
    "difficulty": "intermediate",
    "weight": 20,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-agentic-ai/module-1-fundamentals/module-overview",
    "title": "Fundamentals of Agentic AI",
    "content": "Fundamentals of Agentic AI\n\nWelcome to the first module of the Agentic AI Architecture course. In this module, we will explore what makes an AI system \"agentic\" and how to model its components using Sruja.\n\nLearning Objectives\n\nBy the end of this module, you will be able to:\n\nDefine Agentic AI: Understand the difference between passive LLM calls and autonomous agents.\nIdentify Core Components: Recognize Agents, Tools, Memory, and Planning modules.\nModel Basic Agents: Use Sruja to represent a simple agent with tools.\n\nLessons\n\nWhat is Agentic AI?\nCore Components",
    "url": "https://sruja.ai/courses/agentic-ai/module-1-fundamentals/module-overview",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Understand the core concepts of AI agents, tools, and cognitive architectures.",
    "description": "This module covers the building blocks of Agentic AI systems, distinguishing them from traditional LLM chains.",
    "difficulty": "intermediate",
    "weight": 10,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-agentic-ai/module-2-patterns/lesson-1",
    "title": "The ReAct Pattern",
    "content": "The ReAct Pattern\n\nReAct (Reasoning + Acting) is a prompting strategy where the model explicitly generates:\n\nThought: Reasoning about the current state.\nAction: The tool call to make.\nObservation: The result of the tool call.\n\nThis loop continues until the agent decides it has enough information to answer.\n\nSruja Model\n\nWe can model this flow using a  or  in Sruja to visualize the sequence.\n\nThis visualization helps stakeholders understand the latency and cost implications of the multiple steps involved in a single user request.",
    "url": "https://sruja.ai/courses/agentic-ai/module-2-patterns/lesson-1",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Modeling the Reason + Act loop.",
    "difficulty": "advanced",
    "weight": 10,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-agentic-ai/module-2-patterns/lesson-2",
    "title": "Multi-Agent Orchestration",
    "content": "Multi-Agent Orchestration\n\nFor complex domains, a single agent can get confused. Multi-Agent Systems (MAS) split responsibilities among specialized agents.\n\nSupervisor Pattern\n\nA central \"Supervisor\" agent routes tasks to worker agents and aggregates results.\n\nHierarchical Teams\n\nAgents can manage other agents, forming a tree structure. This is useful for large-scale operations like software development (Manager -> Tech Lead -> Developer).\n\nNetwork/Mesh\n\nAgents communicate directly with each other without a central supervisor. This is more decentralized but harder to debug. Sruja's relationship visualization shines here by mapping the allowable communication paths.",
    "url": "https://sruja.ai/courses/agentic-ai/module-2-patterns/lesson-2",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Supervisor, Hierarchical, and Mesh architectures.",
    "difficulty": "advanced",
    "weight": 20,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-agentic-ai/module-2-patterns/module-overview",
    "title": "Agentic Patterns",
    "content": "Agentic Patterns\n\nSingle-loop agents are powerful, but complex tasks often require structured patterns or multiple agents working together.\n\nLearning Objectives\n\nUnderstand ReAct: The foundational pattern of Reason + Act.\nExplore Multi-Agent Systems: How agents collaborate.\nModel Orchestration: Supervisor vs. Hierarchical flows.\n\nLessons\n\nThe ReAct Pattern\nMulti-Agent Orchestration",
    "url": "https://sruja.ai/courses/agentic-ai/module-2-patterns/module-overview",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Common architectural patterns for building reliable agents.",
    "description": "Learn about ReAct, Plan-and-Solve, and Multi-Agent Orchestration.",
    "difficulty": "advanced",
    "weight": 20,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-agentic-ai/module-3-modeling/lesson-1",
    "title": "Modeling Strategies",
    "content": "Modeling Strategies\n\nHow should you represent an agent in Sruja? It depends on the scope of your diagram.\n\nLevel 1: System Context\n\nIf your AI is a product that users interact with, model it as a System.\n\nLevel 2: Container View\n\nIf you are designing the internals, agents are often Containers (deployable units).\n\nLevel 3: Component View\n\nIf you are designing a single agent's logic, the specific tools and chains are Components.\n\nUsing Metadata\n\nUse metadata to capture AI-specific details:",
    "url": "https://sruja.ai/courses/agentic-ai/module-3-modeling/lesson-1",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Choosing the right abstraction level.",
    "difficulty": "advanced",
    "weight": 10,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-agentic-ai/module-3-modeling/lesson-2",
    "title": "Governance and Safety",
    "content": "Governance and Safety\n\nAutonomous agents can be unpredictable. Architecture-as-Code allows us to define constraints to ensure safety.\n\nDefining Requirements\n\nUse  blocks to specify safety properties.\n\nPolicy as Code\n\nYou can enforce rules about which agents can access which tools.\n\nGuardrails\n\nModel your guardrails explicitly as components that intercept messages.",
    "url": "https://sruja.ai/courses/agentic-ai/module-3-modeling/lesson-2",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Defining constraints and policies for autonomous agents.",
    "difficulty": "advanced",
    "weight": 20,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-agentic-ai/module-3-modeling/module-overview",
    "title": "Modeling Agents in Sruja",
    "content": "Modeling Agents in Sruja\n\nIn this final module, we will bring everything together and learn the best practices for modeling agentic systems in Sruja.\n\nLearning Objectives\n\nGranularity: Deciding when to model an agent as a System, Container, or Component.\nMetadata: Using tags to track models, costs, and latency.\nGovernance: Defining policies for AI safety.\n\nLessons\n\nModeling Strategies\nGovernance and Safety",
    "url": "https://sruja.ai/courses/agentic-ai/module-3-modeling/module-overview",
    "type": "course",
    "category": "agentic-ai",
    "summary": "Best practices for documenting Agentic systems.",
    "description": "Learn how to use Sruja's features to effectively model AI architectures.",
    "difficulty": "advanced",
    "weight": 30,
    "topic": "agentic-ai"
  },
  {
    "objectID": "course-ecommerce-platform/course-overview",
    "title": "Ecommerce Platform: Architecture and Operations",
    "content": "Ecommerce Platform: Architecture and Operations\n\nOverview\nEnd-to-end view of building and operating a modern ecommerce platform\nBalances product vision with technical architecture and operational excellence\n\nLearning Goals\nModel domain entities, flows, and services for ecommerce\nDesign modular architecture and platform capabilities\nPlan SDLC, release management, and operational readiness\nGovern changes with policies, SLOs, and compliance\n\nPrerequisites\nFamiliarity with web services, data stores, messaging, and CI/CD\n\nCourse Structure\nModule 1: Vision & Basics\nModule 3: Architecture & Tech\nModule 4: SDLC\nModule 5: Ops\nModule 6: Evolution\nModule 7: Governance\n\nWhere to Start\nBegin with Module 1 to align vision and fundamentals, then proceed in order",
    "url": "https://sruja.ai/courses/ecommerce-platform/course-overview",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "From vision and basics to architecture tech, SDLC, operations, evolution, and governance.",
    "weight": 1
  },
  {
    "objectID": "course-ecommerce-platform/module-1-vision-basics/lesson-1",
    "title": "Lesson 1: Introduction to the Project",
    "content": "Lesson 1: Introduction to the Project\n\nIn this course, we are building Shopify-lite. Let's define what that means.\n\nThe Concept\nWe are building a multi-tenant e-commerce platform. This means a single instance of our software will serve multiple different online stores (tenants), each with their own products, orders, and customers.\n\nCore Capabilities\nOur system must support:\nStorefronts: Fast, SEO-friendly pages for browsing products.\nAdmin Dashboard: Where merchants manage their inventory.\nCheckout: A secure, reliable way to take money.\nInventory Management: Real-time stock tracking to prevent overselling.\n\nThe \"Why\"\nWhy build this? Because it touches on every hard problem in distributed systems:\n   Consistency: Inventory must be accurate.\n   Availability: Checkout must never go down.\n   Scalability: We need to handle flash sales.\n   Security: We are handling credit card data (PCI Compliance).\n\nThe Role of Sruja\nMost tutorials start by running . We will not do that yet.\n\nWe will start by creating a  file. Why? Because we need to agree on the structure before we get lost in the details. Sruja will be our shared whiteboard, our documentation, and our validator.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-1-vision-basics/lesson-1",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Defining the scope of our Shopify-lite platform.",
    "weight": 1
  },
  {
    "objectID": "course-ecommerce-platform/module-1-vision-basics/lesson-2",
    "title": "Lesson 2: Setting up the Workspace",
    "content": "Lesson 2: Setting up the Workspace\n\nLet's get our hands dirty. We will set up a professional project structure that separates our architectural definitions from our implementation code, and aligns with product requirements.\n\nReal-World Scenario: Starting a New Product\n\nContext: You're building Shopify-lite, a multi-tenant e-commerce platform. Before writing code, you need to:\n\nAlign engineering, product, and DevOps on the architecture\nDocument requirements alongside the design\nSet up a structure that scales as the team grows\n\nProduct team needs: Clear documentation of what we're building and why.\n\nEngineering team needs: Technical architecture that supports product goals.\n\nDevOps team needs: Deployment and operational considerations from day one.\n\nDirectory Structure\n\nCreate a new directory for your project:\n\nWe will use the following structure (based on real-world best practices):\n\nWhy this structure?\n\nSeparation of concerns: Architecture separate from code\nVersion control: Track architecture changes over time\nCI/CD ready: Easy to integrate validation\nTeam collaboration: Product, engineering, and DevOps can all contribute\n\nInstalling Sruja\n\nIf you haven't already, install the Sruja CLI:\n\nFor DevOps: Add to your CI/CD pipeline (we'll cover this in Module 5).\n\nHello World: The Context View\n\nCreate your first file at . We'll start with a high-level Context View to define the boundaries of our system.\n\nProduct Requirements First\n\nBefore modeling architecture, let's capture product requirements:\n\nThe Architecture Context\n\nNow let's model the system context:\n\nWhy This Approach?\n\nFor Product Teams:\n\nRequirements are visible and linked to architecture\nBusiness goals are documented\nSuccess metrics are clear\n\nFor Engineering:\n\nArchitecture shows what to build\nRequirements guide implementation priorities\nExternal dependencies are identified early\n\nFor DevOps:\n\nUptime SLA (R6) informs infrastructure planning\nPerformance requirements (R5) guide monitoring setup\nScale requirements (R4) inform capacity planning\n\nVisualize It\n\nRun the Sruja CLI to visualize your architecture:\n\nYou should see a clean diagram showing:\n\nYour platform in the center\nUsers (Merchant, Shopper) on the left\nExternal systems (Stripe, EmailService) on the right\nInteractions between them\n\nValidate Your Architecture\n\nBefore moving forward, validate your architecture:\n\nCommon issues to watch for:\n\nMissing relations (orphan elements)\nInvalid references\nUnclear descriptions\n\nSet Up CI/CD (DevOps Best Practice)\n\nCreate :\n\nWhy this matters: Catches architecture errors before they reach production.\n\nKey Takeaways\n\nStart with requirements: Document what you're building and why\nModel context first: Understand system boundaries before diving into details\nLink requirements to architecture: Show how architecture supports product goals\nSet up CI/CD early: Automate validation from day one\nThink about all stakeholders: Product, engineering, and DevOps all need different views\n\nExercise: Create Your Context View\n\nTasks:\n\nCreate a new project directory\nInstall Sruja CLI\nCreate  with:\n   - At least 3 product requirements\n   - System context (your system, users, external systems)\n   - High-level interactions\nValidate and visualize your architecture\n(Optional) Set up CI/CD validation\n\nTime: 15 minutes\n\nFurther Reading\n\nTutorial: CLI Basics\nTutorial: Validation & Linting\nDocs: Requirements Concepts\nCourse: System Design 101 - Module 1: Fundamentals",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-1-vision-basics/lesson-2",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Initializing the project structure and creating the first architecture file with product requirements.",
    "weight": 2
  },
  {
    "objectID": "course-ecommerce-platform/module-1-vision-basics/module-overview",
    "title": "Module Overview: Vision & Basics",
    "content": "Module Overview: Vision & Basics\n\nGoals:\nDefine project vision and scope\nIdentify key systems and stakeholders\nDraft initial architecture map\n\nEstimated time: 45‚Äì60 minutes\n\nChecklist:\nVision statement\nStakeholders listed\nInitial system map in Sruja",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-1-vision-basics/module-overview",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Goals, outcomes, and a quick checklist for Module 1.",
    "weight": 0
  },
  {
    "objectID": "course-ecommerce-platform/module-3-architecture-tech/lesson-1",
    "title": "Lesson 1: Monolith vs. Microservices (ADRs)",
    "content": "Lesson 1: Monolith vs. Microservices\n\nThis is the most debated topic in software engineering. Should we start with a monolith or microservices?\n\nThe Trade-off\n\nMonolith: Easier to develop, deploy, and debug. Harder to scale teams and components independently.\nMicroservices: Independent scaling and deployment. High complexity (network, consistency, observability).\n\nOur Decision: Modular Monolith\n\nFor Shopify-lite, we will start with a Modular Monolith. We will have clear boundaries (modules) but deploy as a single unit initially. This gives us speed now and flexibility later.\n\nDocumenting with ADRs\n\nWe don't just make this decision; we document it so future engineers know why.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-3-architecture-tech/lesson-1",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Using Architecture Decision Records to document critical choices.",
    "weight": 1
  },
  {
    "objectID": "course-ecommerce-platform/module-3-architecture-tech/lesson-2",
    "title": "Lesson 2: Selecting the Stack",
    "content": "Lesson 2: Selecting the Stack\n\nWe have our domains. Now we need to pick the tools to build them.\n\nThe Stack\n\nFrontend: Next.js (React) - Great for SEO and performance.\nBackend: Go (Golang) - High performance, great concurrency for e-commerce.\nDatabase: PostgreSQL - Reliable, ACID compliant (critical for money).\n\nModeling in Sruja\n\nWe define these choices in our  definitions.\n\nBy documenting , we make it clear to new developers what skills they need.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-3-architecture-tech/lesson-2",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Choosing technologies and documenting them in Containers.",
    "weight": 2
  },
  {
    "objectID": "course-ecommerce-platform/module-3-architecture-tech/lesson-3",
    "title": "Lesson 3: API-First Design",
    "content": "Lesson 3: API-First Design\n\nBefore frontend and backend teams start working, they need to agree on the API. This is where API-First Design comes in.\n\nAPI-First Design\n\nInstead of writing code and then documenting it, we define the API schema first using OpenAPI. This allows frontend devs to mock the API while backend devs build it.\n\nSruja's Role: Architecture Modeling\n\nSruja models which services exist and how they connect. For detailed API schemas (endpoints, request/response structures), use OpenAPI/Swagger.\n\nBest Practice: Separation of Concerns\n\nSruja: Models architecture (services, containers, relationships)\nOpenAPI: Defines API schemas (endpoints, request/response structures)\nTogether: Architecture shows the big picture, OpenAPI shows the details\n\nWhy this matters\n\nRight tool for the job: Architecture modeling vs. API specification\nIndustry standard: OpenAPI is widely supported by tools and frameworks\nCode Generation: Generate Go structs, TypeScript interfaces, and client SDKs from OpenAPI",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-3-architecture-tech/lesson-3",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Design-first API development using OpenAPI and Sruja together.",
    "weight": 3
  },
  {
    "objectID": "course-ecommerce-platform/module-3-architecture-tech/lesson-4",
    "title": "Lesson 4: API Design & Integration",
    "content": "Lesson 4: API Design & Integration\n\nWhy API Design Matters\n\nWell-designed APIs define stable interfaces between services; they reduce coupling and surprises. However, API schemas belong in OpenAPI, not in Sruja.\n\nSruja's Role: Architecture Modeling\n\nSruja focuses on architectural concerns: which services exist, how they relate, and what they do. For detailed API schemas, use OpenAPI/Swagger.\n\nBest Practice\n\nModel architecture in Sruja: Services, containers, relationships\nDefine API schemas in OpenAPI: Request/response structures, endpoints\nLink them: Reference OpenAPI files in your architecture documentation\n\nPractice\n\nModel the  service in Sruja\nCreate an OpenAPI spec for the  endpoint\nShow how they work together",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-3-architecture-tech/lesson-4",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Design stable APIs and integrate with external services.",
    "weight": 4
  },
  {
    "objectID": "course-ecommerce-platform/module-3-architecture-tech/module-overview",
    "title": "Module Overview: Architecture & Tech",
    "content": "Module Overview: Architecture & Tech\n\nGoals:\nModel systems, containers, and key relations\nSelect technology stack per container\nCapture ADRs for major choices\n\nEstimated time: 60‚Äì90 minutes\n\nChecklist:\nC4 L1/L2 map\nContainer tech set\nADR drafts",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-3-architecture-tech/module-overview",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Model the architecture and pick enabling technologies.",
    "weight": 0
  },
  {
    "objectID": "course-ecommerce-platform/module-4-sdlc/lesson-1",
    "title": "Lesson 1: The Local Loop",
    "content": "Lesson 1: The Local Loop\n\nHow do you use Sruja while you code?\n\nThe Blueprint\nKeep  open in a split pane. It is your map. Before you create a new file or function, verify where it fits in the architecture.\n\nGenerating Boilerplate (Future)\nImagine running  to scaffold your Go microservices based on your  definitions. While this feature is in development, you can manually align your folder structure to your architecture.\n\nLocal Validation\nBefore you commit, run:\n\nThis checks for:\n   Orphans: Components defined but never used.\n   Broken Links: Relations pointing to non-existent elements.\nPolicy Violations: Did you accidentally introduce a circular dependency?",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-4-sdlc/lesson-1",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Using Sruja for local development and testing.",
    "weight": 1
  },
  {
    "objectID": "course-ecommerce-platform/module-4-sdlc/lesson-2",
    "title": "Lesson 2: Environments (Deployment Nodes)",
    "content": "Lesson 2: Environments\n\nYour software runs differently in Production than it does on your laptop. Sruja models this using Deployment Nodes.\n\nModeling Production\n\nModeling Local Dev\n\nWhy model this?\nIt helps you visualize the physical differences. Maybe in Prod you have a Load Balancer that doesn't exist locally. Sruja makes these differences explicit.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-4-sdlc/lesson-2",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Modeling Dev, Staging, and Production environments.",
    "weight": 2
  },
  {
    "objectID": "course-ecommerce-platform/module-4-sdlc/lesson-3",
    "title": "Lesson 3: CI/CD Pipeline (Validation)",
    "content": "Lesson 3: CI/CD Pipeline\n\nArchitecture compliance shouldn't be a manual review process. It should be a build step.\n\nThe Pipeline\nIn your GitHub Actions or Jenkins pipeline, add a step to install and run Sruja.\n\nBreaking the Build\nIf a developer introduces a violation (e.g., \"Frontend talks directly to Database\"),  will exit with a non-zero code, failing the build.\n\nThis is Governance as Code. You stop architectural drift before it merges.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-4-sdlc/lesson-3",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Automating architectural checks in your pipeline.",
    "weight": 3
  },
  {
    "objectID": "course-ecommerce-platform/module-5-ops/lesson-1",
    "title": "Lesson 1: Deployment Strategies",
    "content": "Lesson 1: Deployment Strategies\n\nReal-World Problem: Black Friday Deployment\n\nScenario: You need to deploy a critical payment fix on Black Friday morning. The system handles $10M/hour in transactions. How do you deploy without risking downtime?\n\nWrong approach: Deploy directly to production and hope nothing breaks.\n\nRight approach: Use a proven deployment strategy that minimizes risk.\n\nWhy Deployment Strategies Matter\n\nIndustry statistics:\n\n60% of outages are caused by bad deployments (Gartner, 2023)\nAverage cost of downtime: $5,600/minute for large enterprises\n99.9% uptime = 8.76 hours downtime/year (still too much for critical systems)\n\nProduct team perspective: Every minute of downtime means lost revenue, frustrated customers, and damaged reputation.\n\nDevOps perspective: Need automated, repeatable, safe deployment processes.\n\nBlue/Green Deployment\n\nConcept\n\nYou have two identical environments (Blue and Green). One is live, the other is idle. You deploy to the idle one, test it, and then switch traffic.\n\nReal-World Example: E-Commerce Platform\n\nDevOps Workflow\n\nDeploy to Green: Deploy new version to idle Green environment\nSmoke Tests: Run automated health checks and integration tests\nLoad Testing: Verify Green can handle production load\nSwitch Traffic: Use load balancer to route 100% traffic to Green\nMonitor: Watch metrics for 30 minutes\nRollback Plan: Keep Blue ready for instant rollback if issues occur\n\nWhen to Use Blue/Green\n\n‚úÖ Good for:\n\nCritical services (payment, authentication)\nStateful applications with database replication\nZero-downtime requirements\nLarge, infrequent deployments\n\n‚ùå Not ideal for:\n\nFrequent small deployments (wasteful)\nStateless services (Canary is better)\nLimited infrastructure budget\n\nCost Consideration\n\nExample: Running duplicate production environment\n\nCost: 2x infrastructure during deployment window\nTypical window: 1-2 hours\nTrade-off: Higher cost for lower risk\n\nCanary Deployment\n\nConcept\n\nYou roll out the new version to a small percentage of users (e.g., 5%) and monitor for errors. Gradually increase if metrics look good.\n\nReal-World Example: API Service\n\nGradual Rollout Strategy\n\nDocument the rollout plan in metadata:\n\nReal-World Rollout Timeline\n\nExample: Deploying new API version\n\nWhen to Use Canary\n\n‚úÖ Good for:\n\nStateless services\nFrequent deployments (multiple per day)\nA/B testing new features\nPerformance-sensitive changes\nLimited infrastructure budget\n\n‚ùå Not ideal for:\n\nDatabase schema changes (requires coordination)\nBreaking API changes (incompatible versions)\nServices with complex state\n\nRolling Deployment\n\nConcept\n\nGradually replace old instances with new ones, one at a time.\n\nWhen to Use Rolling\n\n‚úÖ Good for:\n\nKubernetes-native deployments\nStateless microservices\nCost-effective (no duplicate infrastructure)\nAutomated rollback via health checks\n\nFeature Flags: Deployment Strategy Alternative\n\nSometimes you don't need a deployment strategy‚Äîuse feature flags instead:\n\nUse case: Deploy code with new feature disabled, then gradually enable via feature flags.\n\nMonitoring During Deployment\n\nModel your observability during deployments:\n\nReal-World Case Study: Netflix Canary Deployment\n\nChallenge: Deploy to 100M+ users without downtime\n\nSolution:\n\nCanary deployment to 1% of users\nAutomated analysis of 50+ metrics\nAutomatic rollback if any metric degrades\nGradual rollout over 6 hours\n\nResult: 99.99% deployment success rate\n\nKey Takeaways\n\nChoose the right strategy: Blue/Green for critical, Canary for frequent, Rolling for cost-effective\nAutomate everything: Use CI/CD pipelines to automate deployment and rollback\nMonitor aggressively: Track error rates, latency, and resource usage during deployment\nHave a rollback plan: Always be ready to rollback within minutes\nDocument in Sruja: Model your deployment strategy so teams understand the process\n\nExercise: Design a Deployment Strategy\n\nScenario: You're deploying a new checkout flow for an e-commerce platform. The system processes $1M/hour.\n\nTasks:\n\nChoose a deployment strategy (Blue/Green, Canary, or Rolling)\nModel it in Sruja with deployment nodes\nAdd monitoring and rollback criteria\nDocument the rollout timeline\n\nTime: 15 minutes\n\nFurther Reading\n\nTutorial: Deployment Modeling\nCourse: System Design 101 - Module 4: Production Readiness\nDocs: Deployment Concepts",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-5-ops/lesson-1",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Production-ready deployment strategies: Blue/Green, Canary, and real-world patterns.",
    "weight": 1
  },
  {
    "objectID": "course-ecommerce-platform/module-5-ops/lesson-2",
    "title": "Lesson 2: Debugging Performance (Structural Analysis)",
    "content": "Lesson 2: Debugging Performance\n\nScenario: It's Black Friday. The \"Checkout\" page is loading in 5 seconds. Why?\n\nThe Wrong Way\n\nStart reading random logs or guessing which database query is slow.\n\nThe Structural Way\n\nLook at your Sruja User Journey for \"Purchase\".\n\nWait, the  call is synchronous and takes 2 seconds? And it's in the critical path of the user request?\n\nRoot Cause: We are blocking the user while waiting for the bank.\n\nThe Fix: Asynchronous Processing\n\nWe need to decouple the user request from the payment processing.\n\nIntroduce a Queue: The Checkout service puts a message on a queue.\nWorker: A background worker processes the payment.\nUpdate: The frontend polls for status or uses WebSockets.\n\nLet's update the architecture:\n\nBy visualizing the flow, the bottleneck (and the fix) becomes obvious.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-5-ops/lesson-2",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Using your architecture diagram to find bottlenecks.",
    "weight": 2
  },
  {
    "objectID": "course-ecommerce-platform/module-5-ops/lesson-3",
    "title": "Lesson 3: Observability",
    "content": "Lesson 3: Observability\n\nYou can't fix what you can't see. Observability is about understanding the internal state of your system from the outside.\n\nThe Three Pillars\n\nLogs: \"What happened?\" (Error: Payment Failed)\nMetrics: \"How often?\" (Error Rate: 5%)\nTraces: \"Where?\" (Checkout -> API -> DB)\n\nMapping to Sruja\n\nYour Sruja components should map 1:1 to your observability dashboards.\n\nSystem  -> Dashboard \nContainer  -> Metric \n\nStandardizing with Policies\n\nYou can enforce observability standards using Sruja Policies.\n\nThis ensures every new service you build comes with the necessary hooks for monitoring.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-5-ops/lesson-3",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Mapping metrics and logs to your architecture.",
    "weight": 3
  },
  {
    "objectID": "course-ecommerce-platform/module-5-ops/lesson-4",
    "title": "Lesson 4: Ops SLOs & Monitoring",
    "content": "Lesson 4: Ops SLOs & Monitoring\n\nSLOs in Ops\n\nTranslate business expectations into measurable targets; build dashboards around them.\n\nSruja: Define SLOs\n\nPractice\n\nSet  latency targets for checkout and search.\nMap alerts to SLO windows; define runbooks for breaches.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-5-ops/lesson-4",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Set SLO targets and align alerts and dashboards.",
    "weight": 4
  },
  {
    "objectID": "course-ecommerce-platform/module-6-evolution/lesson-1",
    "title": "Lesson 1: The \"Good\" Problem (Traffic Spikes)",
    "content": "Lesson 1: The \"Good\" Problem\n\nYou have too many users. Your single database is melting. It's time to scale.\n\nThe Bottleneck\n\nOur monitoring (Module 5) shows that  checks are 80% of the database load.\n\nThe Refactor: Splitting the Monolith\n\nWe decide to extract  into its own microservice with its own database.\n\nStep 1: Update the Architecture\n\nWe change  from a logical domain inside the monolith to a physical .\n\nStep 2: Update the Architecture\n\nThe  can no longer call  functions directly. It must make a gRPC call. Update your OpenAPI specs to reflect the new gRPC interfaces.\n\nWhy Sruja helps\n\nRefactoring is dangerous. Sruja helps you visualize the impact of the change before you write code. You can see exactly which other systems depend on Inventory and ensure you don't break them.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-6-evolution/lesson-1",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Refactoring from Monolith to Microservices when necessary.",
    "weight": 1
  },
  {
    "objectID": "course-ecommerce-platform/module-6-evolution/lesson-2",
    "title": "Lesson 2: Managing Technical Debt",
    "content": "Lesson 2: Managing Technical Debt\n\nEvery codebase has skeletons. The key is to label them.\n\nDeprecating Components\n\nWe decided to move from  to  for lower fees. But we can't switch overnight.\n\nGovernance Policies\n\nWe can enforce this with a policy!\n\nThis prevents developers from accidentally adding dependencies to the system you are trying to kill.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-6-evolution/lesson-2",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Using Deprecation and ADRs to manage legacy code.",
    "weight": 2
  },
  {
    "objectID": "course-ecommerce-platform/module-7-governance/lesson-1",
    "title": "Lesson 1: Security by Design",
    "content": "Lesson 1: Security by Design\n\nSecurity isn't something you \"add on\" at the end. It must be baked into the architecture.\n\nThe Requirement\n\nGDPR Article 32: Personal data must be encrypted.\n\nModeling Security Signals\n\nUse tags and metadata to make security posture explicit.\n\nValidating in CI\n\nRun  in CI to enforce architectural rules (unique IDs, valid references, layering, external boundary checks). Combine with linters to flag missing tags for sensitive resources. This is Compliance as Code.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-7-governance/lesson-1",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Modeling security standards with tags and metadata, validated in CI.",
    "weight": 1
  },
  {
    "objectID": "course-ecommerce-platform/module-7-governance/lesson-2",
    "title": "Lesson 2: Cost Optimization",
    "content": "Lesson 2: Cost Optimization\n\nCloud bills kill startups. Sruja helps you visualize where the money is going.\n\nModeling Cost\nWe can add cost metadata to our deployment nodes.\n\nCost Policies\nUse metadata and CI checks to prevent expensive mistakes in non‚Äëproduction environments.\n\nAdd a CI rule to flag dev nodes exceeding budget thresholds.",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-7-governance/lesson-2",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Tracking and controlling infrastructure costs.",
    "weight": 2
  },
  {
    "objectID": "course-ecommerce-platform/module-7-governance/lesson-3",
    "title": "Lesson 3: Audit Readiness (SOC 2)",
    "content": "Lesson 3: Audit Readiness (SOC 2)\n\nCongratulations! You are now big enough to need a SOC 2 audit. The auditor asks: \"Show me your system diagram and prove that all changes are reviewed.\"\n\nSruja as Evidence\nInstead of scrambling to draw a whiteboard diagram, you point them to your Sruja repository.\n\nCurrent State: The generated diagram is always up to date.\nChange History: Git history shows every architectural change, who made it, and who approved it (via Pull Request).\nControls: Your validation and CI checks prove that you have automated controls for security and compliance.\n\nThe End\nYou have built a scalable, secure, and compliant e-commerce platform. And you did it with a blueprint.\n\nHappy Architecting!",
    "url": "https://sruja.ai/courses/ecommerce-platform/module-7-governance/lesson-3",
    "type": "course",
    "category": "ecommerce-platform",
    "summary": "Using Sruja as evidence for auditors.",
    "weight": 3
  },
  {
    "objectID": "course-production-architecture/course-overview",
    "title": "System Design Interview Mastery",
    "content": "System Design Interview Mastery\n\nCrack your next system design interview. This course teaches you how to approach, design, and model systems that impress interviewers at FAANG companies and top tech firms.\n\nWhy This Course?\n\nSystem design interviews are the most important part of senior engineering interviews. This course gives you:\n‚úÖ Real interview questions from top companies\n‚úÖ Step-by-step approach to tackle any design question\n‚úÖ Sruja modeling to visualize your designs\n‚úÖ Best practices that interviewers look for\n‚úÖ Common pitfalls to avoid\n\nWhat You'll Learn\n\nInterview Strategy: How to approach system design questions systematically\nScaling & Performance: Handle \"design for 1M users\" questions confidently\nArchitecture Patterns: Microservices, caching, load balancing, and more\nTrade-offs: Make informed decisions and explain them clearly\nModeling with Sruja: Use Sruja to visualize and communicate your designs\n\nWho This Course Is For\n\nSoftware engineers preparing for senior/staff level interviews\nCandidates targeting FAANG and top tech companies\nEngineers who want to improve their system design skills\nAnyone preparing for architecture/design interviews\n\nCourse Structure\n\nModule 1: Performance & Scalability Interview Questions\nMaster the most common interview questions about scaling and performance.\n\nInterview Questions Covered:\n\"Design a video streaming platform like YouTube\"\n\"How would you handle 10M concurrent users?\"\n\"Design a system with < 200ms latency\"\n\nModule 2: Modular Architecture & Microservices\nTackle complex system design questions requiring distributed systems knowledge.\n\nInterview Questions Covered:\n\"Design an e-commerce platform\"\n\"Design a ride-sharing service like Uber\"\n\"Design a social media feed\"\n\nModule 3: Governance & Policies (Senior/Staff Level)\nAnswer questions about compliance, governance, and architectural standards.\n\nInterview Questions Covered:\n\"How do you ensure compliance (HIPAA, SOC 2)?\"\n\"How do you enforce architectural standards?\"\n\"Design a system that must comply with regulations\"\n\nPrerequisites\n\nCompleted System Design 101 or equivalent\nFamiliarity with basic Sruja syntax\nUnderstanding of basic system design concepts\n\nEstimated Time\n\n4-5 hours (includes practice exercises)\n\nInterview Success Framework\n\nEach module follows this proven approach:\nUnderstand the Question - Clarify requirements and scope\nDesign the System - High-level architecture first\nModel with Sruja - Visualize your design\nDeep Dive - Discuss scaling, trade-offs, and edge cases\nOptimize - Improve based on feedback\n\nLearning Outcomes\n\nBy the end of this course, you'll be able to:\n‚úÖ Approach any system design question with confidence\n‚úÖ Design scalable systems that handle millions of users\n‚úÖ Explain trade-offs and make informed decisions\n‚úÖ Use Sruja to communicate your designs clearly\n‚úÖ Avoid common interview mistakes\n‚úÖ Impress interviewers with production-ready thinking\n\nReal Interview Questions You'll Master\n\nDesign a URL shortener (bit.ly)\nDesign a video streaming service (YouTube/Netflix)\nDesign a ride-sharing service (Uber/Lyft)\nDesign a social media feed (Twitter/Instagram)\nDesign a chat application (WhatsApp/Slack)\nDesign a search engine (Google)\nDesign a payment system (Stripe)\nDesign a distributed cache (Redis)\n\nReady to ace your next interview? Let's get started! üéØ",
    "url": "https://sruja.ai/courses/production-architecture/course-overview",
    "type": "course",
    "category": "production-architecture",
    "summary": "Ace your system design interviews with real-world scenarios and Sruja modeling.",
    "weight": 0
  },
  {
    "objectID": "course-production-architecture/module-1-performance/lesson-1",
    "title": "Lesson 1: Interview Question - Design a Video Streaming Platform",
    "content": "Lesson 1: Interview Question - Design a Video Streaming Platform\n\nThe Interview Question\n\n\"Design a video streaming platform like YouTube or Netflix that can handle millions of concurrent viewers.\"\n\nThis is a classic system design interview question asked at Google, Netflix, and other top companies. Let's break it down step-by-step.\n\nStep 1: Clarify Requirements (What Interviewers Want to Hear)\n\nBefore jumping into design, always clarify:\n\nYou should ask:\n\n\"What's the scale? How many concurrent viewers?\"\n\"What's the latency requirement? How fast should videos start?\"\n\"What types of videos? Short clips or full movies?\"\n\"Do we need to support live streaming or just on-demand?\"\n\nInterviewer's typical answer:\n\n\"Let's say 10 million concurrent viewers\"\n\"Videos should start within 2 seconds\"\n\"Both short clips and full movies\"\n\"Focus on on-demand for now\"\n\nStep 2: Design the High-Level Architecture\n\nStart with the core components:\n\nClient (mobile app, web browser)\nCDN (Content Delivery Network) - serves videos\nOrigin Server - stores original videos\nAPI Server - handles metadata, user requests\nDatabase - stores video metadata, user data\n\nStep 3: Model with Sruja\n\nLet's model this architecture:\n\nStep 4: Address Scaling (The Key Part)\n\nInterviewer will ask: \"How does this handle 10 million concurrent viewers?\"\n\nThis is where you show your scaling knowledge. Let's add scaling configuration:\n\nWhat Interviewers Look For\n\n‚úÖ Good Answer (What You Just Did)\n\nClarified requirements before designing\nStarted with high-level architecture\nModeled with Sruja to visualize\nAddressed scaling with specific numbers\nExplained trade-offs (CDN vs origin server)\n\n‚ùå Bad Answer (Common Mistakes)\n\nJumping straight to code/implementation details\nNot asking clarifying questions\nDesigning for small scale only\nNot mentioning CDN or caching\nIgnoring database scaling\n\nKey Points to Mention in Interview\n\nCDN for Video Delivery\n\nSay: \"We use a CDN to serve videos from edge locations close to users. This reduces latency and offloads traffic from origin servers.\"\n\nHorizontal Scaling for API\n\nSay: \"The API server scales horizontally from 10 to 1000 instances based on CPU and request rate. This handles traffic spikes during peak hours.\"\n\nDatabase Read Replicas\n\nSay: \"We use read replicas for the database to scale read operations. Writes go to primary, reads can go to any replica.\"\n\nCaching Strategy\n\nSay: \"We cache frequently accessed video metadata in Redis to reduce database load.\"\n\nInterview Practice: Add Caching\n\nInterviewer might ask: \"How do you reduce database load?\"\n\nAdd caching to your design:\n\nUnderstanding Scale Block Fields\n\nMinimum Replicas\n\nInterview tip: \"We keep at least 10 instances running to handle baseline traffic and provide fault tolerance.\"\n\nMaximum Replicas\n\nInterview tip: \"We cap at 1000 instances to control costs. If we need more, we'd need to optimize the architecture first.\"\n\nScaling Trigger\n\nInterview tip: \"We scale based on CPU usage and request rate. When CPU exceeds 75% or requests exceed 10k/sec, we add more instances.\"\n\nReal Interview Example: Capacity Estimation\n\nInterviewer: \"How many API servers do you need for 10M concurrent users?\"\n\nYour answer:\n\n\"Assume each user makes 1 request per minute = 10M requests/minute = ~167k requests/second\"\n\"Each API server handles ~1000 requests/second\"\n\"We need ~167 servers at peak\"\n\"With 2x headroom for spikes: ~350 servers\"\n\"Our scale block allows 10-1000, so we're covered\"\n\nExercise: Practice This Question\n\nDesign a video streaming platform and be ready to explain:\n\nWhy you chose CDN\nHow scaling works\nDatabase scaling strategy\nCaching approach\n\nPractice tip: Time yourself (30-40 minutes) and explain out loud as if in an interview.\n\nCommon Follow-Up Questions\n\nBe prepared for:\n\n\"How do you handle video uploads?\" (Add upload service, queue for processing)\n\"What about live streaming?\" (Add live streaming infrastructure)\n\"How do you ensure availability?\" (Add redundancy, health checks)\n\"What's the cost?\" (Estimate based on scale)\n\nNext Steps\n\nIn the next lesson, we'll learn about SLOs (Service Level Objectives) - another common interview topic about defining performance targets.",
    "url": "https://sruja.ai/courses/production-architecture/module-1-performance/lesson-1",
    "type": "course",
    "category": "production-architecture",
    "summary": "Master scaling questions by designing YouTube/Netflix-style systems.",
    "weight": 1
  },
  {
    "objectID": "course-production-architecture/module-1-performance/lesson-2",
    "title": "Lesson 2: Interview Question - Design a High-Performance Payment System",
    "content": "Lesson 2: Interview Question - Design a High-Performance Payment System\n\nThe Interview Question\n\n\"Design a payment processing system that can handle 1 million transactions per second with 99.99% availability and < 100ms latency.\"\n\nThis question tests your understanding of:\n\nPerformance requirements (SLOs)\nHigh availability\nLow latency systems\nTrade-offs between consistency and performance\n\nStep 1: Clarify Requirements\n\nYou should ask:\n\n\"What's the transaction volume? Peak vs average?\"\n\"What's the availability requirement? 99.9% or 99.99%?\"\n\"What's the latency requirement? P95 or P99?\"\n\"What about consistency? Do we need strong consistency?\"\n\nInterviewer's answer:\n\n\"1M transactions/second at peak\"\n\"99.99% availability (four nines)\"\n\"< 100ms p95 latency\"\n\"Strong consistency required (it's money!)\"\n\nStep 2: Design with SLOs in Mind\n\nThis is where SLOs (Service Level Objectives) come in. Interviewers love when you think about measurable targets.\n\nLet's model the payment system with explicit SLOs:\n\nWhat Interviewers Look For\n\n‚úÖ Good Answer (What You Just Did)\n\nDefined SLOs explicitly - Shows you think about measurable targets\nAddressed all requirements - Availability, latency, throughput\nExplained trade-offs - Strong consistency vs performance\nScalability - Showed how to handle 1M txn/s\nRedundancy - Multiple replicas, failover strategies\n\n‚ùå Bad Answer (Common Mistakes)\n\nNot defining SLOs or performance targets\nIgnoring availability requirements\nNot explaining how to achieve 99.99% availability\nNot addressing consistency requirements\nNo capacity estimation\n\nKey Points to Mention in Interview\n\nAvailability (99.99% = Four Nines)\n\nSay: \"99.99% availability means 52.6 minutes of downtime per year. To achieve this, we need:\n\nMultiple data centers (active-active)\nAutomatic failover\nHealth checks and monitoring\nDatabase replication with automatic promotion\"\n\nLatency (< 100ms p95)\n\nSay: \"To achieve < 100ms latency, we:\n\nUse in-memory cache (Redis) for hot data\nKeep database queries simple and indexed\nUse connection pooling\nMinimize network hops\nConsider async processing for non-critical paths\"\n\nThroughput (1M txn/s)\n\nSay: \"To handle 1M transactions/second:\n\nHorizontal scaling: 100-10,000 API instances\nDatabase sharding by transaction ID\nRead replicas for scaling reads\nCaching frequently accessed data\nAsync processing for non-critical operations\"\n\nStrong Consistency\n\nSay: \"Since this is financial data, we need strong consistency:\n\nAll writes go to primary database\nRead replicas are eventually consistent (ok for reads)\nUse distributed transactions for critical operations\nTrade-off: Slightly higher latency for correctness\"\n\nUnderstanding SLO Types (Interview Context)\n\nAvailability SLO\n\nInterviewer asks: \"How do you ensure 99.99% availability?\"\n\nYour answer with SLO:\n\nExplain: \"We target 99.99% (four nines), which allows 52.6 minutes downtime per year. Currently at 99.97%, so we're close but need to improve redundancy.\"\n\nLatency SLO\n\nInterviewer asks: \"How fast should payments process?\"\n\nYour answer with SLO:\n\nExplain: \"95% of payments complete in under 100ms, 99% in under 250ms. We use p95/p99 instead of average because they show real user experience - a few slow payments don't skew the metric.\"\n\nError Rate SLO\n\nInterviewer asks: \"What error rate is acceptable?\"\n\nYour answer with SLO:\n\nExplain: \"We target less than 0.01% error rate. Currently at 0.008%, which is good, but we monitor closely because payment errors are critical.\"\n\nReal Interview Example: Capacity Estimation\n\nInterviewer: \"How many servers do you need for 1M txn/s?\"\n\nYour answer:\n\n\"Each transaction requires ~10ms processing = 100 transactions/second per server\"\n\"1M txn/s √∑ 100 = 10,000 servers needed\"\n\"With 2x headroom for spikes and redundancy: ~20,000 servers\"\n\"But we can optimize:\n   - Caching reduces DB load ‚Üí fewer DB servers\n   - Async processing ‚Üí can batch operations\n   - Database sharding ‚Üí distributes load\n   - Final estimate: ~5,000-10,000 servers\"\n\nInterview Practice: Add High Availability\n\nInterviewer: \"How do you ensure 99.99% availability?\"\n\nAdd redundancy to your design:\n\nExplain: \"We deploy across 3 data centers in active-active mode. If one fails, traffic automatically routes to others. Database has primary + replicas with automatic failover.\"\n\nCommon Follow-Up Questions\n\nBe prepared for:\n\n\"What if the database fails?\"\n   - Answer: \"Automatic failover to replica, data replication with < 1s lag\"\n\n\"How do you handle network partitions?\"\n   - Answer: \"CAP theorem - we choose consistency over availability for payments. If partition occurs, we reject transactions rather than risk inconsistency.\"\n\n\"What about data consistency across regions?\"\n   - Answer: \"Synchronous replication for critical data, eventual consistency for non-critical. Use distributed transactions for cross-region operations.\"\n\n\"How do you monitor SLOs?\"\n   - Answer: \"Real-time dashboards showing current vs target SLOs. Alerts when we're at risk of violating SLOs. Weekly reviews of SLO performance.\"\n\nExercise: Practice This Question\n\nDesign a payment system and be ready to explain:\n\nHow you achieve 99.99% availability\nHow you keep latency < 100ms\nHow you handle 1M txn/s\nYour SLO targets and how you measure them\n\nPractice tip: Time yourself (40-45 minutes) and explain out loud. Focus on SLOs - interviewers love this!\n\nKey Takeaways for Interviews\n\nAlways define SLOs - Shows production-ready thinking\nExplain trade-offs - Availability vs consistency, latency vs throughput\nShow capacity estimation - Back up your numbers\nMention monitoring - How you track SLOs\nDiscuss failure scenarios - What happens when things break\n\nNext Steps\n\nYou've learned how to handle performance and SLO questions. In the next module, we'll tackle modular architecture questions - another common interview topic!",
    "url": "https://sruja.ai/courses/production-architecture/module-1-performance/lesson-2",
    "type": "course",
    "category": "production-architecture",
    "summary": "Answer SLO and performance questions with confidence.",
    "weight": 2
  },
  {
    "objectID": "course-production-architecture/module-1-performance/lesson-3",
    "title": "Lesson 3: SLO Enforcement in Practice",
    "content": "Lesson 3: SLO Enforcement in Practice\n\nSLO‚ÄëDriven Operations\n\nUse SLOs to set thresholds for alerts and capacity changes.\n\nSruja: Model SLOs & Validate\n\nPractice\n\nDefine SLOs for your critical path; ensure  bounds meet .\nSet alert thresholds aligned to SLO windows.",
    "url": "https://sruja.ai/courses/production-architecture/module-1-performance/lesson-3",
    "type": "course",
    "category": "production-architecture",
    "summary": "Use SLOs to drive scaling, alerting, and design trade‚Äëoffs.",
    "weight": 3
  },
  {
    "objectID": "course-production-architecture/module-1-performance/module-overview",
    "title": "Module Overview: Scaling & Performance Interview Questions",
    "content": "Module Overview: Scaling & Performance Interview Questions\n\n\"Design a system that handles 10 million concurrent users.\"\n\nThis is one of the most common system design interview questions. In this module, you'll learn how to answer scaling and performance questions confidently.\n\nInterview Questions You'll Master\n\n\"Design a video streaming platform like YouTube/Netflix\"\n\"How would you design a system to handle 10M concurrent users?\"\n\"Design a system with < 200ms latency\"\n\"How do you ensure high availability (99.99%)?\"\n\nWhat Interviewers Look For\n\n‚úÖ Understanding of horizontal vs vertical scaling\n‚úÖ Ability to estimate capacity and scale\n‚úÖ Knowledge of performance metrics (latency, throughput)\n‚úÖ Trade-off analysis (cost vs performance)\n‚úÖ Clear communication of your design\n\nGoals\n\nAnswer scaling questions with confidence\nUse  blocks to model auto-scaling strategies\nDefine SLOs to show production-ready thinking\nExplain trade-offs clearly to interviewers\n\nInterview Framework\n\nWe'll follow this approach for each question:\nClarify Requirements - Ask about scale, latency, availability\nDesign High-Level - Start with core components\nModel with Sruja - Visualize your architecture\nDiscuss Scaling - Show how it handles load\nOptimize - Improve based on constraints\n\nEstimated Time\n\n60-75 minutes (includes practice)\n\nChecklist\n\n[ ] Understand how to approach scaling questions\n[ ] Model scaling strategies with Sruja\n[ ] Define SLOs to show production thinking\n[ ] Practice explaining trade-offs clearly",
    "url": "https://sruja.ai/courses/production-architecture/module-1-performance/module-overview",
    "type": "course",
    "category": "production-architecture",
    "summary": "Master the most common system design interview questions about scaling and performance.",
    "weight": 0
  },
  {
    "objectID": "course-production-architecture/module-2-modular/lesson-1",
    "title": "Lesson 1: Interview Question - Design an E-Commerce Platform (Microservices)",
    "content": "Lesson 1: Interview Question - Design an E-Commerce Platform (Microservices)\n\nThe Interview Question\n\n\"Design an e-commerce platform like Amazon that can handle millions of users and products. Use a microservices architecture.\"\n\nThis is one of the most common system design interview questions. It tests:\n\nSystem decomposition into microservices\nService boundaries and responsibilities\nInter-service communication\nData consistency across services\n\nStep 1: Clarify Requirements\n\nYou should ask:\n\n\"What are the core features? Shopping cart, checkout, recommendations?\"\n\"What's the scale? Users, products, orders per day?\"\n\"What about inventory? Real-time stock management?\"\n\"Payment processing? Do we integrate with payment gateways?\"\n\nInterviewer's typical answer:\n\n\"Core features: Product catalog, shopping cart, checkout, order management, user accounts\"\n\"Scale: 100M users, 1B products, 10M orders/day\"\n\"Real-time inventory tracking required\"\n\"Integrate with payment gateways like Stripe\"\n\nStep 2: Identify Microservices\n\nKey insight: Break down by business domain, not technical layers.\n\nYou should identify:\n\nUser Service - Authentication, profiles\nProduct Service - Catalog, search, recommendations\nCart Service - Shopping cart management\nOrder Service - Order processing, tracking\nPayment Service - Payment processing\nInventory Service - Stock management\nNotification Service - Emails, SMS\n\nStep 3: Model with Sruja (Separate Systems)\n\nModel each microservice as a separate system within the architecture. This clearly shows service boundaries.\n\nWhat Interviewers Look For\n\n‚úÖ Good Answer (What You Just Did)\n\nClear service boundaries - Each service is a separate system\nSingle responsibility - Each service has one clear purpose\nIdentified communication patterns - API calls, queues, events\nAddressed data ownership - Each service owns its database\nExplained trade-offs - Why microservices vs monolith\n\n‚ùå Bad Answer (Common Mistakes)\n\nServices too granular (one service per function)\nServices too coarse (monolith split incorrectly)\nNot showing service boundaries clearly\nIgnoring data consistency challenges\nNo API gateway or service mesh\n\nKey Points to Mention in Interview\n\nService Decomposition Strategy\n\nSay: \"I decompose by business domain, not technical layers. Each service owns its data and has clear boundaries. For example:\n\nUser Service owns user data and authentication\nProduct Service owns product catalog and search\nOrder Service owns order lifecycle\nEach service is a separate system in the architecture\"\n\nInter-Service Communication\n\nSay: \"Services communicate via:\n\nSynchronous: REST/gRPC for real-time operations (checkout, cart)\nAsynchronous: Message queues for eventual consistency (order processing, notifications)\nAPI Gateway: Single entry point, handles routing, auth, rate limiting\"\n\nData Consistency\n\nSay: \"Each service owns its database (database per service pattern). For cross-service operations:\n\nSaga pattern: For distributed transactions (order ‚Üí payment ‚Üí inventory)\nEventual consistency: Acceptable for non-critical paths (notifications)\nStrong consistency: Only within a service (cart operations)\"\n\nAPI Gateway Pattern\n\nSay: \"API Gateway provides:\n\nSingle entry point for all client requests\nRequest routing to appropriate microservices\nAuthentication/authorization - validate tokens once\nRate limiting and throttling\nLoad balancing across service instances\"\n\nInterview Practice: Add More Services\n\nInterviewer might ask: \"What about recommendations and analytics?\"\n\nAdd them to your design (extending the main architecture):\n\nCommon Follow-Up Questions\n\nBe prepared for:\n\n\"How do you handle failures?\"\n   - Answer: \"Circuit breakers prevent cascading failures. Retries with exponential backoff. Fallbacks (show cached data if service down). If payment service is down, queue the order for later processing.\"\n\n\"How do you ensure data consistency?\"\n   - Answer: \"Saga pattern for distributed transactions. Each step can be compensated if later steps fail. For example, if payment fails after inventory is reserved, we release the inventory (compensating transaction).\"\n\n\"How do you handle service versioning?\"\n   - Answer: \"API versioning in URLs (/v1/, /v2/). Deploy new versions alongside old ones. Gradually migrate traffic. Deprecate old versions after migration.\"\n\n\"How do you monitor microservices?\"\n   - Answer: \"Distributed tracing (Jaeger, Zipkin) to track requests across services. Centralized logging (ELK stack). Metrics (Prometheus) per service. Health checks for each service.\"\n\n\"How do you handle service discovery?\"\n   - Answer: \"Service registry (Consul, Eureka) or DNS-based discovery. API Gateway can handle routing. Service mesh (Istio) for advanced features like load balancing, retries.\"\n\nExercise: Practice This Question\n\nDesign an e-commerce platform and be ready to explain:\n\nHow you decomposed into services (why these services?)\nHow services communicate (sync vs async)\nHow you handle data consistency\nHow you handle failures\nYour scaling strategy for each service\n\nPractice tip: Time yourself (45-50 minutes). Draw the architecture, then model it with Sruja. Explain your decisions out loud as if in an interview.\n\nKey Takeaways for Interviews\n\nDecompose by business domain - Not technical layers\nEach service is a separate system - Clear boundaries in Sruja\nEach service owns its data - Database per service\nUse API Gateway - Single entry point\nMix sync and async - REST for real-time, queues for async\nAddress failures - Circuit breakers, retries, fallbacks\nShow with separate systems - Clear service boundaries in architecture\n\nNext Steps\n\nYou've learned how to design microservices architectures. In the next module, we'll cover governance and policies - important for senior/staff level interviews!",
    "url": "https://sruja.ai/courses/production-architecture/module-2-modular/lesson-1",
    "type": "course",
    "category": "production-architecture",
    "summary": "Master microservices questions by designing Amazon-style platforms.",
    "weight": 1
  },
  {
    "objectID": "course-production-architecture/module-2-modular/module-overview",
    "title": "Module Overview: Microservices & Distributed Systems Interview Questions",
    "content": "Module Overview: Microservices & Distributed Systems Interview Questions\n\n\"Design an e-commerce platform using microservices.\"\n\nThis is a very common interview question that tests your understanding of:\nMicroservices architecture\nService decomposition\nInter-service communication\nDistributed system challenges\n\nInterview Questions You'll Master\n\n\"Design an e-commerce platform (Amazon-style)\"\n\"Design a ride-sharing service like Uber\"\n\"Design a social media platform\"\n\"How do you split a monolith into microservices?\"\n\nWhat Interviewers Look For\n\n‚úÖ Understanding of microservices vs monolith trade-offs\n‚úÖ Ability to decompose a system into services\n‚úÖ Knowledge of service communication patterns\n‚úÖ Understanding of distributed system challenges\n‚úÖ Clear communication of design decisions\n\nGoals\n\nAnswer microservices questions confidently\nModel service boundaries using separate systems in Sruja\nExplain service decomposition strategy\nDiscuss trade-offs and challenges\n\nInterview Framework\n\nWe'll follow this approach:\nClarify Requirements - Scale, features, constraints\nIdentify Services - How to decompose the system\nModel with Sruja - Use separate systems to show service boundaries\nDiscuss Communication - APIs, events, data flow\nAddress Challenges - Consistency, failures, monitoring\n\nEstimated Time\n\n60-75 minutes (includes practice)\n\nChecklist\n\n[ ] Understand microservices decomposition\n[ ] Model services as separate systems in Sruja\n[ ] Explain service communication patterns\n[ ] Discuss distributed system challenges",
    "url": "https://sruja.ai/courses/production-architecture/module-2-modular/module-overview",
    "type": "course",
    "category": "production-architecture",
    "summary": "Master microservices and distributed system design interview questions.",
    "weight": 0
  },
  {
    "objectID": "course-production-architecture/module-3-governance/lesson-1",
    "title": "Lesson 1: Interview Question - Design a HIPAA-Compliant Healthcare System",
    "content": "Lesson 1: Interview Question - Design a HIPAA-Compliant Healthcare System\n\nThe Interview Question\n\n\"Design a healthcare platform that stores patient data and must comply with HIPAA regulations. How do you ensure compliance across all services?\"\n\nThis is a senior/staff level interview question that tests:\n\nUnderstanding of compliance requirements\nAbility to enforce standards at scale\nSecurity and privacy considerations\nGovernance and policy enforcement\n\nStep 1: Clarify Requirements\n\nYou should ask:\n\n\"What are the core features? Patient records, appointments, prescriptions?\"\n\"What's the scale? How many patients, healthcare providers?\"\n\"What compliance requirements? HIPAA, SOC 2, others?\"\n\"What about data retention? How long must we keep records?\"\n\nInterviewer's answer:\n\n\"Core: Patient records, appointments, prescriptions, billing\"\n\"Scale: 10M patients, 100K healthcare providers\"\n\"Must comply with HIPAA (health data privacy)\"\n\"Retain records for 10 years (legal requirement)\"\n\nStep 2: Understand HIPAA Requirements\n\nKey HIPAA requirements (you should mention these):\n\nEncryption: Data at rest and in transit\nAccess Control: Role-based access, audit logs\nAudit Logging: Track all access to patient data\nData Minimization: Only collect necessary data\nBreach Notification: Report breaches within 72 hours\n\nStep 3: Design with Policies\n\nThis is where Sruja's  feature is perfect! Show how you enforce compliance:\n\nWhat Interviewers Look For\n\n‚úÖ Good Answer (What You Just Did)\n\nUnderstood compliance requirements - Mentioned specific HIPAA rules\nDefined policies explicitly - Showed governance thinking\nApplied policies to architecture - Tags, descriptions show compliance\nAddressed security - Encryption, access control, audit logging\nExplained enforcement - How policies are enforced\n\n‚ùå Bad Answer (Common Mistakes)\n\nNot understanding compliance requirements\nNo mention of policies or governance\nIgnoring security (encryption, access control)\nNo audit logging strategy\nCan't explain how to enforce standards\n\nKey Points to Mention in Interview\n\nPolicy-Driven Architecture\n\nSay: \"I define policies at the architecture level to enforce standards. For example:\n\nHIPAACompliance policy requires encryption and audit logging\nAll services that handle patient data must comply\nPolicies are checked in CI/CD - non-compliant services can't deploy\"\n\nEncryption Strategy\n\nSay: \"We encrypt data at multiple levels:\n\nIn transit: TLS 1.3 for all communications\nAt rest: AES-256 encryption for databases\nApplication level: Encrypt sensitive fields before storing\"\n\nAccess Control\n\nSay: \"We use:\n\nOAuth2/OIDC: For authentication and authorization\nRole-based access control (RBAC): Doctors can access their patients, admins have broader access\nPrinciple of least privilege: Users only get minimum required access\"\n\nAudit Logging\n\nSay: \"We log all access to patient data:\n\nWhat: Which patient record was accessed\nWho: Which user/role accessed it\nWhen: Timestamp\nWhy: Purpose of access (treatment, billing, etc.)\nImmutable logs: Can't be modified or deleted\"\n\nEnforcement Strategy\n\nSay: \"We enforce policies through:\n\nCI/CD checks: Validate architecture before deployment\nService mesh policies: Enforce TLS, rate limiting\nDatabase policies: Encryption at rest, access controls\nMonitoring: Alert on policy violations\"\n\nInterview Practice: Add More Compliance\n\nInterviewer might ask: \"What about data retention and deletion?\"\n\nAdd data retention policy:\n\nCommon Follow-Up Questions\n\nBe prepared for:\n\n\"How do you ensure all services comply?\"\n   - Answer: \"Policy validation in CI/CD. Architecture review process. Service mesh enforces some policies automatically. Regular audits.\"\n\n\"What if a service violates a policy?\"\n   - Answer: \"CI/CD blocks deployment. Alert security team. Architecture review required. Service owner must fix before deploying.\"\n\n\"How do you handle breaches?\"\n   - Answer: \"Automated breach detection via monitoring. Incident response plan. HIPAA requires notification within 72 hours. Audit logs help identify scope.\"\n\n\"How do you balance compliance with developer productivity?\"\n   - Answer: \"Automate compliance checks. Provide templates and libraries. Make compliance easy, not burdensome. Clear documentation and examples.\"\n\nExercise: Practice This Question\n\nDesign a HIPAA-compliant healthcare system and be ready to explain:\n\nHow you enforce HIPAA requirements\nYour encryption strategy\nYour access control approach\nYour audit logging implementation\nHow you ensure compliance across services\n\nPractice tip: This is a senior-level question. Focus on:\n\nGovernance and policies\nSecurity and compliance\nEnforcement strategies\nTrade-offs and practical considerations\n\nKey Takeaways for Senior Interviews\n\nUnderstand compliance requirements - Know HIPAA, SOC 2, GDPR basics\nDefine policies explicitly - Show governance thinking\nEnforce at multiple levels - CI/CD, service mesh, monitoring\nBalance compliance and productivity - Make it easy for developers\nThink about scale - How to enforce across 100+ services\n\nNext Steps\n\nYou've learned how to handle compliance and governance questions. This completes the Production Architecture course! You're now ready to tackle:\n\n‚úÖ Scaling and performance questions\n‚úÖ Microservices architecture questions\n‚úÖ Senior-level governance questions\n\nKeep practicing with real interview questions! üéØ",
    "url": "https://sruja.ai/courses/production-architecture/module-3-governance/lesson-1",
    "type": "course",
    "category": "production-architecture",
    "summary": "Answer compliance and governance questions for senior-level interviews.",
    "weight": 1
  },
  {
    "objectID": "course-production-architecture/module-3-governance/lesson-2",
    "title": "Lesson 2: Policies, Constraints, Conventions",
    "content": "Lesson 2: Policies, Constraints, Conventions\n\nWhy Governance?\n\nGovernance ensures systems remain secure, maintainable, and consistent as they evolve.\n\nSruja: Codify Guardrails\n\nPractice\n\nAdd a policy describing your security posture.\nCapture 2‚Äì3 constraints and conventions used by your team.",
    "url": "https://sruja.ai/courses/production-architecture/module-3-governance/lesson-2",
    "type": "course",
    "category": "production-architecture",
    "summary": "Codify guardrails and agreements; enforce consistency.",
    "weight": 2
  },
  {
    "objectID": "course-production-architecture/module-3-governance/module-overview",
    "title": "Module Overview: Senior/Staff Level Interview Questions",
    "content": "Module Overview: Senior/Staff Level Interview Questions\n\n\"How do you ensure architectural standards across a large organization?\"\n\nThis module covers questions typically asked in senior/staff engineer interviews. These test your ability to:\nLead architecture decisions\nEnforce standards and best practices\nHandle compliance and regulatory requirements\nDesign for large-scale organizations\n\nInterview Questions You'll Master\n\n\"How do you enforce architectural standards?\"\n\"Design a system that must comply with HIPAA/SOC 2\"\n\"How do you ensure security across microservices?\"\n\"How do you handle compliance in a distributed system?\"\n\nWhat Interviewers Look For\n\n‚úÖ Understanding of governance and policies\n‚úÖ Ability to enforce standards at scale\n‚úÖ Knowledge of compliance requirements\n‚úÖ Leadership and architectural thinking\n‚úÖ Trade-offs between flexibility and standards\n\nGoals\n\nAnswer governance questions confidently\nDefine policies with Sruja\nExplain compliance requirements\nDiscuss enforcement strategies\n\nInterview Framework\n\nWe'll follow this approach:\nUnderstand Requirements - Compliance, standards, scale\nDefine Policies - Security, compliance, best practices\nModel with Sruja - Show policies in architecture\nDiscuss Enforcement - How to ensure compliance\nAddress Trade-offs - Flexibility vs standards\n\nEstimated Time\n\n45-60 minutes\n\nChecklist\n\n[ ] Understand policy syntax and usage\n[ ] Define security and compliance policies\n[ ] Model policies with Sruja\n[ ] Explain enforcement strategies",
    "url": "https://sruja.ai/courses/production-architecture/module-3-governance/module-overview",
    "type": "course",
    "category": "production-architecture",
    "summary": "Answer governance, compliance, and architecture leadership questions.",
    "weight": 0
  },
  {
    "objectID": "course-system-design-101/course-overview",
    "title": "System Design 101: Fundamentals",
    "content": "System Design 101: Fundamentals\n\n[!NOTE]\nWho is this for? Developers moving into senior roles, students preparing for interviews, or anyone curious about how massive systems like Netflix or Uber work.\n\nWhy Learn System Design?\n\nWriting code is only half the battle. As you grow in your career, the challenges shift from \"how do I write this function?\" to \"how do I ensure this system handles 10 million users?\".\n\nSystem design is the skill of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It's about making the right trade-offs.\n\nWhat You Will Learn\n\nBy the end of this course, you will be able to:\n\nSpeak the Language: Confidently use terms like latency, throughput, consistency, and availability.\nUse the Toolbox: Know when to use a relational database vs. NoSQL, or when to introduce a cache or message queue.\nDraw the Blueprint: Visualise your ideas using industry-standard diagrams (C4 model).\nScale for Success: Understand how to take a system from 1 user to 1,000,000 users.\n\nCourse Structure\n\nThis course is broken down into digestible modules:\n\nModule 1: Core Concepts\nThe foundational pillars of distributed systems. We cover Scalability (Vertical vs Horizontal), Reliability, and Maintainability.\n\nModule 2: The Building Blocks\nA deep dive into the components that make up a system:\nLoad Balancers: The traffic cops of the internet.\nDatabases: SQL vs NoSQL, replication, and sharding.\nCaches: speeding up access with Redis/Memcached.\nMessage Queues: Decoupling services with Kafka/RabbitMQ.\n\nModule 3: Architectural Patterns\nHow to organize code and services:\nMonolith vs Microservices\nEvent-Driven Architecture\nAPI Gateway Pattern\n\nModule 4: The Interview Guide\nPractical tips for acing the system design interview, including a framework for tackling open-ended problems.\n\nPrerequisites\n\nBasic understanding of how the web works (HTTP, DNS, Client-Server).\nFamiliarity with at least one programming language.\nNo prior distributed systems knowledge required.\n\nLet's Begin\n\nStart your journey with Module 1: Fundamentals.",
    "url": "https://sruja.ai/courses/system-design-101/course-overview",
    "type": "course",
    "category": "system-design-101",
    "summary": "Master the art of designing scalable, reliable, and maintainable systems. From load balancers to caching strategies, learn the building blocks of modern architecture.",
    "weight": 1
  },
  {
    "objectID": "course-system-design-101/module-1-fundamentals/lesson-1",
    "title": "Lesson 1: The Mindset",
    "content": "Lesson 1: The Mindset\n\nThe Shift\n\nWhen you write code, you are building a single room. You care about the furniture (variables), the flow (logic), and the usability (UI).\n\nSystem Design is city planning.\n\nYou stop caring about the furniture in every room. instead, you care about:\n\nTraffic flow: Can the roads handle rush hour? (Throughput)\nUtilities: Is there enough water and electricity? (Capacity)\nDisaster recovery: What happens if the power plant explodes? (Reliability)\nExpansion: Can we add a new suburb next year? (Scalability)\n\n[!IMPORTANT]\nThe golden rule: In system design, there are no right answers, only trade-offs.\n\nFunctional vs Non-Functional\n\nEvery system has two sets of requirements. In an interview (and real life), 90% of your initial grade comes from clarifying these before you draw a single box.\n\nFunctional Requirements (The \"What\")\n\nThese are the features. If the system doesn't do this, it's useless.\n\nUser can post a tweet.\nUser can follow others.\nUser sees a news feed.\n\nNon-Functional Requirements (The \"How\")\n\nThese are the constraints. If the system doesn't meet these, it will crash/fail/be too slow.\n\nScalability: Must handle 100M daily active users.\nLatency: Feed must load in < 200ms.\nConsistency: A tweet must appear on followers' feeds within 5 seconds.\n\nThe \"It Depends\" Game\n\nJunior engineers search for the \"best\" database. Senior engineers ask \"what are we optimizing for?\"\n\n| You Optimize For      | You Might Sacrifice | Example                                                              |\n| :-------------------- | :------------------ | :------------------------------------------------------------------- |\n| Consistency       | Availability    | Banking (Balances must be correct, even if system goes down briefly) |\n| Availability      | Consistency     | Social Media (Better to show old likes than an error page)         |\n| Write Speed       | Read Speed      | Logging (Write fast, read rarely)                                    |\n| Development Speed | Performance     | Startups (Ship Python/Ruby MVP fast, rewrite later)                  |\n\nSruja Integration\n\nIn Sruja, we treat requirements as code. This keeps your constraints right next to your architecture.\n\nWhy the Specification Block Matters\n\nThe  block isn't just syntax‚Äîit provides real benefits:\n\nEarly Validation: If you typo an element type (e.g.,  instead of ), Sruja catches it immediately\nBetter Tooling: IDEs can provide autocomplete and validation based on declared element types\nSelf-Documentation: Anyone reading your model knows exactly what element types are available\nOrganization: Separates \"what types exist\" from \"what instances we create\"\n\nExample: Requirements-Driven Architecture\n\nKnowledge Check\n\n<details>\n<summary><strong>Q: My boss says \"We need to handle infinite users\". How do you respond?</strong></summary>\n\nBad Answer: \"Okay, I'll use Kubernetes and sharding.\"\n\nSenior Answer: \"Infinite is expensive. Do we expect 1k users or 100M users? The design for 1k costs $50/mo. The design for 100M costs $50k/mo. Let's define a realistic target for the next 12 months.\"\n\n</details>\n\n<details>\n<summary><strong>Q: Why not just use the fastest database for everything?</strong></summary>\n\nBecause \"fastest\" depends on the workload. A database fast at reading (Cassandra) might be complex to manage. A database fast at relationships (Neo4j) might scale poorly for heavy writes. Trade-offs.\n\n</details>\n\nNext Steps\n\nNow that we have the mindset, let's learn the language.\nüëâ Lesson 2: The Vocabulary of Scale",
    "url": "https://sruja.ai/courses/system-design-101/module-1-fundamentals/lesson-1",
    "type": "course",
    "category": "system-design-101",
    "summary": "Stop coding. Start designing. Why system design is different from application development.",
    "difficulty": "beginner",
    "weight": 1
  },
  {
    "objectID": "course-system-design-101/module-1-fundamentals/lesson-2",
    "title": "Lesson 2: The Vocabulary of Scale",
    "content": "Lesson 2: The Vocabulary of Scale\n\nTo design big systems, you need to speak the language.\n\nScaling: Up vs Out\n\nWhen your website crashes because too many people are using it, you have two choices.\n\nVertical Scaling (Scaling Up)\n\n\"Get a bigger machine.\"\nYou upgrade from a 4GB RAM server to a 64GB RAM server.\n\nPros: Easy. No code changes.\nCons: Expensive. Finite limit (you can't buy a 100TB RAM server... easily). Single point of failure.\n\nHorizontal Scaling (Scaling Out)\n\n\"Get more machines.\"\nYou buy 10 cheap servers and split the traffic between them.\n\nPros: Infinite scale (google has millions of servers). Resilient (if one dies, others take over).\nCons: Complex. You need load balancers and data consistency strategies.\n\nSpeed: Latency vs Throughput\n\nIn interviews, never just say \"it needs to be fast\". Be specific.\n\nLatency: The time it takes for one person to get a result.\n  - Metaphor: The time it takes to drive from A to B.\n  - Unit: Milliseconds (ms).\nThroughput: The number of people the system can serve at the same time.\n  - Metaphor: The width of the highway (how many cars per hour).\n  - Unit: Requests per Second (RPS).\n\n[!TIP]\nUse the right word: A system can have low latency (fast response) but low throughput (crashes if 5 people use it). A highway can have high throughput (10 lanes) but high latency (traffic jam).\n\nSruja in Action\n\nSruja allows you to define horizontal scaling requirements explicitly using the  block.\n\nKnowledge Check\n\n<details>\n<summary><strong>Q: Why don't we just vertically scale forever?</strong></summary>\n\nBecause physics. There is a limit to how fast a single CPU can be. Also, if that one super-computer catches fire, your entire business is dead.\n\n</details>\n\nNext Steps\n\nWe have the mindset, and we have the words. Now let's draw.\nüëâ Lesson 3: The C4 Model (Visualizing Architecture)",
    "url": "https://sruja.ai/courses/system-design-101/module-1-fundamentals/lesson-2",
    "type": "course",
    "category": "system-design-101",
    "summary": "Vertical vs. Horizontal Scaling, Latency vs. Throughput. The words you need to know.",
    "difficulty": "beginner",
    "weight": 2
  },
  {
    "objectID": "course-system-design-101/module-1-fundamentals/lesson-3",
    "title": "Lesson 3: Availability & Reliability",
    "content": "Lesson 3: Availability & Reliability\n\nReliability vs. Availability\n\nReliability: The probability that a system will function correctly without failure for a specified period. It's about correctness.\nAvailability: The percentage of time a system is operational and accessible. It's about uptime.\n\nA system can be available but not reliable (e.g., it returns 500 errors but is \"up\").\n\nMeasuring Availability\n\nAvailability is often measured in \"nines\":\n\n| Availability         | Downtime per Year |\n| :------------------- | :---------------- |\n| 99% (Two nines)      | 3.65 days         |\n| 99.9% (Three nines)  | 8.76 hours        |\n| 99.99% (Four nines)  | 52.6 minutes      |\n| 99.999% (Five nines) | 5.26 minutes      |\n\nAchieving High Availability\n\nRedundancy\n\nThe key to availability is eliminating Single Points of Failure (SPOF). This is done via redundancy.\n\nActive-Passive: One server handles traffic; the other is on standby.\nActive-Active: Both servers handle traffic. If one fails, the other takes over the full load.\n\nFailover\n\nThe process of switching to a redundant system upon failure. This can be manual or automatic.\n\nüõ†Ô∏è Sruja Perspective: Modeling Redundancy\n\nYou can explicitly model redundant components in Sruja to visualize your high-availability strategy.",
    "url": "https://sruja.ai/courses/system-design-101/module-1-fundamentals/lesson-3",
    "type": "course",
    "category": "system-design-101",
    "summary": "Redundancy, Failover, and SLAs.",
    "weight": 3
  },
  {
    "objectID": "course-system-design-101/module-1-fundamentals/lesson-4",
    "title": "Lesson 4: CAP Theorem & Consistency",
    "content": "Lesson 4: CAP Theorem & Consistency\n\nThe CAP Theorem\n\nProposed by Eric Brewer, the CAP theorem states that a distributed data store can only provide two of the following three guarantees:\n\nConsistency (C): Every read receives the most recent write or an error. All nodes see the same data at the same time.\nAvailability (A): Every request receives a (non-error) response, without the guarantee that it contains the most recent write.\nPartition Tolerance (P): The system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes.\n\nThe Reality: P is Mandatory\n\nIn a distributed system, network partitions (P) are inevitable. Therefore, you must choose between Consistency (CP) and Availability (AP) when a partition occurs.\n\nCP (Consistency + Partition Tolerance): Wait for data to sync. If a node is unreachable, return an error. (e.g., Banking systems).\nAP (Availability + Partition Tolerance): Return the most recent version of data available, even if it might be stale. (e.g., Social media feeds).\n\nConsistency Models\n\nStrong Consistency: Once a write is confirmed, all subsequent reads see that value.\nEventual Consistency: If no new updates are made, eventually all accesses will return the last updated value. (Common in AP systems).\n\nüõ†Ô∏è Sruja Perspective: Documenting Guarantees\n\nWhen defining data stores in Sruja, it is helpful to document their consistency guarantees, especially for distributed databases.",
    "url": "https://sruja.ai/courses/system-design-101/module-1-fundamentals/lesson-4",
    "type": "course",
    "category": "system-design-101",
    "summary": "Consistency, Availability, and Partition Tolerance.",
    "weight": 4
  },
  {
    "objectID": "course-system-design-101/module-1-fundamentals/lesson-5",
    "title": "Lesson 5: User Scenarios",
    "content": "Lesson 5: User Scenarios\n\nUnderstanding User Journeys\n\nA User Scenario describes the series of steps a user takes to achieve a specific goal within your system. While static architecture diagrams show structure, user scenarios show behavior.\n\nWhy Model Scenarios?\n\nValidation: Ensures that all components required for a feature actually exist and are connected.\nClarity: Helps stakeholders understand how the system works from a user's perspective.\nTesting: Serves as a blueprint for integration and end-to-end tests.\n\nExample Scenario: Buying a Ticket\n\nUser searches for events.\nUser selects a ticket.\nUser enters payment details.\nSystem processes payment.\nSystem sends confirmation email.\n\nüõ†Ô∏è Sruja Perspective: Modeling Scenarios\n\nSruja provides a dedicated  keyword to model these interactions explicitly. This allows you to visualize the flow of data across your defined architecture.\n\nBy defining scenarios, you can automatically generate sequence diagrams or flowcharts that map directly to your code.",
    "url": "https://sruja.ai/courses/system-design-101/module-1-fundamentals/lesson-5",
    "type": "course",
    "category": "system-design-101",
    "summary": "Modeling user flows and interactions.",
    "weight": 5
  },
  {
    "objectID": "course-system-design-101/module-1-fundamentals/module-overview",
    "title": "Module 1: Fundamentals",
    "content": "Module 1: Fundamentals\n\n[!TIP]\nThe Interview Secret: Most candidates fail not because they don't know the tech, but because they dive into solutions too early. This module fixes that.\n\nWhat's Inside?\n\nThis isn't just theory. It's the playbook for how senior engineers approach broad, ambiguous problems.\n\nWhat is System Design?: Defining the game we're playing.\nThe Art of Requirements: How to extract the real problem from a vague prompt.\nThe C4 Model: A standardized way to draw your ideas so others actually understand them.\nTrade-offs: Why \"it depends\" is the only correct answer (and how to explain what it depends on).\nSruja Basics: Your first architecture-as-code model.\n\nLearning Goals\n\nBy the end of this module, you will be able to:\n\n‚úÖ Distinguish between Functional and Non-Functional Requirements.\n‚úÖ Calculate rough capacity estimates (back-of-the-envelope math).\n‚úÖ Draw a high-level System Context diagram.\n‚úÖ Explain the CAP theorem in plain English.\n\nReady?\n\nLet's start your journey with Lesson 1: What is System Design?",
    "url": "https://sruja.ai/courses/system-design-101/module-1-fundamentals/module-overview",
    "type": "course",
    "category": "system-design-101",
    "summary": "Lay the groundwork. Learn the language of system design, how to dissect problems, and master the art of trade-offs.",
    "weight": 0
  },
  {
    "objectID": "course-system-design-101/module-2-building-blocks/lesson-1",
    "title": "Lesson 1: Load Balancers",
    "content": "Lesson 1: Load Balancers\n\nWhat is a Load Balancer?\n\nA load balancer sits between clients and servers, distributing incoming network traffic across a group of backend servers. This ensures that no single server bears too much load.\n\nTypes of Load Balancing\n\nLayer 4 (Transport Layer)\n\nDecisions based on IP address and TCP/UDP ports.\nFaster, less CPU intensive.\nDoes not inspect the content of the request.\n\nLayer 7 (Application Layer)\n\nDecisions based on the content of the message (URL, HTTP headers, cookies).\nCan route traffic to different services based on URL (e.g.,  to image servers).\nMore CPU intensive but smarter.\n\nAlgorithms\n\nRound Robin: Requests are distributed sequentially.\nLeast Connections: Sends request to the server with the fewest active connections.\nIP Hash: The client's IP address is used to determine which server receives the request (useful for session stickiness).\n\nüõ†Ô∏è Sruja Perspective: Modeling Load Balancers\n\nIn Sruja, a load balancer is typically modeled as a  or  that sits in front of your application servers.",
    "url": "https://sruja.ai/courses/system-design-101/module-2-building-blocks/lesson-1",
    "type": "course",
    "category": "system-design-101",
    "summary": "L4 vs L7 Load Balancing, Algorithms.",
    "weight": 1
  },
  {
    "objectID": "course-system-design-101/module-2-building-blocks/lesson-2",
    "title": "Lesson 2: Databases",
    "content": "Lesson 2: Databases\n\nSQL vs. NoSQL\n\nSQL (Relational Databases)\n\nStructure: Structured data with predefined schemas (Tables, Rows, Columns).\nQuery Language: SQL (Structured Query Language).\nACID Compliance: Strong guarantees for Atomicity, Consistency, Isolation, Durability.\nExamples: MySQL, PostgreSQL, Oracle.\nBest for: Complex queries, financial transactions.\n\nNoSQL (Non-Relational Databases)\n\nStructure: Flexible schemas (Key-Value, Document, Graph, Column-Family).\nScalability: Designed for horizontal scaling.\nExamples: MongoDB (Document), Redis (Key-Value), Cassandra (Column).\nBest for: Rapidly changing data, massive scale, unstructured data.\n\nScaling Databases\n\nReplication\n\nCopying data to multiple servers.\n\nMaster-Slave: Writes go to Master, Reads go to Slaves. Good for read-heavy systems.\nMaster-Master: Writes can go to any node. Complex conflict resolution needed.\n\nSharding\n\nPartitioning data across multiple servers (e.g., Users A-M on Server 1, N-Z on Server 2).\n\nPros: Handles massive data volumes.\nCons: Complex joins, rebalancing data is hard.\n\nüõ†Ô∏è Sruja Perspective: Modeling Databases\n\nSruja allows you to define the type of database and its role in the system.",
    "url": "https://sruja.ai/courses/system-design-101/module-2-building-blocks/lesson-2",
    "type": "course",
    "category": "system-design-101",
    "summary": "SQL vs NoSQL, Replication, and Sharding.",
    "weight": 2
  },
  {
    "objectID": "course-system-design-101/module-2-building-blocks/lesson-3",
    "title": "Lesson 3: Caching",
    "content": "Lesson 3: Caching\n\nWhy Cache?\n\nCaching is the process of storing copies of data in a temporary storage location (cache) so that future requests for that data can be served faster.\n\nReduce Latency: Memory is faster than disk.\nReduce Load: Fewer queries to the database.\n\nCaching Strategies\n\nCache-Aside (Lazy Loading)\n\nApp checks cache.\nIf miss, App reads from DB.\nApp writes to cache.\n\nPros: Only requested data is cached.\nCons: Initial request is slow (cache miss).\n\nWrite-Through\n\nApp writes to cache and DB simultaneously.\n\nPros: Data in cache is always fresh.\nCons: Slower writes.\n\nWrite-Back (Write-Behind)\n\nApp writes to cache only.\nCache writes to DB asynchronously.\n\nPros: Fast writes.\nCons: Data loss risk if cache fails before syncing.\n\nEviction Policies\n\nWhen the cache is full, what do you remove?\n\nLRU (Least Recently Used): Remove the item that hasn't been used for the longest time.\nLFU (Least Frequently Used): Remove the item used least often.\nFIFO (First In, First Out): Remove the oldest item.\n\nüõ†Ô∏è Sruja Perspective: Modeling Caches\n\nIn Sruja, caches are often modeled as separate containers or components.",
    "url": "https://sruja.ai/courses/system-design-101/module-2-building-blocks/lesson-3",
    "type": "course",
    "category": "system-design-101",
    "summary": "Caching strategies and eviction policies.",
    "weight": 3
  },
  {
    "objectID": "course-system-design-101/module-3-advanced-modeling/lesson-1",
    "title": "Lesson 1: Microservices Architecture",
    "content": "Lesson 1: Microservices Architecture\n\nMonolith vs. Microservices\n\nMonolithic Architecture\n\nA single application where all functionality is packaged together.\n\nPros: Simple to develop, deploy, and test initially.\nCons: Hard to scale specific parts, tight coupling, single point of failure.\n\nMicroservices Architecture\n\nA collection of small, independent services that communicate over a network.\n\nPros: Independent scaling, technology diversity, fault isolation.\nCons: Distributed system complexity, network latency, data consistency challenges.\n\nDefining Service Boundaries\n\nThe hardest part of microservices is deciding where to draw the lines. Common strategies include:\n\nBusiness Capability: Group by what the business does (e.g., Billing, Shipping).\nSubdomain: Group by Domain-Driven Design (DDD) subdomains.\n\nüõ†Ô∏è Sruja Perspective: Modeling Microservices\n\nIn Sruja, microservices are typically modeled as separate  items within a , or even as separate  items if they are large enough.\n\nBasic Example\n\nKey Benefits of Multiple Views\n\nDifferent Audiences: Developers see technical details, product managers see user flows\nReduced Complexity: Each view focuses on what matters for that perspective\nBetter Communication: Stakeholders get diagrams tailored to their needs\nDocumentation: Multiple views serve as different types of documentation",
    "url": "https://sruja.ai/courses/system-design-101/module-3-advanced-modeling/lesson-1",
    "type": "course",
    "category": "system-design-101",
    "summary": "Monolith vs Microservices, Service Boundaries.",
    "weight": 1
  },
  {
    "objectID": "course-system-design-101/module-3-advanced-modeling/lesson-2",
    "title": "Lesson 2: Event-Driven Architecture",
    "content": "Lesson 2: Event-Driven Architecture\n\nSynchronous vs. Asynchronous\n\nSynchronous (Request/Response): Client waits for the server to respond (e.g., HTTP REST).\nAsynchronous (Event-Driven): Client sends a message and continues work. The receiver processes it later.\n\nCore Concepts\n\nMessage Queues (Point-to-Point)\n\nA message is sent to a queue and processed by exactly one consumer.\n\nUse Case: Background jobs (e.g., image resizing).\n\nPub/Sub (Publish/Subscribe)\n\nA message (event) is published to a topic. Multiple subscribers can receive a copy.\n\nUse Case: notifying multiple services (e.g., \"UserSignedUp\" -> EmailService, AnalyticsService).\n\nüõ†Ô∏è Sruja Perspective: Modeling Events\n\nSruja supports  as a first-class citizen to model asynchronous communication.\n\nKey Concepts\n\nScenarios model behavioral flows (user journeys, use cases)\nFlows model data pipelines (ETL, streaming, batch processing)\nViews let you focus on different aspects (events vs data vs user experience)",
    "url": "https://sruja.ai/courses/system-design-101/module-3-advanced-modeling/lesson-2",
    "type": "course",
    "category": "system-design-101",
    "summary": "Pub/Sub, Message Queues, Event Sourcing.",
    "weight": 2
  },
  {
    "objectID": "course-system-design-101/module-3-advanced-modeling/lesson-3",
    "title": "Lesson 3: Advanced Scenarios",
    "content": "Lesson 3: Advanced Scenarios\n\nIn Sruja, use  (and its alias ) to model runtime interactions: user journeys and technical sequences.\n\nWhen to Use Scenarios\n\nModeling user interactions\nModeling technical sequences across elements\n\nUser Flows (Stories)\n\nWhen modeling a user flow, you focus on the value delivered to the user. Sruja provides the  keyword (an alias for ) to make these definitions semantic and clear.\n\nNotice how we can add properties like  and  to steps using the  syntax. This adds richness to your model without cluttering the diagram.\n\nTechnical Sequences\n\nWhen modeling technical sequences, you dive deeper into the architecture, showing how  and  interact to fulfill a request. You can stick with the  keyword here.\n\nüõ†Ô∏è Syntax Flexibility\n\nSruja offers flexible syntax to suit your needs:\n\nSimple Syntax\n\nGreat for quick sketches or simple flows.\n\nFormal Syntax\n\nBetter for documentation and referencing. Includes an ID and optional description.\n\nVisualizing Scenarios\n\nStudio/Viewer can highlight scenario paths over your static architecture so readers can follow behavior step‚Äëby‚Äëstep.\n\nData-Oriented Scenarios\n\nUse  for data‚Äëoriented flows too‚Äîkeep steps focused on interactions and outcomes between elements.",
    "url": "https://sruja.ai/courses/system-design-101/module-3-advanced-modeling/lesson-3",
    "type": "course",
    "category": "system-design-101",
    "summary": "Modeling user journeys and technical sequences with Scenarios.",
    "weight": 3
  },
  {
    "objectID": "course-system-design-101/module-3-advanced-modeling/lesson-4",
    "title": "Lesson 4: Architectural Perspectives",
    "content": "Lesson 4: Architectural Perspectives\n\nAs your system grows, a single diagram becomes too cluttered. You need different \"maps\" for different audiences:\n\nExecutives: Need a high-level overview (Context).\nArchitects: Need to see service boundaries (Containers).\nDevelopers: Need to see internal details (Components).\n\nSruja models naturally support multiple perspectives without special keywords. Use the built‚Äëin elements, and tooling presents the right level of detail.\n\nOne Model, Multiple Perspectives\n\nSruja's  block lets you create custom perspectives from a single model. This is powerful for communicating with different audiences.\n\nKey Benefits\n\nContext View (Executive): Shows systems and actors - perfect for stakeholders\nContainer View (Architect): Shows deployable units and their relationships\nComponent View (Developer): Shows internal structure and implementation details\nData Flow View: Focuses on data dependencies and storage\nComplete View: Shows everything for comprehensive documentation\n\nWhen to Use Views\n\nDifferent Audiences: Tailor diagrams to what each audience needs to see\nReduce Complexity: Hide irrelevant details for specific discussions\nDocumentation: Create multiple diagrams from one source of truth\nPresentations: Switch views during presentations to zoom in/out",
    "url": "https://sruja.ai/courses/system-design-101/module-3-advanced-modeling/lesson-4",
    "type": "course",
    "category": "system-design-101",
    "summary": "Understanding context, containers, and components without special DSL keywords.",
    "weight": 4
  },
  {
    "objectID": "course-system-design-101/module-3-advanced-modeling/lesson-5",
    "title": "Lesson 5: Views & Styling",
    "content": "Lesson 5: Views & Styling\n\nWhy Views?\n\nViews let you spotlight specific paths (API, data, auth) without redrawing the whole system.\n\nSruja: Views and Styles\n\nViews let you create focused diagrams from a single model. Styles make them visually clear.\n\nBasic Views Example\n\nViews with Custom Styling\n\nPractice\n\nCreate an \"Data Flow\" view focusing on  reads/writes.\nUse view  to highlight critical edges.",
    "url": "https://sruja.ai/courses/system-design-101/module-3-advanced-modeling/lesson-5",
    "type": "course",
    "category": "system-design-101",
    "summary": "Focus diagrams with views; improve legibility with styling.",
    "weight": 5
  },
  {
    "objectID": "course-system-design-101/module-3-advanced-modeling/lesson-6",
    "title": "Lesson 6: Advanced DSL Features",
    "content": "Lesson 6: Advanced DSL Features\n\nThe new Sruja DSL format (//) provides powerful features for creating production-ready architecture models. This lesson covers the advanced capabilities that make your models more maintainable, understandable, and useful.\n\nThe Specification Block: Your Foundation\n\nThe  block defines what element types are available in your model. This isn't just documentation‚Äîit provides real benefits:\n\nBenefits\n\nEarly Validation: Catches typos in element types before runtime\nBetter Tooling: Enables autocomplete, validation, and refactoring\nDocumentation: Makes available element types explicit\nOrganization: Separates structure definition from instantiation\n\nBest Practice\n\nDeclare all element types you'll use upfront. This makes your model self-documenting and enables better tooling support.\n\nMultiple Views: One Model, Many Perspectives\n\nThe  block lets you create custom perspectives from a single model. This is essential for communicating with different audiences.\n\nReal-World Example: E-Commerce Platform\n\nView Strategies\n\nBy Audience: Executive, Architect, Developer, Product Manager\nBy Concern: Data flow, Security, Performance, User experience\nBy Layer: Context, Container, Component\nBy Feature: Checkout flow, User management, Analytics\n\nScenarios: Modeling User Journeys\n\nScenarios model behavioral flows‚Äîwhat happens when users interact with your system. They're perfect for documenting user stories and use cases.\n\nExample: Checkout Flow\n\nWhen to Use Scenarios\n\nUser Stories: Document how users interact with your system\nUse Cases: Model specific business processes\nError Handling: Document failure paths and recovery\nIntegration Testing: Define test scenarios\n\nFlows: Modeling Data Pipelines\n\nFlows model data-oriented processes‚Äîhow data moves through your system. Use them for ETL, streaming, and batch processing.\n\nExample: Analytics Pipeline\n\nScenario vs Flow\n\nScenario: Behavioral flows (user actions, business processes)\nFlow: Data flows (ETL, streaming, batch processing)\n\nIntegrating Requirements, ADRs, and Policies\n\nThe new DSL format makes it easy to integrate requirements, ADRs, and policies directly into your architecture model.\n\nComplete Example\n\nBest Practices\n\nStart with Specification: Declare all element types upfront\nUse Multiple Views: Create views for different audiences and concerns\nDocument with Scenarios: Model user journeys and business processes\nModel Data Flows: Use flows for ETL and data pipelines\nLink Requirements: Connect requirements to architecture decisions\nDocument Decisions: Use ADRs to explain why, not just what\nDefine SLOs: Model service level objectives for production systems\n\nNext Steps\n\nNow that you understand the advanced features, you can create production-ready models that:\n\nCommunicate effectively with different audiences\nDocument user journeys and data flows\nLink requirements to architecture decisions\nEnable automated validation and governance\n\nüëâ Module 4: Production Readiness - Learn how to make your architecture production-ready.",
    "url": "https://sruja.ai/courses/system-design-101/module-3-advanced-modeling/lesson-6",
    "type": "course",
    "category": "system-design-101",
    "summary": "Master views, scenarios, flows, and the specification block to create production-ready models.",
    "weight": 6
  },
  {
    "objectID": "course-system-design-101/module-3-advanced-modeling/lesson-7",
    "title": "Lesson 7: Views Best Practices",
    "content": "Lesson 7: Views Best Practices\n\nViews are one of the most powerful features in Sruja DSL. They let you create multiple perspectives from a single model, making your architecture documentation accessible to different audiences. This lesson covers best practices for creating effective views.\n\nThe Power of Views\n\nA single architecture model can serve:\n\nExecutives: High-level business context\nProduct Managers: Feature and user journey focus\nArchitects: Technical design and patterns\nDevelopers: Implementation details\nOperations: Deployment and monitoring concerns\nSecurity: Compliance and threat modeling\n\nView Creation Strategy\n\nStart with Your Audience\n\nBefore creating a view, ask:\n\nWho will use this view? (Executive, Developer, Ops)\nWhat questions do they need answered? (Cost, Performance, Security)\nWhat level of detail do they need? (Context, Container, Component)\n\nUse Include/Exclude Strategically\n\nCreate Concern-Specific Views\n\nFocus on specific concerns: performance, security, data flow, deployment.\n\nView Naming Conventions\n\nUse clear, descriptive names that indicate the view's purpose:\n\nGood Names\n\n- Clear audience\n- Clear concern\n- Clear purpose\n- Specific use case\n\nAvoid\n\n,  - Not descriptive\n- Temporary views should be removed\n- Test views shouldn't be in production models\n\nView Organization Patterns\n\nPattern 1: By Audience\n\nCreate views for each stakeholder group.\n\nPattern 2: By Concern\n\nCreate views for different technical concerns.\n\nPattern 3: By Layer\n\nCreate views for different C4 model layers.\n\nPattern 4: By Feature\n\nCreate views for specific features or domains.\n\nBest Practices\n\nAlways Include an Index View\n\nUse Descriptive Titles\n\nAdd Descriptions\n\nKeep Views Focused\n\nEach view should answer a specific set of questions. If a view tries to answer too many questions, split it into multiple views.\n\nDocument View Purpose\n\nUse comments or descriptions to explain why a view exists and when to use it.\n\nCommon View Patterns\n\nExecutive Dashboard View\n\nTechnical Architecture View\n\nUser Journey View\n\nDeployment View\n\nView Maintenance\n\nWhen to Create New Views\n\nNew stakeholder group needs different perspective\nNew concern emerges (e.g., compliance)\nFeature-specific view needed for documentation\n\nWhen to Remove Views\n\nView is no longer used\nView duplicates another view\nView is outdated and not maintained\n\nWhen to Update Views\n\nArchitecture changes affect view scope\nNew components need to be included/excluded\nView purpose changes\n\nAdvanced: View Composition\n\nYou can create views that build on other views by carefully selecting elements:\n\nReal-World Example: E-Commerce Platform\n\nSummary\n\nViews are a powerful tool for making architecture documentation accessible to different audiences. Follow these best practices:\n\nStart with your audience - Know who will use the view\nUse include/exclude strategically - Focus on what matters\nCreate concern-specific views - Performance, security, data flow\nUse clear naming - Descriptive names that indicate purpose\nDocument view purpose - Explain why the view exists\nKeep views focused - Each view should answer specific questions\nMaintain views - Update or remove views as architecture evolves\n\nüëâ Module 4: Production Readiness - Learn how to make your architecture production-ready.",
    "url": "https://sruja.ai/courses/system-design-101/module-3-advanced-modeling/lesson-7",
    "type": "course",
    "category": "system-design-101",
    "summary": "Master the art of creating effective views for different audiences and purposes.",
    "weight": 7
  },
  {
    "objectID": "course-system-design-101/module-4-production-readiness/lesson-1",
    "title": "Lesson 1: Documenting Decisions (ADRs)",
    "content": "Lesson 1: Documenting Decisions (ADRs)\n\nWhat is an ADR?\n\nAn Architecture Decision Record (ADR) is a document that captures an important architectural decision made along with its context and consequences.\n\nWhy use ADRs?\n\nContext: Explains why a decision was made (e.g., \"Why did we choose Postgres over Mongo?\").\nOnboarding: Helps new team members understand the history of the system.\nAlignment: Ensures everyone agrees on the path forward.\n\nStructure of an ADR\n\nTitle: Short summary.\nStatus: Proposed, Accepted, Deprecated.\nContext: The problem we are solving.\nDecision: What we are doing.\nConsequences: The pros and cons of this decision.\n\nüõ†Ô∏è Sruja Perspective: Native ADR Support\n\nSruja treats ADRs as first-class citizens. You can define them directly in your architecture file.\n\nThis ensures that your documentation lives right next to the code it describes, making it harder to ignore or lose.",
    "url": "https://sruja.ai/courses/system-design-101/module-4-production-readiness/lesson-1",
    "type": "course",
    "category": "system-design-101",
    "summary": "Why document? What is an ADR?",
    "weight": 1
  },
  {
    "objectID": "course-system-design-101/module-4-production-readiness/lesson-2",
    "title": "Lesson 2: Deployment Architecture",
    "content": "Lesson 2: Deployment Architecture\n\nReal-World Scenario: Startup to Scale\n\nContext: A fintech startup begins with a single server, grows to 10M users, and needs to plan deployment architecture.\n\nChallenge: How do you model and evolve deployment architecture as you scale?\n\nLogical vs. Physical Architecture\n\nLogical Architecture: The software components and how they interact (Containers, Components).\nPhysical Architecture: Where those components actually run (Servers, VMs, Kubernetes Pods).\n\nWhy it matters: Understanding this separation helps you:\n\nPlan migrations (e.g., moving from EC2 to EKS)\nModel multi-cloud strategies\nDocument disaster recovery plans\nCommunicate with DevOps teams\n\nDeployment Strategies: Real-World Trade-offs\n\nOn-Premises\n\nRunning on your own hardware in a data center.\n\nReal-world use cases:\n\nFinancial institutions (regulatory compliance)\nHealthcare systems (HIPAA data residency)\nGovernment systems (sovereignty requirements)\n\n Pros: Total control, security, data sovereignty.\n Cons: High maintenance, capital expense, slower scaling.\n Cost example: $500K+ initial investment, 3-5 year hardware refresh cycles\n\nCloud (AWS, GCP, Azure)\n\nRenting infrastructure from a provider.\n\nReal-world use cases:\n\nSaaS platforms (99% of modern startups)\nE-commerce (seasonal scaling)\nMedia streaming (global distribution)\n\n Pros: Pay-as-you-go, infinite scale, managed services.\n Cons: Vendor lock-in, variable costs, compliance complexity.\n Cost example: $5K/month for small SaaS, $50K+ for mid-size, $500K+ for enterprise\n\nContainers & Orchestration\n\nPackaging code with dependencies (Docker) and managing them at scale (Kubernetes).\n\nReal-world adoption:\n\n2024: 70% of enterprises use Kubernetes\nCommon pattern: Docker ‚Üí Kubernetes ‚Üí Service Mesh (Istio/Linkerd)\n\nProduction considerations:\n\nResource limits (CPU/memory)\nHealth checks and liveness probes\nRolling updates and rollback strategies\nMulti-region deployments\n\nüõ†Ô∏è Sruja Perspective: Deployment Nodes\n\nSruja allows you to map your logical containers to physical deployment nodes, making it clear where code runs in production.\n\nExample: Multi-Region E-Commerce Platform\n\nDevOps Integration: CI/CD Pipeline\n\nModel your deployment pipeline alongside architecture:\n\nReal-World Patterns\n\nPattern 1: Blue/Green Deployment\n\nUse case: Zero-downtime deployments for critical services\n\nDevOps workflow:\n\nDeploy new version to Green\nRun smoke tests\nSwitch 10% traffic to Green\nMonitor for 15 minutes\nGradually increase to 100%\nKeep Blue ready for rollback\n\nPattern 2: Canary Deployment\n\nUse case: Gradual rollout with automatic rollback\n\nPattern 3: Multi-Cloud Strategy\n\nUse case: Avoiding vendor lock-in, disaster recovery\n\nService Level Objectives (SLOs)\n\nDefine reliability targets directly in your architecture model:\n\nBenefits of Modeling SLOs\n\nClear Targets: Everyone knows what \"good\" looks like\nMonitoring Guidance: SLOs define what metrics to track\nStakeholder Communication: Clear reliability commitments\nLiving Documentation: SLOs live with architecture, not separate docs\n\nMonitoring & Observability\n\nModel your observability stack:\n\nKey Takeaways\n\nSeparate logical from physical: Model what your system does (logical) separately from where it runs (physical)\nDocument deployment strategies: Use deployment nodes to show Blue/Green, Canary, or multi-region setups\nLink to CI/CD: Show how code flows from commit to production\nModel observability: Include monitoring, logging, and tracing in your architecture\nPlan for scale: Document scaling strategies (min/max replicas, regions)\n\nExercise: Model Your Deployment\n\nChoose a real system you work on (or a hypothetical one)\nModel the logical architecture (containers, datastores)\nMap to physical deployment (cloud regions, clusters)\nAdd deployment strategy (Blue/Green, Canary, or Rolling)\nInclude observability components\n\nTime: 20 minutes\n\nFurther Reading\n\nTutorial: Deployment Modeling\nDocs: Deployment Concepts\nCourse: E-Commerce Platform - Module 5: Ops",
    "url": "https://sruja.ai/courses/system-design-101/module-4-production-readiness/lesson-2",
    "type": "course",
    "category": "system-design-101",
    "summary": "Cloud, On-prem, Containers, and real-world deployment strategies.",
    "weight": 2
  },
  {
    "objectID": "course-system-design-101/module-4-production-readiness/lesson-3",
    "title": "Lesson 3: Governance as Code",
    "content": "Lesson 3: Governance as Code\n\nAs your organization scales, manually reviewing every architectural change becomes impossible. You need automated guardrails to ensure consistency and security.\n\nWhat is Governance as Code?\n\nGovernance as Code treats architectural policies (e.g., \"All databases must be encrypted\", \"No circular dependencies\") as executable code that can be validated automatically in your CI/CD pipeline.\n\nBuilt-in Validation Rules\n\nSruja validates common architectural concerns automatically:\n\nAutomated Validation\n\nThe real power comes when you run the Sruja CLI. It can check your architecture against these policies and fail the build if violations are found.\n\nThis ensures that your architecture isn't just a diagram‚Äîit's a specification that is continuously verified.",
    "url": "https://sruja.ai/courses/system-design-101/module-4-production-readiness/lesson-3",
    "type": "course",
    "category": "system-design-101",
    "summary": "Automating architectural compliance with Policies and Rules.",
    "weight": 3
  },
  {
    "objectID": "course-system-design-101/module-4-production-readiness/lesson-4",
    "title": "Lesson 4: SLOs & Scale Integration",
    "content": "Lesson 4: SLOs & Scale Integration\n\nWhy SLOs?\n\nSLOs set measurable targets (availability, latency, error rate, throughput). They guide capacity and design.\n\nSruja: SLO + Scale\n\nKey Integration Points\n\nScale aligns with SLOs: Min/max replicas support throughput targets\nSLOs guide monitoring: Define what metrics to track and alert on\nCurrent vs Target: Track progress toward SLO targets\nMultiple SLO types: Availability, latency, error rate, throughput\n\nPractice\n\nSet  and  targets for the API.\nAdjust  bounds to keep  above target.",
    "url": "https://sruja.ai/courses/system-design-101/module-4-production-readiness/lesson-4",
    "type": "course",
    "category": "system-design-101",
    "summary": "Define SLOs and align scale to meet targets.",
    "weight": 4
  },
  {
    "objectID": "course-system-design-101/module-4-production-readiness/lesson-5",
    "title": "Lesson 5: Change & Snapshots",
    "content": "Lesson 5: Change & Snapshots\n\nWhy Track Changes?\n\nKeeping a history of changes improves communication, auditability, and onboarding.\n\nSruja: Change and Snapshot\n\nPractice\n\nAdd a  describing an API refactor.\nCreate a  with the current version tag.",
    "url": "https://sruja.ai/courses/system-design-101/module-4-production-readiness/lesson-5",
    "type": "course",
    "category": "system-design-101",
    "summary": "Track evolution and version states within the architecture.",
    "weight": 5
  },
  {
    "objectID": "course-system-design-201/course-overview",
    "title": "System Design 201: Advanced Systems",
    "content": "System Design 201: Advanced Systems\n\nOverview\nFocuses on scaling strategies and production realities beyond fundamentals\nCovers throughput, real-time processing, data-intensive architectures, and consistency models\n\nLearning Goals\nDesign services for high throughput and predictable performance\nApply real-time processing patterns for streaming data\nArchitect data-intensive systems with storage and compute separation\nChoose appropriate consistency and isolation models (and know the trade-offs)\n\nPrerequisites\nCompleted or familiar with concepts from System Design 101\nComfortable with distributed systems basics, caching, queues, and storage types\n\nCourse Structure\nModule 1: High Throughput\nModule 2: Real-Time\nModule 3: Data-Intensive\nModule 4: Consistency\n\nWhere to Start\nBegin with Module 1 to build scaling foundations, then proceed in order",
    "url": "https://sruja.ai/courses/system-design-201/course-overview",
    "type": "course",
    "category": "system-design-201",
    "summary": "Deep dive into high throughput, real-time, data-intensive patterns, and consistency trade-offs.",
    "weight": 1
  },
  {
    "objectID": "course-system-design-201/module-1-high-throughput/lesson-1",
    "title": "Lesson 1: Design a URL Shortener",
    "content": "Lesson 1: Design a URL Shortener\n\nGoal: Design a service like TinyURL that takes a long URL and converts it into a short alias (e.g., ).\n\nRequirements\n\nFunctional\n\nCustom aliases (optional).\n\nNon-Functional\n\nHighly Available: If the service is down, URL redirection stops working.\nLow Latency: Redirection must happen in milliseconds.\nRead-Heavy: 100:1 read-to-write ratio.\n\nCore Design\n\nDatabase Choice\n\nSince we need fast lookups and the data model is simple (Key-Value), a NoSQL Key-Value Store (like DynamoDB or Redis) is ideal.\n\nKey: \nValue: \n\nHashing Algorithm\n\nHow do we generate the alias?\n\nMD5/SHA256: Too long.\nBase62 Encoding: Converts a unique ID (from a counter or database ID) into a string of characters [a-z, A-Z, 0-9].\n\nüõ†Ô∏è Sruja Perspective: Modeling the Flow\n\nWe can use Sruja to model the system components and the user scenario for redirection.",
    "url": "https://sruja.ai/courses/system-design-201/module-1-high-throughput/lesson-1",
    "type": "course",
    "category": "system-design-201",
    "summary": "TinyURL: Hashing, Key-Value Stores, Redirection.",
    "weight": 1
  },
  {
    "objectID": "course-system-design-201/module-1-high-throughput/lesson-2",
    "title": "Lesson 2: Design a Rate Limiter",
    "content": "Lesson 2: Design a Rate Limiter\n\nGoal: Design a system to limit the number of requests a client can send to an API within a time window (e.g., 10 requests per second).\n\nWhy Rate Limit?\n\nPrevent Abuse: Stop DDoS attacks or malicious bots.\nFairness: Ensure one user doesn't hog all resources.\nCost Control: Prevent auto-scaling bills from exploding.\n\nAlgorithms\n\nToken Bucket\n\nA \"bucket\" holds tokens.\nTokens are added at a fixed rate (e.g., 10 tokens/sec).\nEach request consumes a token.\nIf the bucket is empty, the request is dropped (429 Too Many Requests).\n\nLeaky Bucket\n\nRequests enter a queue (bucket) and are processed at a constant rate.\nIf the queue is full, new requests are dropped.\n\nArchitecture Location\n\nWhere does the rate limiter live?\n\nClient-side: Unreliable (can be forged).\nServer-side: Inside the application code.\nMiddleware: In a centralized API Gateway (Best practice).\n\nüõ†Ô∏è Sruja Perspective: Middleware Modeling\n\nIn Sruja, we can model the Rate Limiter as a component within the API Gateway, backed by a fast datastore like Redis.",
    "url": "https://sruja.ai/courses/system-design-201/module-1-high-throughput/lesson-2",
    "type": "course",
    "category": "system-design-201",
    "summary": "Token Bucket, Distributed Caching, Middleware.",
    "weight": 2
  },
  {
    "objectID": "course-system-design-201/module-1-high-throughput/lesson-3",
    "title": "Lesson 3: Views for Critical Throughput Paths",
    "content": "Lesson 3: Views for Critical Throughput Paths\n\nWhy Views for Throughput?\n\nFocus on hot paths to reason about scaling, backpressure, and caching. High-throughput systems have critical paths that need isolation for analysis.\n\nSruja: High‚ÄëThroughput View\n\nPractice\n\nCreate a view highlighting backpressure points.\nAnnotate scale bounds for hot components.\nUse scenarios to model high-volume flows.",
    "url": "https://sruja.ai/courses/system-design-201/module-1-high-throughput/lesson-3",
    "type": "course",
    "category": "system-design-201",
    "summary": "Use views to isolate and analyze high‚Äëvolume flows.",
    "weight": 3
  },
  {
    "objectID": "course-system-design-201/module-1-high-throughput/module-overview",
    "title": "Module Overview: High Throughput Systems",
    "content": "Module Overview: High Throughput Systems\n\n\"Design a system that handles 1 million requests per second.\"\n\nThis module covers advanced scaling patterns needed for high-throughput systems - a common interview topic at top tech companies.\n\nLearning Goals\n\nIdentify throughput bottlenecks in systems\nApply scaling patterns (queues, sharding, caching)\nModel trade-offs and document decisions with ADRs\nDesign systems that handle massive scale\n\nInterview Preparation\n\n‚úÖ Answer \"design for high throughput\" questions\n‚úÖ Explain queuing and async processing\n‚úÖ Discuss database sharding strategies\n‚úÖ Model scaling patterns with Sruja\n\nReal-World Application\n\nDesign systems that handle millions of requests\nApply patterns to actual high-scale systems\nUnderstand trade-offs in scaling decisions\n\nEstimated Time\n\n60-75 minutes (includes practice)\n\nChecklist\n\n[ ] Can identify throughput bottlenecks\n[ ] Understand queuing and async patterns\n[ ] Can design sharding strategies\n[ ] Can explain trade-offs clearly",
    "url": "https://sruja.ai/courses/system-design-201/module-1-high-throughput/module-overview",
    "type": "course",
    "category": "system-design-201",
    "summary": "Master high-throughput interview questions: queues, sharding, and scaling patterns.",
    "weight": 0
  },
  {
    "objectID": "course-system-design-201/module-2-real-time/lesson-1",
    "title": "Lesson 1: Design a Chat Application",
    "content": "Lesson 1: Design a Chat Application\n\nGoal: Design a real-time chat service like WhatsApp or Slack that supports 1-on-1 and Group messaging.\n\nRequirements\n\nFunctional\n\nSend/Receive messages in real-time.\nSee user status (Online/Offline).\nMessage history (persistent storage).\n\nNon-Functional\n\nLow Latency: Messages must appear instantly.\nConsistency: Messages must be delivered in order.\nAvailability: High uptime.\n\nCore Design\n\nCommunication Protocol\n\nHTTP is request/response (pull). For chat, we need push.\n\nWebSockets: Keeps a persistent connection open between client and server.\n\nMessage Flow\n\nUser A sends message to Chat Server.\nChat Server finds which server User B is connected to (using a Session Store like Redis).\nChat Server pushes message to User B.\n\nStorage\n\nChat History: Write-heavy. Cassandra or HBase (Wide-column stores) are good for time-series data.\nUser Status: Key-Value store (Redis) with TTL.\n\nüõ†Ô∏è Sruja Perspective: Modeling Real-Time Flows\n\nWe can use Sruja to model the WebSocket connections and the async message processing.",
    "url": "https://sruja.ai/courses/system-design-201/module-2-real-time/lesson-1",
    "type": "course",
    "category": "system-design-201",
    "summary": "WhatsApp: WebSockets, Pub/Sub, Message Persistence.",
    "weight": 1
  },
  {
    "objectID": "course-system-design-201/module-3-data-intensive/lesson-1",
    "title": "Lesson 1: Design a Video Streaming Service",
    "content": "Lesson 1: Design a Video Streaming Service\n\nGoal: Design a video sharing platform like YouTube or Netflix where users can upload and watch videos.\n\nRequirements\n\nFunctional\n\nUpload videos.\nWatch videos (streaming).\nSupport multiple resolutions (360p, 720p, 1080p).\n\nNon-Functional\n\nReliability: No buffering.\nAvailability: Videos are always accessible.\nScalability: Handle millions of concurrent viewers.\n\nCore Design\n\nStorage (Blob Store)\n\nVideos are large binary files (BLOBs). Databases are bad for this.\n\nObject Storage: AWS S3, Google Cloud Storage.\nMetadata: Store title, description, and S3 URL in a SQL/NoSQL DB.\n\nProcessing (Transcoding)\n\nRaw uploads are huge. We need to convert them into different formats and resolutions.\n\nTranscoding Service: Breaks video into chunks and encodes them (H.264, VP9).\n\nDelivery (CDN)\n\nServing video from a single server is too slow for global users.\n\nContent Delivery Network (CDN): Caches video chunks in edge servers close to the user.\n\nAdaptive Bitrate Streaming (HLS/DASH)\n\nThe player automatically switches quality based on the user's internet speed.\n\nüõ†Ô∏è Sruja Perspective: Modeling Infrastructure\n\nWe can use Sruja's  nodes to visualize the global distribution of content.",
    "url": "https://sruja.ai/courses/system-design-201/module-3-data-intensive/lesson-1",
    "type": "course",
    "category": "system-design-201",
    "summary": "YouTube: Transcoding, CDNs, Adaptive Streaming.",
    "weight": 1
  },
  {
    "objectID": "course-system-design-201/module-4-consistency/lesson-1",
    "title": "Lesson 1: Design a Distributed Counter",
    "content": "Lesson 1: Design a Distributed Counter\n\nGoal: Design a system to count events (e.g., YouTube views, Facebook likes) at a massive scale (e.g., 1 million writes/sec).\n\nThe Problem with a Single Database\n\nA standard SQL database (like PostgreSQL) can handle ~2k-5k writes/sec. If we try to update a single row () for every view, the database will lock the row and become a bottleneck.\n\nSolutions\n\nSharding (Write Splitting)\n\nInstead of one counter, have $N$ counters for the same video.\n\nRandomly pick a counter from $1$ to $N$ and increment it.\nTotal Views = Sum of all $N$ counters.\n\nWrite-Behind (Batching)\n\nDon't write to the DB immediately.\n\nStore counts in memory (Redis) or a log (Kafka).\nA background worker aggregates them and updates the DB every few seconds.\nTrade-off: If the server crashes before flushing, you lose a few seconds of data (Eventual Consistency).\n\nüõ†Ô∏è Sruja Perspective: Modeling Write Flows\n\nWe can use Sruja to model the \"Write-Behind\" architecture.",
    "url": "https://sruja.ai/courses/system-design-201/module-4-consistency/lesson-1",
    "type": "course",
    "category": "system-design-201",
    "summary": "Sharding, Write-Behind, Eventual Consistency.",
    "weight": 1
  },
  {
    "objectID": "course-system-design-201/module-4-consistency/lesson-2",
    "title": "Lesson 2: Consistency via Constraints & Conventions",
    "content": "Lesson 2: Consistency via Constraints & Conventions\n\nWhy Constraints?\n\nThey document trade‚Äëoffs and prevent accidental coupling across services.\n\nSruja: Guardrails for Consistency\n\nPractice\n\nAdd constraints that support your chosen consistency model.\nCapture conventions for retries, idempotency, and naming.",
    "url": "https://sruja.ai/courses/system-design-201/module-4-consistency/lesson-2",
    "type": "course",
    "category": "system-design-201",
    "summary": "Use constraints and conventions to manage consistency trade‚Äëoffs.",
    "weight": 2
  },
  {
    "objectID": "tutorial-advanced/agentic-ai-modeling",
    "title": "Agentic AI Modeling",
    "content": "Agentic AI Modeling\n\nThis tutorial shows how to model agent-based systems with orchestrators, planners, executors, tools, and memory.\n\nCore Structure\n\nAdd Governance\n\nIntegrate RAG\n\nNext Steps\n\nExplore  and \nAdd scenarios to capture common workflows\nUse views to present developer vs. executive perspectives",
    "url": "https://sruja.ai/tutorials/advanced/agentic-ai-modeling",
    "type": "tutorial",
    "category": "advanced",
    "summary": "Model agent orchestration, tools, and memory using Sruja DSL.",
    "difficulty": "advanced",
    "tags": ["ai", "agents", "rag", "modeling"],
    "weight": 40
  },
  {
    "objectID": "tutorial-advanced/cicd-integration",
    "title": "CI/CD Integration",
    "content": "CI/CD Integration\n\nIntegrate Sruja into your CI/CD pipeline to automatically validate architecture, enforce standards, and generate documentation on every commit.\n\nWhy CI/CD Integration?\n\nFor DevOps teams:\nCatch architecture violations before they reach production\nAutomate documentation generation\nEnforce architectural standards across teams\nReduce manual review overhead\n\nFor software architects:\nEnsure architectural decisions are documented\nPrevent architectural drift\nScale governance across multiple teams\n\nFor product teams:\nKeep architecture docs up-to-date automatically\nTrack architecture changes over time\nEnsure compliance with requirements\n\nReal-World Scenario\n\nChallenge: A team of 50 engineers across 10 microservices. Architecture documentation is outdated, and violations happen frequently.\n\nSolution: Integrate Sruja validation into CI/CD to:\nValidate architecture on every PR\nGenerate updated documentation automatically\nBlock merges if constraints are violated\nTrack architecture changes over time\n\nGitHub Actions Integration\n\nBasic Setup\n\nAdvanced: Enforce Constraints\n\nMulti-Architecture Validation\n\nFor monorepos with multiple architecture files:\n\nGitLab CI Integration\n\nJenkins Integration\n\nCircleCI Integration\n\nPre-commit Hooks\n\nValidate before every commit locally:\n\nOr use pre-commit framework:\n\nAutomated Documentation Updates\n\nGenerate and commit documentation automatically:\n\nArchitecture Change Tracking\n\nTrack architecture changes over time:\n\nReal-World Example: Microservices Platform\n\nComplete CI/CD setup for a microservices platform:\n\nKey Takeaways\n\nAutomate everything: Don't rely on manual validation\nFail fast: Block merges if constraints are violated\nGenerate docs automatically: Keep documentation up-to-date\nTrack changes: Monitor architecture evolution over time\nScale governance: Use CI/CD to enforce standards across teams\n\nExercise: Set Up CI/CD Integration\n\nTasks:\nChoose a CI/CD platform (GitHub Actions, GitLab CI, etc.)\nCreate a workflow that validates architecture on every PR\nAdd documentation generation\nTest the workflow with a sample architecture file\n\nTime: 20 minutes\n\nFurther Reading\n\nTutorial: Validation & Linting\nDocs: Adoption Playbook\nCourse: Advanced Architects - Policy as Code",
    "url": "https://sruja.ai/tutorials/advanced/cicd-integration",
    "type": "tutorial",
    "category": "advanced",
    "summary": "Integrate Sruja validation and documentation into your CI/CD pipelines for automated architecture governance.",
    "difficulty": "intermediate",
    "tags": ["devops", "cicd", "automation", "governance"],
    "weight": 50
  },
  {
    "objectID": "tutorial-advanced/deployment-modeling",
    "title": "Deployment Modeling",
    "content": "Deployment Modeling\n\nModel production environments and map containers onto infrastructure nodes.",
    "url": "https://sruja.ai/tutorials/advanced/deployment-modeling",
    "type": "tutorial",
    "category": "advanced",
    "summary": "Map logical elements to deployment nodes for environment diagrams.",
    "tags": ["deployment", "infrastructure"],
    "weight": 70
  },
  {
    "objectID": "tutorial-advanced/extending-cli-with-cobra",
    "title": "Extending the CLI with Cobra",
    "content": "Extending the CLI with Cobra\n\nSruja‚Äôs CLI uses Cobra. This tutorial shows how to add a new subcommand.\n\nDefine a Command\n\nWire It In\n\nGenerate Completions",
    "url": "https://sruja.ai/tutorials/advanced/extending-cli-with-cobra",
    "type": "tutorial",
    "category": "advanced",
    "summary": "Add new subcommands using Cobra and reuse existing run functions.",
    "tags": ["cli", "go", "cobra"],
    "weight": 80
  },
  {
    "objectID": "tutorial-advanced/releasing-with-goreleaser",
    "title": "Releasing with GoReleaser",
    "content": "Releasing with GoReleaser\n\nSruja uses GoReleaser to build and publish releases.\n\nConfiguration\n\n sets builds and archive names:\n\nSnapshot Build\n\nThis produces , , etc., which the installer consumes.",
    "url": "https://sruja.ai/tutorials/advanced/releasing-with-goreleaser",
    "type": "tutorial",
    "category": "advanced",
    "summary": "Build cross-platform binaries and publish archives that match the installer.",
    "tags": ["release", "goreleaser", "ci"],
    "weight": 90
  },
  {
    "objectID": "tutorial-basic/cli-basics",
    "title": "CLI Basics",
    "content": "CLI Basics\n\nThis tutorial teaches the essential Sruja CLI commands for day‚Äëto‚Äëday work.\n\nInstall and Verify\n\nIf  is not found, add Go‚Äôs bin to your :\n\nCreate a Model\n\nLint and Compile\n\nFormat\n\nTree View\n\nExport to D2",
    "url": "https://sruja.ai/tutorials/basic/cli-basics",
    "type": "tutorial",
    "category": "basic",
    "summary": "Install, verify, and use the Sruja CLI to work with architecture models.",
    "tags": ["cli", "getting-started"],
    "weight": 10
  },
  {
    "objectID": "tutorial-basic/demo-script",
    "title": "Demo Script",
    "content": "Demo Script: Quick 10-Minute Walkthrough\n\nThis tutorial provides a quick 10-minute walkthrough to demonstrate Sruja's core capabilities: modeling, validation, and export.\n\n1) Model (2 minutes)\n\nCreate a simple e-commerce architecture:\n\n2) Validate (2 minutes)\n\nFormat and validate your model:\n\n3) Add Targets (3 minutes)\n\nAdd SLOs and scaling configuration:\n\n4) Export (3 minutes)\n\nExport to various formats:\n\nOutcome: Living docs and diagrams generated from the model.\n\nNote: Sruja is free and open source (Apache 2.0 licensed). Need help with adoption? Professional consulting services are available. Contact the team through GitHub Discussions to learn more.",
    "url": "https://sruja.ai/tutorials/basic/demo-script",
    "type": "tutorial",
    "category": "basic",
    "summary": "10‚Äëminute walkthrough: model, validate, and export.",
    "tags": ["demo", "getting-started", "walkthrough"],
    "weight": 5
  },
  {
    "objectID": "tutorial-basic/design-mode",
    "title": "Design Mode Workflow",
    "content": "Design Mode Workflow\n\nDesign Mode helps you build architecture assets step by step, starting with high‚Äëlevel context and progressively adding detail. It also lets you focus on a specific system or container and share audience‚Äëspecific views.\n\nWorkflow Steps\n\nStep 1: Context ‚Äî define  and \n\nStart with the high-level context:\n\nStep 2: Containers ‚Äî add , ,  to a chosen system\n\nAdd containers and datastores:\n\nStep 3: Components ‚Äî add  inside a chosen container\n\nDrill down into components:\n\nStep 4: Stitch ‚Äî add relations and optional scenarios; share focused views\n\nAdd relations and scenarios to complete the model.\n\nLayers and Focus\n\nLevels: L1 Context, L2 Containers, L3 Components, All\nFocus:\n  - L2 focus by \n  - L3 focus by \n\nWhen focused, non‚Äërelevant nodes/edges are dimmed so you can work deeper without distractions.\n\nShare Deep Links\n\nViewer opens focused views via URL params:\n\n‚Üí Context\n‚Üí Containers of system \n‚Üí Components in container  of system \nDSL payload is passed with  or .\n\nStudio Experience\n\nDiagram‚Äëfirst: Studio opens with the diagram; a Design Mode overlay guides steps\nContextual palette: add containers at L2 (focused system), components at L3 (focused container)\nAutosave on close: resume drafts; share per‚Äëlayer links from the toolbar\n\nViewer Experience\n\nUse level buttons and focus to tailor the view\nDimming clarifies what's relevant at each depth\nShare via copied URL (includes , , and DSL)\n\nSee Also\n\nLayering\nValidation\nScenario",
    "url": "https://sruja.ai/tutorials/basic/design-mode",
    "type": "tutorial",
    "category": "basic",
    "summary": "A guided, layered workflow to design architectures step‚Äëby‚Äëstep and share focused views.",
    "tags": ["workflow", "design", "studio"],
    "weight": 6
  },
  {
    "objectID": "tutorial-basic/dsl-basics",
    "title": "DSL Basics",
    "content": "DSL Basics\n\nSruja is an architecture DSL. This tutorial introduces its core elements.\n\nElements\n\nDescriptions and Metadata\n\nComponent‚Äëlevel Modeling\n\nNext Steps\n\nLearn Deployment Modeling for infrastructure perspective\nTake the quiz: DSL Basics Quiz",
    "url": "https://sruja.ai/tutorials/basic/dsl-basics",
    "type": "tutorial",
    "category": "basic",
    "summary": "Learn Sruja syntax: systems, containers, persons, relations, and descriptions.",
    "tags": ["dsl", "modeling"],
    "weight": 20
  },
  {
    "objectID": "tutorial-basic/export-diagrams",
    "title": "Export Diagrams: Mermaid & Studio",
    "content": "Export Diagrams\n\nSruja currently supports export to Mermaid (for Markdown) and interactive visualization in Studio.\n\nExport Formats\n\nMermaid (Markdown)\n\nExport to Mermaid code fences for use in Markdown pages:\n\nThe output includes text\nOpen in Studio from the Learn examples or visit /studio/\n``pkg/export/markdown/MERMAID_CONFIG.md` for available options.\n\nChoosing the Right Path\n\nMermaid: For Markdown-first workflows and lightweight sharing\nStudio: For interactive exploration and richer documentation\n\nNote: Sruja Designer provides interactive diagrams and editing capabilities.",
    "url": "https://sruja.ai/tutorials/basic/export-diagrams",
    "type": "tutorial",
    "category": "basic",
    "summary": "Export architecture to Mermaid (Markdown) or interactive Studio.",
    "tags": ["export", "diagrams", "studio", "mermaid"],
    "weight": 40
  },
  {
    "objectID": "tutorial-basic/systems-thinking",
    "title": "Systems Thinking",
    "content": "Systems Thinking\n\nSystems thinking helps you understand how components interact as part of a whole. Sruja supports five core systems thinking concepts.\n\nParts and Relationships\n\nSystems thinking starts with understanding what the system contains (parts) and how they connect (relationships).\n\nKey insight: Identify the parts first, then define how they relate.\n\nBoundaries\n\nBoundaries define what's inside the system vs. what's outside (the environment).\n\nKey insight: Use  to define internal boundaries,  and  for external boundaries.\n\nFlows\n\nFlows show how information and data move through the system. Sruja supports two flow styles:\n\nData Flow Diagram (DFD) Style\n\nUse  for data-oriented flows:\n\nUser Story/Scenario Style\n\nUse  for behavioral flows:\n\nKey insight: Use  for data flows (DFD), / for behavioral flows (BDD).\n\nFeedback Loops\n\nFeedback loops show how actions create reactions that affect future actions. Cycles are valid patterns in Sruja.\n\nSimple Feedback Loop\n\nSystem Feedback Loop\n\nKey insight: Cycles model natural feedback loops, event-driven patterns, and mutual dependencies. They're valid architectural patterns.\n\nContext\n\nContext defines the environment the system operates in - external dependencies, stakeholders, and surrounding systems.\n\nKey insight: Context includes all external entities and dependencies that affect or are affected by your system.\n\nPutting It All Together\n\nHere's a complete example combining all five concepts:\n\nWhy Systems Thinking Matters\n\nHolistic understanding: See the whole system, not just parts\nNatural patterns: Model real-world interactions and feedback\nClear boundaries: Understand what's in scope vs. context\nFlow visualization: See how data and information move\nValid cycles: Feedback loops are natural, not errors\n\nNext Steps\n\nTry the complete example: \nLearn Deployment Modeling for infrastructure perspective",
    "url": "https://sruja.ai/tutorials/basic/systems-thinking",
    "type": "tutorial",
    "category": "basic",
    "summary": "Learn to model systems holistically: parts, boundaries, flows, feedback loops, and context.",
    "tags": ["systems", "modeling"],
    "weight": 25
  },
  {
    "objectID": "tutorial-basic/validation-linting",
    "title": "Validation & Linting",
    "content": "Validation & Linting\n\nSruja ships with a validation engine that helps keep architectures healthy. This tutorial covers how to use it effectively and troubleshoot common issues.\n\nQuick Start\n\nCommon Validation Checks\n\nSruja validates:\n\nUnique IDs: No duplicate element IDs\nValid references: Relations must connect existing elements\nCycle detection: Informational (cycles are valid for many patterns)\nOrphan detection: Elements not used by any relation\nSimplicity guidance: Suggests simpler syntax when appropriate\nConstraint violations: Policy and constraint rule violations\n\nReal-World Example: E-Commerce Platform\n\nLet's validate a real architecture:\n\nValidation output:\n\nTroubleshooting Common Errors\n\nError 1: Invalid Reference\n\nError message:\n\nProblem: You're referencing an element that doesn't exist.\n\nFix:\n\nReal-world scenario: You renamed a service but forgot to update all references.\n\nError 2: Duplicate ID\n\nError message:\n\nProblem: Two elements have the same ID in the same scope.\n\nFix:\n\nReal-world scenario: You added a new API type but used the same ID.\n\nError 3: Orphan Element\n\nWarning message:\n\nProblem: An element exists but nothing connects to it.\n\nFix options:\n\nAdd a relation (if the element should be used):\n\nRemove the element (if it's not needed):\n\nDocument why it's isolated (if intentional):\n\nReal-world scenario: You added a component for future use but haven't integrated it yet.\n\nError 4: Constraint Violation\n\nError message:\n\nProblem: A constraint rule is being violated.\n\nFix:\n\nReal-world scenario: Enforcing architectural standards (e.g., \"no direct database access from frontend\").\n\nUnderstanding Validation Messages\n\nCycles Are Valid\n\nSruja detects cycles but doesn't block them - cycles are valid architectural patterns:\n\nFeedback loops: User ‚Üî System interactions\nEvent-driven: Service A ‚Üî Service B via events\nMutual dependencies: Microservices that call each other\nBidirectional flows: API ‚Üî Database (read/write)\n\nThe validator will inform you about cycles but won't prevent compilation, as they're often intentional.\n\nSimplicity Guidance\n\nSruja suggests simpler syntax when appropriate:\n\nExample:\n\nThis is informational only - use the level of detail that matches your modeling goal.\n\nCI/CD Integration\n\nGitHub Actions Example\n\nAdd validation to your CI pipeline:\n\nGitLab CI Example\n\nPre-commit Hook\n\nValidate before every commit:\n\nAdvanced: Custom Validation Rules\n\nUse constraints and conventions for custom validation:\n\nReal-World Workflow\n\nStep 1: Write Architecture\n\nStep 2: Validate\n\nStep 3: Fix Errors\n\nAddress any validation errors or warnings.\n\nStep 4: Commit to CI/CD\n\nOnce validation passes locally, commit. CI/CD will validate again.\n\nStep 5: Monitor in Production\n\nUse validation in CI/CD to catch issues before they reach production.\n\nKey Takeaways\n\nValidate early and often: Run  frequently during development\nFix errors immediately: Don't accumulate validation debt\nIntegrate with CI/CD: Catch issues before they reach production\nUnderstand cycles: They're often valid patterns, not errors\nUse constraints: Enforce architectural standards automatically\n\nExercise: Fix Validation Errors\n\nScenario: You have an architecture file with several validation errors.\n\nTasks:\n\nRun  on a file\nIdentify all errors and warnings\nFix each error\nRe-validate to confirm fixes\n\nTime: 10 minutes\n\nFurther Reading\n\nDocs: Validation Concepts\nTutorial: CLI Basics\nCourse: System Design 101 - Module 4: Production Readiness",
    "url": "https://sruja.ai/tutorials/basic/validation-linting",
    "type": "tutorial",
    "category": "basic",
    "summary": "Use Sruja's validator to catch errors, orphan elements, and bad references. Includes troubleshooting guide.",
    "tags": ["validation", "linting", "troubleshooting"],
    "weight": 30
  },
  {
    "objectID": "tutorial-topics",
    "title": "Tutorial Topics",
    "content": "CLI\n\n{{< tutorials-by-tag \"cli\" >}}\n\nDSL\n\n{{< tutorials-by-tag \"dsl\" >}}\n\nValidation\n\n{{< tutorials-by-tag \"validation\" >}}\n\nExport & D2\n\n{{< tutorials-by-tag \"export\" >}}\n{{< tutorials-by-tag \"d2\" >}}\n\nDeployment\n\n{{< tutorials-by-tag \"deployment\" >}}\n\nRelease\n\n{{< tutorials-by-tag \"release\" >}}\n{{< tutorials-by-tag \"goreleaser\" >}}",
    "url": "https://sruja.ai/tutorials/topics",
    "type": "tutorial",
    "category": "topics",
    "summary": "Browse tutorials by topic tags.",
    "weight": 5
  },
  {
    "objectID": "challenge-add-component",
    "title": "Social Feed: Add Recommendation Engine",
    "content": "",
    "url": "https://sruja.ai/challenges/add-component",
    "type": "challenge",
    "summary": "Your social media platform needs personalized content! Add a Recommendation component to the FeedService container that suggests posts based on user interests.",
    "difficulty": "beginner",
    "topic": "components"
  },
  {
    "objectID": "challenge-deployment-architecture",
    "title": "CDN Architecture: Add Cache Layer",
    "content": "",
    "url": "https://sruja.ai/challenges/deployment-architecture",
    "type": "challenge",
    "summary": "Your content delivery network needs a caching layer! Add a Cache datastore and connect it to both the API and CDN edge servers for faster content delivery.",
    "difficulty": "intermediate",
    "topic": "deployment"
  },
  {
    "objectID": "challenge-external-service",
    "title": "Weather App: Integrate Weather API",
    "content": "",
    "url": "https://sruja.ai/challenges/external-service",
    "type": "challenge",
    "summary": "Your weather app needs real-time weather data! Integrate an external weather service (like OpenWeatherMap) that your API can query for current conditions.",
    "difficulty": "intermediate",
    "topic": "integration"
  },
  {
    "objectID": "challenge-fix-relations",
    "title": "Microservices: Connect Service Mesh",
    "content": "",
    "url": "https://sruja.ai/challenges/fix-relations",
    "type": "challenge",
    "summary": "You're building a microservices architecture! Connect the UserService, OrderService, and PaymentService so they can communicate. Each service has its own database.",
    "difficulty": "beginner",
    "topic": "relations"
  },
  {
    "objectID": "challenge-missing-relations",
    "title": "Healthcare Portal: Connect Patient to System",
    "content": "",
    "url": "https://sruja.ai/challenges/missing-relations",
    "type": "challenge",
    "summary": "A patient needs to book an appointment! Model the complete flow: Patient uses the Portal, Portal calls the Appointment API, and API stores data in the database.",
    "difficulty": "beginner",
    "topic": "relations"
  },
  {
    "objectID": "challenge-queue-worker",
    "title": "Email Notification System: Build Async Processor",
    "content": "",
    "url": "https://sruja.ai/challenges/queue-worker",
    "type": "challenge",
    "summary": "Your app sends too many emails synchronously, causing slow responses! Create an async email processing system with a queue and worker to handle notifications in the background.",
    "difficulty": "intermediate",
    "topic": "async"
  },
  {
    "objectID": "challenge-syntax-error",
    "title": "Code Review: Fix the Ride-Sharing App",
    "content": "",
    "url": "https://sruja.ai/challenges/syntax-error",
    "type": "challenge",
    "summary": "A junior developer wrote this code for a ride-sharing app, but it has syntax errors. Find and fix all the issues to get it compiling!",
    "difficulty": "beginner",
    "topic": "validation"
  }
]
