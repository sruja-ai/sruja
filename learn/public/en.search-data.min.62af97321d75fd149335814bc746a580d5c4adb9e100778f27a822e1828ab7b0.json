[{"id":0,"href":"/docs/concepts/architecture/","title":"Architecture","section":"Core Concepts","content":"Architecture# The architecture block is the root element of any Sruja model. It represents the entire scope of what you are modeling.\nSyntax# architecture \u0026#34;My System Name\u0026#34; { // ... define systems, persons, etc. here }Purpose# Scope Boundary: Everything inside is part of the model. Naming: Gives a name to the overall architecture. "},{"id":1,"href":"/community/development-setup/","title":"Development Setup","section":"Community","content":"Development Setup Guide# Get your development environment ready to contribute to Sruja in under 10 minutes. This guide covers everything from installing dependencies to making your first contribution.\nüöÄ Quick Setup (5 minutes)# Prerequisites# Go 1.25+ (we use the latest Go features) Git (for version control) Make (for build automation) 1. Fork and Clone# # Fork the repository on GitHub, then clone your fork git clone https://github.com/YOUR_USERNAME/sruja.git cd sruja # Add the upstream remote git remote add upstream https://github.com/sruja-ai/sruja.git2. Install Dependencies# # Download Go modules go mod download # Install development tools make install-tools3. Build and Test# # Build the project make build # Run tests to ensure everything works make test # Run the linter make lint4. Verify Installation# # Test the CLI ./sruja --help # Run a quick example ./sruja lint examples/simple.srujaüõ†Ô∏è Development Environment Options# VS Code (Recommended)# Install these extensions:\nGo (official Go extension) gopls (language server) Error Lens (enhanced error display) GitLens (Git integration) IntelliJ IDEA / GoLand# Go plugin is built-in Configure Go SDK path Enable go modules integration Vim / Neovim# Install vim-go plugin Configure gopls language server Use coc.nvim for enhanced Go support üìÅ Project Structure Deep Dive# Understanding the codebase structure:\nsruja/ ‚îú‚îÄ‚îÄ cmd/ # Command-line applications ‚îÇ ‚îú‚îÄ‚îÄ sruja/ # Main CLI tool ‚îÇ ‚îî‚îÄ‚îÄ wasm/ # WebAssembly compiler ‚îú‚îÄ‚îÄ pkg/ # Shared packages (library code) ‚îÇ ‚îú‚îÄ‚îÄ config/ # Configuration management ‚îÇ ‚îú‚îÄ‚îÄ dx/ # Developer experience (CLI formatting, errors) ‚îÇ ‚îú‚îÄ‚îÄ engine/ # Validation engine (rules, validation) ‚îÇ ‚îú‚îÄ‚îÄ export/ # Export functionality (D2, JSON, etc.) ‚îÇ ‚îî‚îÄ‚îÄ language/ # Language implementation (parser, AST, lexer) ‚îú‚îÄ‚îÄ examples/ # Example .sruja files ‚îú‚îÄ‚îÄ scripts/ # Build and deployment scripts ‚îî‚îÄ‚îÄ docs/ # Documentation (Hugo site)üîß Development Workflow# Making Changes# Create a feature branch\ngit checkout -b feature/your-feature-name Make your changes\nWrite tests first (TDD approach) Follow existing code patterns Add comments for complex logic Run tests frequently\n# Run all tests make test # Run tests for specific package go test ./pkg/language/ # Run tests with coverage make test-coverage Check code quality\n# Run linter make lint # Format code make fmt # Run all checks make check Testing Your Changes# Unit Tests# # Run specific test go test -run TestParserFunction ./pkg/language/ # Run tests with verbose output go test -v ./... # Run benchmarks go test -bench=. ./...Integration Tests# # Test CLI commands ./sruja lint examples/simple.sruja ./sruja export d2 examples/example.sruja ./sruja tree --file examples/full_features.srujaManual Testing# # Create test files mkdir -p test_files echo \u0026#39;architecture \u0026#34;Test\u0026#34; { system Test \u0026#34;Test System\u0026#34; }\u0026#39; \u0026gt; test_files/test.sruja # Test your changes ./sruja lint test_files/test.srujaüêõ Debugging Tips# VS Code Debugging# Create .vscode/launch.json:\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug Sruja CLI\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;go\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/cmd/sruja\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;lint\u0026#34;, \u0026#34;examples/simple.sruja\u0026#34;], \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } ] }Print Debugging# // Use the existing logger import \u0026#34;log\u0026#34; func yourFunction() { log.Printf(\u0026#34;Debug: variable = %v\u0026#34;, variable) }Delve Debugger# # Install delve go install github.com/go-delve/delve/cmd/dlv@latest # Debug a test dlv test ./pkg/language/ # Debug the CLI dlv debug ./cmd/sruja -- lint examples/simple.srujaüìä Performance Testing# Benchmarking# # Run all benchmarks go test -bench=. ./... # Run specific benchmark go test -bench=BenchmarkParser ./pkg/language/ # Run with memory profiling go test -bench=. -memprofile=mem.prof ./... # Run with CPU profiling go test -bench=. -cpuprofile=cpu.prof ./...Profiling# # Generate CPU profile go tool pprof cpu.prof # Generate memory profile go tool pprof mem.prof # Web-based profiling interface go tool pprof -http=:8080 cpu.profüîç Code Quality Tools# Built-in Tools# # Run all quality checks make check # Individual checks make lint # golangci-lint make fmt # go fmt make vet # go vet make test # go testAdditional Tools# # Install additional tools go install golang.org/x/tools/cmd/goimports@latest go install github.com/securecodewarrior/sast-scan@latest # Run goimports (better than gofmt) goimports -w . # Security scan gosec ./...üöß Common Development Tasks# Adding a New Validation Rule# Create rule in pkg/engine/ Add tests in pkg/engine/*_test.go Register rule in validator Update documentation Adding a New Export Format# Create exporter in pkg/export/ Implement the exporter interface Add CLI command in cmd/sruja/ Add tests and examples Modifying the Language# Update lexer in pkg/language/lexer.go Update parser in pkg/language/parser.go Update AST in pkg/language/ast.go Add comprehensive tests üéØ Next Steps# Now that your environment is set up:\nRead the Contributor Guide for contribution guidelines Check Good First Issues to start contributing Join our Discord community for help and discussions Follow the Contribution Workflow for making contributions üÜò Getting Help# Discord: Join our server for real-time help GitHub Discussions: Ask questions Issues: Report problems Email: dev@sruja.ai Happy coding! üéâ Your contributions help make Sruja better for everyone.\n"},{"id":2,"href":"/docs/getting-started/","title":"Getting Started","section":"Introduction","content":"Getting Started with Sruja# This guide will help you install Sruja and create your first architecture model.\nInstallation# Automated Install (Recommended)# curl -fsSL https://raw.githubusercontent.com/sruja-ai/sruja/main/scripts/install.sh | bashManual Download# Download the latest release for your operating system from the GitHub Releases page.\nFrom Source (Go)# If you have Go installed, you can still build from source:\ngo install github.com/sruja-ai/sruja/cmd/sruja@latestVerify the installation:\nsruja --versionYour First Project# Create a file: Create a new file named architecture.sruja.\nWrite your model:\narchitecture \u0026#34;My System\u0026#34; { system App \u0026#34;My App\u0026#34; { container Web \u0026#34;Web Server\u0026#34; datastore DB \u0026#34;Database\u0026#34; } person User \u0026#34;User\u0026#34; User -\u0026gt; Web \u0026#34;Visits\u0026#34; Web -\u0026gt; DB \u0026#34;Reads/Writes\u0026#34; } Run Loading WASM... Visualize: Export to D2 to see the diagram.\nsruja export d2 architecture.sruja \u0026gt; architecture.d2You can then render architecture.d2 using the D2 CLI or online playground.\n"},{"id":3,"href":"/courses/system-design-201/module-2-real-time/lesson-1/","title":"Lesson 1: Design a Chat Application","section":"Module 2: Real-Time Systems","content":"Lesson 1: Design a Chat Application# Goal: Design a real-time chat service like WhatsApp or Slack that supports 1-on-1 and Group messaging.\nRequirements# Functional# Send/Receive messages in real-time. See user status (Online/Offline). Message history (persistent storage). Non-Functional# Low Latency: Messages must appear instantly. Consistency: Messages must be delivered in order. Availability: High uptime. Core Design# 1. Communication Protocol# HTTP is request/response (pull). For chat, we need push.\nWebSockets: Keeps a persistent connection open between client and server. 2. Message Flow# User A sends message to Chat Server. Chat Server finds which server User B is connected to (using a Session Store like Redis). Chat Server pushes message to User B. 3. Storage# Chat History: Write-heavy. Cassandra or HBase (Wide-column stores) are good for time-series data. User Status: Key-Value store (Redis) with TTL. üõ†Ô∏è Sruja Perspective: Modeling Real-Time Flows# We can use Sruja to model the WebSocket connections and the async message processing.\narchitecture \u0026#34;Chat System\u0026#34; { system ChatApp \u0026#34;WhatsApp Clone\u0026#34; { container ChatServer \u0026#34;Chat Server\u0026#34; { technology \u0026#34;Node.js (Socket.io)\u0026#34; description \u0026#34;Handles WebSocket connections\u0026#34; scale { min 10 max 100 metric \u0026#34;connections \u0026gt; 10k\u0026#34; } } datastore SessionStore \u0026#34;Session Store\u0026#34; { technology \u0026#34;Redis\u0026#34; description \u0026#34;Maps UserID -\u0026gt; WebSocketServerID\u0026#34; } datastore MessageDB \u0026#34;Message History\u0026#34; { technology \u0026#34;Cassandra\u0026#34; description \u0026#34;Stores chat logs\u0026#34; } queue MessageQueue \u0026#34;Message Queue\u0026#34; { technology \u0026#34;Kafka\u0026#34; description \u0026#34;Buffers messages for group chat fan-out\u0026#34; } } person UserA \u0026#34;Alice\u0026#34; person UserB \u0026#34;Bob\u0026#34; // Dynamic view of 1-on-1 chat dynamic ChatServer \u0026#34;Send Message Flow\u0026#34; { UserA -\u0026gt; ChatServer \u0026#34;Send \u0026#39;Hello\u0026#39;\u0026#34; ChatServer -\u0026gt; MessageDB \u0026#34;Persist message\u0026#34; ChatServer -\u0026gt; SessionStore \u0026#34;Lookup Bob\u0026#39;s connection\u0026#34; SessionStore -\u0026gt; ChatServer \u0026#34;Bob is on Server-2\u0026#34; ChatServer -\u0026gt; UserB \u0026#34;Push \u0026#39;Hello\u0026#39;\u0026#34; } }"},{"id":4,"href":"/courses/system-design-201/module-4-consistency/lesson-1/","title":"Lesson 1: Design a Distributed Counter","section":"Module 4: Distributed Consistency","content":"Lesson 1: Design a Distributed Counter# Goal: Design a system to count events (e.g., YouTube views, Facebook likes) at a massive scale (e.g., 1 million writes/sec).\nThe Problem with a Single Database# A standard SQL database (like PostgreSQL) can handle ~2k-5k writes/sec. If we try to update a single row (UPDATE videos SET views = views + 1 WHERE id = 123) for every view, the database will lock the row and become a bottleneck.\nSolutions# 1. Sharding (Write Splitting)# Instead of one counter, have $N$ counters for the same video.\nRandomly pick a counter from $1$ to $N$ and increment it. Total Views = Sum of all $N$ counters. 2. Write-Behind (Batching)# Don\u0026rsquo;t write to the DB immediately.\nStore counts in memory (Redis) or a log (Kafka). A background worker aggregates them and updates the DB every few seconds. Trade-off: If the server crashes before flushing, you lose a few seconds of data (Eventual Consistency). üõ†Ô∏è Sruja Perspective: Modeling Write Flows# We can use Sruja to model the \u0026ldquo;Write-Behind\u0026rdquo; architecture.\narchitecture \u0026#34;Distributed Counter\u0026#34; { system CounterService \u0026#34;View Counter\u0026#34; { container API \u0026#34;Ingestion API\u0026#34; { technology \u0026#34;Go\u0026#34; description \u0026#34;Receives \u0026#39;view\u0026#39; events\u0026#34; } queue EventLog \u0026#34;Kafka\u0026#34; { description \u0026#34;Buffers raw view events\u0026#34; } container Worker \u0026#34;Aggregator\u0026#34; { technology \u0026#34;Python\u0026#34; description \u0026#34;Reads batch of events, sums them, updates DB\u0026#34; scale { min 5 } } datastore DB \u0026#34;Counter DB\u0026#34; { technology \u0026#34;Cassandra\u0026#34; description \u0026#34;Stores final counts (Counter Columns)\u0026#34; } container Cache \u0026#34;Read Cache\u0026#34; { technology \u0026#34;Redis\u0026#34; description \u0026#34;Caches total counts for fast reads\u0026#34; } } person User \u0026#34;Viewer\u0026#34; // Write Path (Eventual Consistency) journey TrackView { User -\u0026gt; API \u0026#34;POST /view\u0026#34; API -\u0026gt; EventLog \u0026#34;Produce Event\u0026#34; API -\u0026gt; User \u0026#34;202 Accepted\u0026#34; // Async processing EventLog -\u0026gt; Worker \u0026#34;Consume Batch\u0026#34; Worker -\u0026gt; DB \u0026#34;UPDATE views += batch_size\u0026#34; Worker -\u0026gt; Cache \u0026#34;Invalidate/Update\u0026#34; } }"},{"id":5,"href":"/courses/system-design-201/module-1-high-throughput/lesson-1/","title":"Lesson 1: Design a URL Shortener","section":"Module 1: High-Throughput Systems","content":"Lesson 1: Design a URL Shortener# Goal: Design a service like TinyURL that takes a long URL and converts it into a short alias (e.g., http://tiny.url/xyz).\nRequirements# Functional# shorten(long_url) -\u0026gt; short_url redirect(short_url) -\u0026gt; long_url Custom aliases (optional). Non-Functional# Highly Available: If the service is down, URL redirection stops working. Low Latency: Redirection must happen in milliseconds. Read-Heavy: 100:1 read-to-write ratio. Core Design# 1. Database Choice# Since we need fast lookups and the data model is simple (Key-Value), a NoSQL Key-Value Store (like DynamoDB or Redis) is ideal.\nKey: short_alias Value: long_url 2. Hashing Algorithm# How do we generate the alias?\nMD5/SHA256: Too long. Base62 Encoding: Converts a unique ID (from a counter or database ID) into a string of characters [a-z, A-Z, 0-9]. üõ†Ô∏è Sruja Perspective: Modeling the Flow# We can use Sruja to model the system components and the user journey for redirection.\narchitecture \u0026#34;URL Shortener\u0026#34; { // Define the system boundary system TinyURL \u0026#34;TinyURL Service\u0026#34; { container WebServer \u0026#34;API Server\u0026#34; { technology \u0026#34;Go\u0026#34; scale { min 3 max 20 metric \u0026#34;cpu \u0026gt; 70%\u0026#34; } } datastore DB \u0026#34;UrlStore\u0026#34; { technology \u0026#34;DynamoDB\u0026#34; description \u0026#34;Stores mapping: short_alias -\u0026gt; long_url\u0026#34; } container Cache \u0026#34;Cache\u0026#34; { technology \u0026#34;Redis\u0026#34; description \u0026#34;Caches popular redirects\u0026#34; } } person User \u0026#34;User\u0026#34; // Define the redirection journey journey RedirectFlow { title \u0026#34;User clicks a short link\u0026#34; steps { User -\u0026gt; WebServer \u0026#34;GET /xyz\u0026#34; WebServer -\u0026gt; Cache \u0026#34;Check cache for \u0026#39;xyz\u0026#39;\u0026#34; Cache -\u0026gt; WebServer \u0026#34;Miss\u0026#34; WebServer -\u0026gt; DB \u0026#34;Get long_url for \u0026#39;xyz\u0026#39;\u0026#34; DB -\u0026gt; WebServer \u0026#34;Return \u0026#39;http://example.com\u0026#39;\u0026#34; WebServer -\u0026gt; User \u0026#34;301 Redirect to \u0026#39;http://example.com\u0026#39;\u0026#34; } } }"},{"id":6,"href":"/courses/system-design-201/module-3-data-intensive/lesson-1/","title":"Lesson 1: Design a Video Streaming Service","section":"Module 3: Data-Intensive Systems","content":"Lesson 1: Design a Video Streaming Service# Goal: Design a video sharing platform like YouTube or Netflix where users can upload and watch videos.\nRequirements# Functional# Upload videos. Watch videos (streaming). Support multiple resolutions (360p, 720p, 1080p). Non-Functional# Reliability: No buffering. Availability: Videos are always accessible. Scalability: Handle millions of concurrent viewers. Core Design# 1. Storage (Blob Store)# Videos are large binary files (BLOBs). Databases are bad for this.\nObject Storage: AWS S3, Google Cloud Storage. Metadata: Store title, description, and S3 URL in a SQL/NoSQL DB. 2. Processing (Transcoding)# Raw uploads are huge. We need to convert them into different formats and resolutions.\nTranscoding Service: Breaks video into chunks and encodes them (H.264, VP9). 3. Delivery (CDN)# Serving video from a single server is too slow for global users.\nContent Delivery Network (CDN): Caches video chunks in edge servers close to the user. 4. Adaptive Bitrate Streaming (HLS/DASH)# The player automatically switches quality based on the user\u0026rsquo;s internet speed.\nüõ†Ô∏è Sruja Perspective: Modeling Infrastructure# We can use Sruja\u0026rsquo;s deployment nodes to visualize the global distribution of content.\narchitecture \u0026#34;Video Streaming\u0026#34; { system YouTube \u0026#34;Video Platform\u0026#34; { container WebApp \u0026#34;Web App\u0026#34; container API \u0026#34;API Server\u0026#34; container Transcoder \u0026#34;Transcoding Service\u0026#34; { description \u0026#34;Converts raw video to HLS format\u0026#34; scale { min 50 } } datastore S3 \u0026#34;Blob Storage\u0026#34; { description \u0026#34;Stores raw and processed video files\u0026#34; } datastore MetadataDB \u0026#34;Metadata DB\u0026#34; } // Deployment View deployment GlobalInfra \u0026#34;Global Infrastructure\u0026#34; { node OriginDC \u0026#34;Origin Data Center\u0026#34; { containerInstance WebApp containerInstance API containerInstance Transcoder containerInstance S3 } node CDN \u0026#34;CDN (Edge Locations)\u0026#34; { description \u0026#34;Cloudflare / Akamai\u0026#34; // Represents cached content node \u0026#34;US-East Edge\u0026#34; node \u0026#34;Europe Edge\u0026#34; node \u0026#34;Asia Edge\u0026#34; } } person User \u0026#34;Viewer\u0026#34; // Streaming Flow journey WatchVideo { User -\u0026gt; WebApp \u0026#34;Get Video Page\u0026#34; WebApp -\u0026gt; API \u0026#34;Get Metadata (Title, URL)\u0026#34; API -\u0026gt; MetadataDB \u0026#34;Query\u0026#34; API -\u0026gt; User \u0026#34;Return Video Manifest URL\u0026#34; User -\u0026gt; CDN \u0026#34;Request Video Chunk (1080p)\u0026#34; CDN -\u0026gt; User \u0026#34;Stream Chunk\u0026#34; } }"},{"id":7,"href":"/courses/system-design-101/module-4-production-readiness/lesson-1/","title":"Lesson 1: Documenting Decisions (ADRs)","section":"Module 4: Production Readiness","content":"Lesson 1: Documenting Decisions (ADRs)# What is an ADR?# An Architecture Decision Record (ADR) is a document that captures an important architectural decision made along with its context and consequences.\nWhy use ADRs?# Context: Explains why a decision was made (e.g., \u0026ldquo;Why did we choose Postgres over Mongo?\u0026rdquo;). Onboarding: Helps new team members understand the history of the system. Alignment: Ensures everyone agrees on the path forward. Structure of an ADR# Title: Short summary. Status: Proposed, Accepted, Deprecated. Context: The problem we are solving. Decision: What we are doing. Consequences: The pros and cons of this decision. üõ†Ô∏è Sruja Perspective: Native ADR Support# Sruja treats ADRs as first-class citizens. You can define them directly in your architecture file.\narchitecture \u0026#34;Payment System\u0026#34; { // Define an ADR adr ADR001 \u0026#34;Use Stripe for Payments\u0026#34; { status \u0026#34;Accepted\u0026#34; context \u0026#34;We need a reliable payment processor that supports global currencies.\u0026#34; decision \u0026#34;We will use Stripe as our primary payment gateway.\u0026#34; consequences \u0026#34;Vendor lock-in, but faster time to market.\u0026#34; } system PaymentService \u0026#34;Payment Service\u0026#34; { // Link the ADR to the component it affects adr ADR001 description \u0026#34;Handles credit card processing.\u0026#34; } }This ensures that your documentation lives right next to the code it describes, making it harder to ignore or lose.\n"},{"id":8,"href":"/courses/system-design-101/module-2-building-blocks/lesson-1/","title":"Lesson 1: Load Balancers","section":"Module 2: Building Blocks","content":"Lesson 1: Load Balancers# What is a Load Balancer?# A load balancer sits between clients and servers, distributing incoming network traffic across a group of backend servers. This ensures that no single server bears too much load.\nTypes of Load Balancing# Layer 4 (Transport Layer)# Decisions based on IP address and TCP/UDP ports. Faster, less CPU intensive. Does not inspect the content of the request. Layer 7 (Application Layer)# Decisions based on the content of the message (URL, HTTP headers, cookies). Can route traffic to different services based on URL (e.g., /images to image servers). More CPU intensive but smarter. Algorithms# Round Robin: Requests are distributed sequentially. Least Connections: Sends request to the server with the fewest active connections. IP Hash: The client\u0026rsquo;s IP address is used to determine which server receives the request (useful for session stickiness). üõ†Ô∏è Sruja Perspective: Modeling Load Balancers# In Sruja, a load balancer is typically modeled as a container or component that sits in front of your application servers.\narchitecture \u0026#34;Web Application\u0026#34; { container LB \u0026#34;Nginx Load Balancer\u0026#34; { technology \u0026#34;Nginx\u0026#34; tags \u0026#34;load-balancer\u0026#34; description \u0026#34;Layer 7 load balancer routing traffic based on URL paths.\u0026#34; } container AppServer \u0026#34;App Server\u0026#34; { technology \u0026#34;Python, Django\u0026#34; tags \u0026#34;scaled\u0026#34; } // Traffic flow LB -\u0026gt; AppServer \u0026#34;Distributes requests (Round Robin)\u0026#34; }"},{"id":9,"href":"/courses/system-design-101/module-3-advanced-modeling/lesson-1/","title":"Lesson 1: Microservices Architecture","section":"Module 3: Advanced Modeling","content":"Lesson 1: Microservices Architecture# Monolith vs. Microservices# Monolithic Architecture# A single application where all functionality is packaged together.\nPros: Simple to develop, deploy, and test initially. Cons: Hard to scale specific parts, tight coupling, single point of failure. Microservices Architecture# A collection of small, independent services that communicate over a network.\nPros: Independent scaling, technology diversity, fault isolation. Cons: Distributed system complexity, network latency, data consistency challenges. Defining Service Boundaries# The hardest part of microservices is deciding where to draw the lines. Common strategies include:\nBusiness Capability: Group by what the business does (e.g., Billing, Shipping). Subdomain: Group by Domain-Driven Design (DDD) subdomains. üõ†Ô∏è Sruja Perspective: Modeling Microservices# In Sruja, microservices are typically modeled as separate container items within a system, or even as separate system items if they are large enough.\narchitecture \u0026#34;E-Commerce Platform\u0026#34; { system OrderSystem \u0026#34;Order Management\u0026#34; { container OrderService \u0026#34;Order Service\u0026#34; { technology \u0026#34;Go\u0026#34; description \u0026#34;Handles order placement and tracking.\u0026#34; } } system InventorySystem \u0026#34;Inventory Management\u0026#34; { container InventoryService \u0026#34;Inventory Service\u0026#34; { technology \u0026#34;Java\u0026#34; description \u0026#34;Tracks stock levels.\u0026#34; } } // Inter-service communication OrderSystem -\u0026gt; InventorySystem \u0026#34;Reserves stock\u0026#34; }"},{"id":10,"href":"/courses/system-design-101/module-1-fundamentals/lesson-1/","title":"Lesson 1: What is System Design?","section":"Module 1: Fundamentals","content":"Lesson 1: What is System Design?# Defining System Design# System design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It is the bridge between business requirements and the final code.\nAt its core, system design is about managing complexity and making trade-offs. There is rarely a single \u0026ldquo;correct\u0026rdquo; design; instead, there are different designs that optimize for different goals (e.g., speed of development vs. system performance).\nRequirements Analysis# Every system design interview or real-world project starts with clarifying requirements. These are generally categorized into two types:\n1. Functional Requirements# These define what the system should do. They describe the specific behaviors or functions.\nExample: \u0026ldquo;Users should be able to post a tweet.\u0026rdquo; Example: \u0026ldquo;The system should send a notification when a new follower is added.\u0026rdquo; 2. Non-Functional Requirements (NFRs)# These define how the system should perform. They act as constraints on the design.\nScalability: Can the system handle 10 million daily active users? Availability: Will the system be up 99.99% of the time? Latency: Should the API respond within 200ms? Consistency: Do all users need to see the same data at the same time? The Art of Trade-offs# \u0026ldquo;Good\u0026rdquo; system design is all about choosing the right trade-offs.\nConsistency vs. Availability: You often can\u0026rsquo;t have both perfectly (CAP Theorem). Latency vs. Throughput: Optimizing for one might hurt the other. Cost vs. Performance: Faster hardware is more expensive. üõ†Ô∏è Sruja Perspective: Documenting Requirements# While Sruja is primarily for modeling architecture, it is also an excellent place to capture your requirements right alongside your design.\nIn Sruja, you can use the description field or comments to document high-level requirements.\narchitecture \u0026#34;Twitter Clone\u0026#34; { // Native Requirement Support requirement R1 functional \u0026#34;Users can post tweets\u0026#34; requirement R2 performance \u0026#34;Must handle 10k writes/second\u0026#34; system Twitter \u0026#34;Social Media Platform\u0026#34; { description \u0026#34;Allows users to post short messages and follow others.\u0026#34; } }By using the requirement keyword, you make requirements a first-class citizen of your architecture. These can be validated and tracked by the Sruja CLI.\n"},{"id":11,"href":"/courses/system-design-101/module-1-fundamentals/","title":"Module 1: Fundamentals","section":"System Design 101","content":"Module 1: Fundamentals# Before diving into specific technologies like databases or load balancers, it\u0026rsquo;s crucial to understand the fundamental principles that guide system design. In this module, we will explore the core concepts that every system architect must know.\nLessons# What is System Design? Learn about functional and non-functional requirements and the art of trade-offs. Scalability \u0026amp; Performance Understand the difference between vertical and horizontal scaling, and latency vs. throughput. Availability \u0026amp; Reliability Explore redundancy, failover strategies, and SLAs. CAP Theorem \u0026amp; Consistency Dive into the trade-offs between Consistency, Availability, and Partition Tolerance. User Journeys Learn how to model user flows and validate your architecture with scenarios. "},{"id":12,"href":"/courses/system-design-201/module-1-high-throughput/","title":"Module 1: High-Throughput Systems","section":"System Design 201: Real-World Architectures","content":"Module 1: High-Throughput Systems# In this module, we focus on systems that need to handle a massive number of requests per second with low latency.\nLessons# Design a URL Shortener TinyURL: Handling high read/write ratios and redirection. Design a Rate Limiter Protection: Preventing abuse and managing traffic spikes. "},{"id":13,"href":"/community/contribution-workflow/","title":"Contribution Workflow","section":"Community","content":"Contribution Workflow# This guide walks you through the complete process of making your first contribution to Sruja, from finding an issue to getting your pull request merged.\nüéØ Before You Start# Choose Your Contribution Type# üêõ Bug Fix: Fix existing issues ‚ú® Feature: Add new functionality üìö Documentation: Improve docs, tutorials, examples üßπ Refactoring: Code improvements without changing behavior ‚ö° Performance: Make things faster üß™ Testing: Add or improve tests Find Something to Work On# For Beginners# Good First Issues: Perfect for newcomers Help Wanted: Community-requested features Documentation: Improve our docs For Experienced Contributors# Feature Requests: New functionality Bugs: Fix existing issues Performance: Speed improvements üîÑ The Contribution Process# Step 1: Claim an Issue# Browse open issues on GitHub Issues Comment on the issue saying you\u0026rsquo;d like to work on it Wait for assignment (maintainers will assign it to you) Ask questions if anything is unclear Step 2: Set Up Your Environment# # 1. Fork the repository on GitHub # 2. Clone your fork git clone https://github.com/YOUR_USERNAME/sruja.git cd sruja # 3. Add upstream remote git remote add upstream https://github.com/sruja-ai/sruja.git # 4. Set up development environment make build make testStep 3: Create a Feature Branch# # Create and switch to a new branch git checkout -b feature/your-feature-name # Or for bug fixes git checkout -b fix/issue-number-brief-descriptionBranch Naming Conventions:\nfeature/add-new-validation-rule fix/parser-memory-leak docs/improve-getting-started refactor/optimize-lexer-performance Step 4: Make Your Changes# Code Changes# Write tests first (TDD approach recommended) Implement your changes Run tests frequently Follow code style guidelines Documentation Changes# Follow documentation style guide Include examples and code snippets Test all commands and examples Update relevant sections Testing Your Changes# # Run all tests make test # Run specific test file go test ./pkg/language/ -v # Run linter make lint # Format code make fmt # Run all checks make checkStep 5: Commit Your Changes# Commit Message Format# type(scope): brief description Longer description if needed. Fixes #123Types:\nfeat: New feature fix: Bug fix docs: Documentation changes style: Code style changes (formatting, etc.) refactor: Code refactoring test: Adding or updating tests chore: Maintenance tasks Examples:\nfeat(parser): add support for metadata annotations Implement parsing of metadata blocks in architecture definitions. This allows users to add custom metadata to any architectural element. Fixes #156fix(validator): resolve cycle detection false positive The cycle detection algorithm was incorrectly flagging valid dependency chains as cyclic. Updated the algorithm to properly handle nested references. Fixes #142Commit Best Practices# Keep commits atomic (one logical change per commit) Write clear commit messages Reference issues with Fixes #123 or Relates to #456 Sign commits if possible (git commit -S) Step 6: Push and Create Pull Request# Push Your Branch# # Push your branch to your fork git push origin feature/your-feature-nameCreate Pull Request# Go to GitHub and navigate to your fork Click \u0026ldquo;Compare \u0026amp; pull request\u0026rdquo; Fill out the PR template completely Link related issues using \u0026ldquo;Fixes #123\u0026rdquo; Add screenshots if UI changes Request review from maintainers Step 7: Address Review Feedback# Review Process# Maintainers will review your PR within 2-3 days Address feedback promptly and thoroughly Ask questions if feedback is unclear Push additional commits to the same branch Resolve conversations after addressing feedback Common Review Feedback# Add more tests for edge cases Update documentation for new features Follow code style guidelines Improve performance if needed Add error handling for edge cases Step 8: Get Merged! üéâ# Final Steps# All tests pass (CI/CD pipeline) Code review approved by maintainers Branch is up to date with main Squash commits if requested Celebrate your contribution! üìù Pull Request Template# When creating a PR, use this template:\n## Description Brief description of changes made. ## Type of Change - [ ] Bug fix - [ ] New feature - [ ] Documentation update - [ ] Performance improvement - [ ] Code refactoring ## Related Issues Fixes #123 Relates to #456 ## Testing - [ ] Unit tests added/updated - [ ] Integration tests pass - [ ] Manual testing completed - [ ] Documentation updated ## Checklist - [ ] Code follows project style guidelines - [ ] Self-review completed - [ ] Comments added for complex code - [ ] Documentation updated - [ ] Tests added/updated - [ ] All tests pass ## Screenshots (if applicable) Add screenshots for UI changes. ## Additional Notes Any additional information for reviewers.üöÄ Quick Reference# Common Commands# # Set up development environment make build \u0026amp;\u0026amp; make test # Run all checks before committing make check # Create and switch to new branch git checkout -b feature/name # Run tests for specific package go test ./pkg/language/ -v # Format and lint code make fmt \u0026amp;\u0026amp; make lint # Push branch and create PR git push origin feature/nameGit Workflow# # Keep your fork up to date git fetch upstream git checkout main git merge upstream/main git push origin main # Create feature branch git checkout -b feature/name # Make changes and commit git add . git commit -m \u0026#34;feat: add new feature\u0026#34; # Push to your fork git push origin feature/name # After PR is merged, delete branch git branch -d feature/name git push origin --delete feature/nameüéØ Tips for Success# For First-Time Contributors# Start small with documentation or good first issues Ask questions in Discord or GitHub discussions Read existing code to understand patterns Follow the style guide consistently Be patient with the review process For Experienced Contributors# Help review other PRs Mentor newcomers in the community Suggest improvements to the contribution process Participate in discussions about project direction Share your knowledge through blog posts or talks üÜò Getting Help# During Development# Discord: Join our server for real-time help GitHub Discussions: Ask questions Documentation: Check our docs and guides Examples: Look at existing code for patterns When Stuck# Check existing issues for similar problems Search documentation and code comments Ask in Discord or GitHub discussions Create a draft PR to get early feedback Don\u0026rsquo;t hesitate to ask - we\u0026rsquo;re here to help! üèÜ Recognition# Contributors are recognized through:\nGitHub contributor list Release notes mentions Contributors Hall of Fame Social media shoutouts Conference speaking opportunities Ready to make your first contribution?\nüöÄ Find Good First Issues ‚Üí\nüí¨ Join Discord for Help ‚Üí\nüìñ Read Contributor Guide ‚Üí\n"},{"id":14,"href":"/docs/concepts/","title":"Core Concepts","section":"Introduction","content":"Core Concepts# Sruja is built around the C4 Model for visualizing software architecture. It defines a hierarchy of abstractions:\nArchitecture: The root context. System: The highest level of abstraction. A software system. Container: Applications or data stores within a system (e.g., API, Web App, Database). Component: Modules or major structural building blocks within a container. Elements# Architecture System Container Component Person DataStore Queue Relations Deployment Dynamic Views "},{"id":15,"href":"/courses/system-design-101/module-2-building-blocks/lesson-2/","title":"Lesson 2: Databases","section":"Module 2: Building Blocks","content":"Lesson 2: Databases# SQL vs. NoSQL# SQL (Relational Databases)# Structure: Structured data with predefined schemas (Tables, Rows, Columns). Query Language: SQL (Structured Query Language). ACID Compliance: Strong guarantees for Atomicity, Consistency, Isolation, Durability. Examples: MySQL, PostgreSQL, Oracle. Best for: Complex queries, financial transactions. NoSQL (Non-Relational Databases)# Structure: Flexible schemas (Key-Value, Document, Graph, Column-Family). Scalability: Designed for horizontal scaling. Examples: MongoDB (Document), Redis (Key-Value), Cassandra (Column). Best for: Rapidly changing data, massive scale, unstructured data. Scaling Databases# Replication# Copying data to multiple servers.\nMaster-Slave: Writes go to Master, Reads go to Slaves. Good for read-heavy systems. Master-Master: Writes can go to any node. Complex conflict resolution needed. Sharding# Partitioning data across multiple servers (e.g., Users A-M on Server 1, N-Z on Server 2).\nPros: Handles massive data volumes. Cons: Complex joins, rebalancing data is hard. üõ†Ô∏è Sruja Perspective: Modeling Databases# Sruja allows you to define the type of database and its role in the system.\narchitecture \u0026#34;User Management\u0026#34; { container UserDB \u0026#34;User Database\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; tags \u0026#34;relational\u0026#34;, \u0026#34;primary\u0026#34; description \u0026#34;Stores user profiles and authentication data.\u0026#34; } container SessionStore \u0026#34;Session Cache\u0026#34; { technology \u0026#34;Redis\u0026#34; tags \u0026#34;key-value\u0026#34;, \u0026#34;cache\u0026#34; description \u0026#34;Stores active user sessions for fast access.\u0026#34; } }"},{"id":16,"href":"/courses/system-design-101/module-4-production-readiness/lesson-2/","title":"Lesson 2: Deployment Architecture","section":"Module 4: Production Readiness","content":"Lesson 2: Deployment Architecture# Logical vs. Physical Architecture# Logical Architecture: The software components and how they interact (Containers, Components). Physical Architecture: Where those components actually run (Servers, VMs, Kubernetes Pods). Deployment Strategies# On-Premises# Running on your own hardware in a data center.\nPros: Total control, security. Cons: High maintenance, capital expense. Cloud (AWS, GCP, Azure)# Renting infrastructure from a provider.\nPros: Pay-as-you-go, infinite scale. Cons: Vendor lock-in, variable costs. Containers \u0026amp; Orchestration# Packaging code with dependencies (Docker) and managing them at scale (Kubernetes).\nüõ†Ô∏è Sruja Perspective: Deployment Nodes# Sruja allows you to map your logical containers to physical deployment nodes.\narchitecture \u0026#34;Web App\u0026#34; { container WebServer \u0026#34;Nginx\u0026#34; container AppServer \u0026#34;Python App\u0026#34; container Database \u0026#34;Postgres\u0026#34; // Define the deployment environment deployment \u0026#34;Production\u0026#34; { node \u0026#34;AWS\u0026#34; { node \u0026#34;US-East-1\u0026#34; { node \u0026#34;EC2 Instance\u0026#34; { // Map the logical container to this node containerInstance WebServer containerInstance AppServer } node \u0026#34;RDS\u0026#34; { containerInstance Database } } } } }This mapping allows you to visualize exactly where your code is running in production.\n"},{"id":17,"href":"/courses/system-design-201/module-1-high-throughput/lesson-2/","title":"Lesson 2: Design a Rate Limiter","section":"Module 1: High-Throughput Systems","content":"Lesson 2: Design a Rate Limiter# Goal: Design a system to limit the number of requests a client can send to an API within a time window (e.g., 10 requests per second).\nWhy Rate Limit?# Prevent Abuse: Stop DDoS attacks or malicious bots. Fairness: Ensure one user doesn\u0026rsquo;t hog all resources. Cost Control: Prevent auto-scaling bills from exploding. Algorithms# Token Bucket# A \u0026ldquo;bucket\u0026rdquo; holds tokens. Tokens are added at a fixed rate (e.g., 10 tokens/sec). Each request consumes a token. If the bucket is empty, the request is dropped (429 Too Many Requests). Leaky Bucket# Requests enter a queue (bucket) and are processed at a constant rate. If the queue is full, new requests are dropped. Architecture Location# Where does the rate limiter live?\nClient-side: Unreliable (can be forged). Server-side: Inside the application code. Middleware: In a centralized API Gateway (Best practice). üõ†Ô∏è Sruja Perspective: Middleware Modeling# In Sruja, we can model the Rate Limiter as a component within the API Gateway, backed by a fast datastore like Redis.\narchitecture \u0026#34;API Rate Limiter\u0026#34; { system APIGateway \u0026#34;API Gateway\u0026#34; { container GatewayService \u0026#34;Gateway\u0026#34; { technology \u0026#34;Nginx / Kong\u0026#34; component RateLimiter \u0026#34;Rate Limiter Middleware\u0026#34; { description \u0026#34;Implements Token Bucket algorithm\u0026#34; } } datastore Redis \u0026#34;Rate Limit Store\u0026#34; { technology \u0026#34;Redis\u0026#34; description \u0026#34;Stores token counts per user/IP\u0026#34; } } system Backend \u0026#34;Backend Service\u0026#34; GatewayService -\u0026gt; Backend \u0026#34;Forward Requests\u0026#34; person Client \u0026#34;Client\u0026#34; // Dynamic view of a request being limited dynamic GatewayService \u0026#34;Rate Limit Check\u0026#34; { Client -\u0026gt; GatewayService \u0026#34;API Request\u0026#34; GatewayService -\u0026gt; RateLimiter \u0026#34;Check Limit\u0026#34; RateLimiter -\u0026gt; Redis \u0026#34;DECR user_123_tokens\u0026#34; Redis -\u0026gt; RateLimiter \u0026#34;Result: -1 (Empty)\u0026#34; RateLimiter -\u0026gt; GatewayService \u0026#34;Deny\u0026#34; GatewayService -\u0026gt; Client \u0026#34;429 Too Many Requests\u0026#34; } }"},{"id":18,"href":"/courses/system-design-101/module-3-advanced-modeling/lesson-2/","title":"Lesson 2: Event-Driven Architecture","section":"Module 3: Advanced Modeling","content":"Lesson 2: Event-Driven Architecture# Synchronous vs. Asynchronous# Synchronous (Request/Response): Client waits for the server to respond (e.g., HTTP REST). Asynchronous (Event-Driven): Client sends a message and continues work. The receiver processes it later. Core Concepts# Message Queues (Point-to-Point)# A message is sent to a queue and processed by exactly one consumer.\nUse Case: Background jobs (e.g., image resizing). Pub/Sub (Publish/Subscribe)# A message (event) is published to a topic. Multiple subscribers can receive a copy.\nUse Case: notifying multiple services (e.g., \u0026ldquo;UserSignedUp\u0026rdquo; -\u0026gt; EmailService, AnalyticsService). üõ†Ô∏è Sruja Perspective: Modeling Events# Sruja supports queue as a first-class citizen to model asynchronous communication.\narchitecture \u0026#34;Notification System\u0026#34; { container AuthService \u0026#34;Auth Service\u0026#34; { technology \u0026#34;Node.js\u0026#34; } // Define a queue or topic queue UserEvents \u0026#34;User Events Topic\u0026#34; { technology \u0026#34;Kafka\u0026#34; description \u0026#34;Events related to user lifecycle (signup, login).\u0026#34; } container EmailService \u0026#34;Email Service\u0026#34; { technology \u0026#34;Python\u0026#34; } container AnalyticsService \u0026#34;Analytics Service\u0026#34; { technology \u0026#34;Spark\u0026#34; } // Pub/Sub flow AuthService -\u0026gt; UserEvents \u0026#34;Publishes \u0026#39;UserSignedUp\u0026#39;\u0026#34; UserEvents -\u0026gt; EmailService \u0026#34;Consumes\u0026#34; UserEvents -\u0026gt; AnalyticsService \u0026#34;Consumes\u0026#34; }"},{"id":19,"href":"/courses/system-design-101/module-1-fundamentals/lesson-2/","title":"Lesson 2: Scalability \u0026 Performance","section":"Module 1: Fundamentals","content":"Lesson 2: Scalability \u0026amp; Performance# What is Scalability?# Scalability is the ability of a system to handle increased load without performance degradation. It\u0026rsquo;s not just about \u0026ldquo;handling more users\u0026rdquo;; it\u0026rsquo;s about doing so cost-effectively and reliably.\nVertical Scaling (Scaling Up)# Adding more power (CPU, RAM) to an existing server.\nPros: Simple to implement. Cons: Hardware limits, single point of failure, expensive at the high end. Horizontal Scaling (Scaling Out)# Adding more servers to the pool of resources.\nPros: Theoretically infinite scale, better fault tolerance. Cons: Increased complexity (load balancing, data consistency). Performance Metrics# Latency# The time it takes for a system to process a request.\nGoal: Minimize latency (e.g., \u0026ldquo;API response \u0026lt; 100ms\u0026rdquo;). Throughput# The number of requests a system can handle per unit of time.\nGoal: Maximize throughput (e.g., \u0026ldquo;Handle 10,000 requests per second\u0026rdquo;). üõ†Ô∏è Sruja Perspective: Modeling Scalability# In Sruja, you can represent horizontal scaling using the native scale block. This allows you to define minimum and maximum replicas and the scaling metric.\narchitecture \u0026#34;E-Commerce Site\u0026#34; { container WebServer \u0026#34;Web App\u0026#34; { technology \u0026#34;Go, Gin\u0026#34; // Define horizontal scaling properties scale { min 3 max 10 metric \u0026#34;cpu \u0026gt; 80%\u0026#34; } } container Database \u0026#34;Primary DB\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; // Vertical scaling example description \u0026#34;Running on a high-memory instance (AWS r5.2xlarge).\u0026#34; } }"},{"id":20,"href":"/courses/system-design-101/module-2-building-blocks/","title":"Module 2: Building Blocks","section":"System Design 101","content":"Module 2: Building Blocks# A distributed system is built from several key components. In this module, we will explore the most common building blocks and how to use them effectively.\nLessons# Load Balancers Distributing traffic across multiple servers. Databases Choosing between SQL and NoSQL, and scaling data. Caching Improving performance with in-memory data stores. "},{"id":21,"href":"/courses/system-design-201/module-2-real-time/","title":"Module 2: Real-Time Systems","section":"System Design 201: Real-World Architectures","content":"Module 2: Real-Time Systems# In this module, we explore systems where data needs to be pushed to the client instantly, rather than pulled.\nLessons# Design a Chat Application WhatsApp/Slack: Handling persistent connections and message delivery. "},{"id":22,"href":"/docs/concepts/system/","title":"System","section":"Core Concepts","content":"System# A System represents a software system, which is the highest level of abstraction in the C4 model. A system delivers value to its users, whether they are human or other systems.\nSyntax# system ID \u0026#34;Label/Name\u0026#34; { description \u0026#34;Optional description\u0026#34; // ... contains containers }Example# system BankingSystem \u0026#34;Internet Banking System\u0026#34; { description \u0026#34;Allows customers to view accounts and make payments.\u0026#34; }"},{"id":23,"href":"/docs/concepts/container/","title":"Container","section":"Core Concepts","content":"Container# A Container represents an application or a data store. It is something that needs to be running in order for the overall software system to work.\nNote: In C4, \u0026ldquo;Container\u0026rdquo; does not mean a Docker container. It means a deployable unit like:\nServer-side web application (e.g., Java Spring, ASP.NET Core) Client-side web application (e.g., React, Angular) Mobile app Database schema File system Syntax# container ID \u0026#34;Label/Name\u0026#34; { technology \u0026#34;Technology Stack\u0026#34; tags [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] // ... contains components }Example# container WebApp \u0026#34;Web Application\u0026#34; { technology \u0026#34;Java and Spring MVC\u0026#34; tags [\u0026#34;web\u0026#34;, \u0026#34;frontend\u0026#34;] }"},{"id":24,"href":"/community/contributors/","title":"Contributors Hall of Fame","section":"Community","content":"Contributors Hall of Fame# Sruja is built by an amazing community of contributors. Meet the people who are shaping the future of architecture-as-code.\nüèÜ Top Contributors# Core Team# Jane Doe Project Lead \u0026 Language Designer\nLeading the development of Sruja's architecture-as-code language. Passionate about making software architecture more accessible and maintainable.\nüíª 150+ commits üìù 50+ PRs üéØ Language Design GitHub Twitter LinkedIn John Smith Core Maintainer \u0026 Validator Engine\nBuilding the validation engine that ensures architectural consistency. Expert in static analysis and compiler design.\nüíª 120+ commits üìù 40+ PRs üîç Validation Rules GitHub Twitter Dev.to üåü Community Contributors# Language \u0026amp; Parser Contributors# Alex Martinez Parser \u0026 Lexer Expert\nEnhanced the parser with better error messages and performance improvements. Key contributor to the language grammar.\nüíª 80+ commits üöÄ Performance üìù Parser GitHub Sarah Kim AST \u0026 Code Generation\nImproved the Abstract Syntax Tree implementation and added new code generation capabilities for multiple output formats.\nüíª 65+ commits üéØ AST üìä Code Generation GitHub Documentation \u0026amp; Education Contributors# Mike Chen Documentation Lead\nTransformed our documentation with comprehensive guides, tutorials, and examples. Made Sruja accessible to newcomers.\nüìù 45+ docs üéì Tutorials üìö Education GitHub Lisa Wang Course Content Creator\nDeveloped the comprehensive system design course content that teaches architecture principles using Sruja.\nüéì 30+ lessons üìñ Course Design üèóÔ∏è Architecture GitHub Tooling \u0026amp; Integration Contributors# David Rodriguez CLI \u0026 Tooling Expert\nBuilt the powerful CLI interface and integrated various development tools. Enhanced developer experience significantly.\nüíª 55+ commits üõ†Ô∏è CLI ‚ö° Tooling GitHub Emma Johnson Export \u0026 Integration Specialist\nCreated multiple export formats and integrations with popular tools. Made Sruja work seamlessly with existing workflows.\nüìä 25+ integrations üîÑ Export Formats üîó Integration GitHub üèÖ Recognition Programs# Monthly Contributor Spotlight# Each month we highlight exceptional contributors who go above and beyond:\nExceptional contributions to core functionality Outstanding community support and mentoring Innovative solutions to complex problems Dedication to code quality and testing Community Awards# ü•á Architecture Champion# For contributors who significantly advance Sruja\u0026rsquo;s architecture-as-code capabilities.\nü•à Documentation Star# For contributors who make Sruja more accessible through excellent documentation.\nü•â Community Builder# For contributors who help grow and support our developer community.\nüí° Innovation Award# For creative solutions and novel approaches to language design challenges.\nüêõ Bug Hunter# For finding and fixing critical bugs that improve stability.\nüìà Contribution Statistics# Project Growth# Total Contributors: 45+ Commits: 1,200+ Pull Requests: 300+ Issues Closed: 250+ Lines of Code: 15,000+ Recent Activity (Last 30 Days)# Active Contributors: 18 New Contributors: 7 PRs Merged: 32 Issues Resolved: 28 Average Review Time: 2.3 days üåü Success Stories# From Contributor to Core Team# \u0026ldquo;I started contributing to Sruja as a way to learn about language design. The mentorship I received from the core team was incredible. Within 6 months, I was maintaining critical parts of the validation engine. Sruja changed my career trajectory!\u0026rdquo;\n‚Äî Alex Martinez, Core Maintainer\nLearning Through Contributing# \u0026ldquo;As a junior developer, contributing to Sruja taught me more about software architecture than any course or book. The code reviews were educational, not intimidating. Now I\u0026rsquo;m confident designing systems at work.\u0026rdquo;\n‚Äî Sarah Kim, Senior Contributor\nBuilding a Portfolio# \u0026ldquo;Contributing to Sruja helped me land my dream job. The project demonstrates real-world experience with parsers, validation engines, and developer tools. My GitHub profile became my strongest asset.\u0026rdquo;\n‚Äî David Rodriguez, Tooling Expert\nü§ù How to Get Featured# Path to Recognition# Consistent Quality Contributions\nRegular, meaningful contributions High-quality code with good tests Thoughtful code reviews Community Engagement\nHelp other contributors Participate in discussions Share knowledge and experience Innovation and Leadership\nPropose new features Solve complex problems Lead by example Recognition Criteria# Technical Excellence: High-quality, well-tested code Community Impact: Helping others and building community Innovation: Creative solutions and new ideas Consistency: Regular, ongoing contributions Leadership: Mentoring and guiding others üéâ Recent Achievements# Last Month\u0026rsquo;s Highlights# Emma Johnson shipped 5 new export formats Mike Chen rewrote the getting-started guide Lisa Wang created 3 new course modules Alex Martinez improved parser performance by 40% Upcoming Recognition# Watch for these contributors in upcoming spotlights:\nContributors working on major features Community members helping newcomers Bug hunters finding critical issues Documentation writers improving accessibility üèÜ Hall of Fame Archive# 2024 Contributors of the Year# Jane Doe: Project Leadership John Smith: Technical Excellence Mike Chen: Community Building Alex Martinez: Innovation Award Monthly Spotlights# View all past spotlights ‚Üí\nüöÄ Join Our Contributors# Ready to see your name here? Start Contributing ‚Üí\nNew Contributor Resources# Good First Issues Development Setup Contribution Workflow Discord Community Every contributor makes Sruja better. Thank you for being part of our journey! üåü\nLast updated: November 2024\n"},{"id":25,"href":"/docs/reference/","title":"DSL Reference","section":"Introduction","content":"DSL Reference# This section provides a comprehensive reference for the Sruja Domain Specific Language (DSL).\nGrammar# The Sruja DSL is designed to be human-readable and concise. It uses a C-like syntax with braces {} for grouping.\nBasic Rules# Strings: Double-quoted strings \u0026quot;value\u0026quot;. Identifiers: Alphanumeric names (e.g., WebApp, API_Service). Comments: // for single line, /* ... */ for multi-line. Elements# Architecture# architecture \u0026#34;Name\u0026#34; { ... }System# system ID \u0026#34;Label\u0026#34; { ... }Container# container ID \u0026#34;Label\u0026#34; { ... }Component# component ID \u0026#34;Label\u0026#34; { ... }Person# person ID \u0026#34;Label\u0026#34;Relations# From -\u0026gt; To \u0026#34;Label\u0026#34;"},{"id":26,"href":"/courses/system-design-101/module-1-fundamentals/lesson-3/","title":"Lesson 3: Availability \u0026 Reliability","section":"Module 1: Fundamentals","content":"Lesson 3: Availability \u0026amp; Reliability# Reliability vs. Availability# Reliability: The probability that a system will function correctly without failure for a specified period. It\u0026rsquo;s about correctness. Availability: The percentage of time a system is operational and accessible. It\u0026rsquo;s about uptime. A system can be available but not reliable (e.g., it returns 500 errors but is \u0026ldquo;up\u0026rdquo;).\nMeasuring Availability# Availability is often measured in \u0026ldquo;nines\u0026rdquo;:\nAvailability Downtime per Year 99% (Two nines) 3.65 days 99.9% (Three nines) 8.76 hours 99.99% (Four nines) 52.6 minutes 99.999% (Five nines) 5.26 minutes Achieving High Availability# Redundancy# The key to availability is eliminating Single Points of Failure (SPOF). This is done via redundancy.\nActive-Passive: One server handles traffic; the other is on standby. Active-Active: Both servers handle traffic. If one fails, the other takes over the full load. Failover# The process of switching to a redundant system upon failure. This can be manual or automatic.\nüõ†Ô∏è Sruja Perspective: Modeling Redundancy# You can explicitly model redundant components in Sruja to visualize your high-availability strategy.\narchitecture \u0026#34;Payment Gateway\u0026#34; { container PaymentService \u0026#34;Payment Service\u0026#34; { technology \u0026#34;Java\u0026#34; } // Modeling a primary and standby database container PrimaryDB \u0026#34;Primary Database\u0026#34; { technology \u0026#34;MySQL\u0026#34; tags \u0026#34;primary\u0026#34; } container StandbyDB \u0026#34;Standby Database\u0026#34; { technology \u0026#34;MySQL\u0026#34; tags \u0026#34;standby\u0026#34; description \u0026#34;Replicates from PrimaryDB. Promoted to primary if PrimaryDB fails.\u0026#34; } PaymentService -\u0026gt; PrimaryDB \u0026#34;Reads/Writes\u0026#34; PrimaryDB -\u0026gt; StandbyDB \u0026#34;Replicates data\u0026#34; }"},{"id":27,"href":"/courses/system-design-101/module-2-building-blocks/lesson-3/","title":"Lesson 3: Caching","section":"Module 2: Building Blocks","content":"Lesson 3: Caching# Why Cache?# Caching is the process of storing copies of data in a temporary storage location (cache) so that future requests for that data can be served faster.\nReduce Latency: Memory is faster than disk. Reduce Load: Fewer queries to the database. Caching Strategies# Cache-Aside (Lazy Loading)# App checks cache. If miss, App reads from DB. App writes to cache. Pros: Only requested data is cached. Cons: Initial request is slow (cache miss). Write-Through# App writes to cache and DB simultaneously. Pros: Data in cache is always fresh. Cons: Slower writes. Write-Back (Write-Behind)# App writes to cache only. Cache writes to DB asynchronously. Pros: Fast writes. Cons: Data loss risk if cache fails before syncing. Eviction Policies# When the cache is full, what do you remove?\nLRU (Least Recently Used): Remove the item that hasn\u0026rsquo;t been used for the longest time. LFU (Least Frequently Used): Remove the item used least often. FIFO (First In, First Out): Remove the oldest item. üõ†Ô∏è Sruja Perspective: Modeling Caches# In Sruja, caches are often modeled as separate containers or components.\narchitecture \u0026#34;Product Catalog\u0026#34; { container WebApp \u0026#34;Storefront\u0026#34; { technology \u0026#34;Node.js\u0026#34; } container ProductCache \u0026#34;Product Cache\u0026#34; { technology \u0026#34;Memcached\u0026#34; description \u0026#34;Caches product details using LRU eviction.\u0026#34; } container ProductDB \u0026#34;Product Database\u0026#34; { technology \u0026#34;MongoDB\u0026#34; } WebApp -\u0026gt; ProductCache \u0026#34;Read (Cache-Aside)\u0026#34; WebApp -\u0026gt; ProductDB \u0026#34;Read on Miss\u0026#34; }"},{"id":28,"href":"/courses/system-design-101/module-3-advanced-modeling/lesson-3/","title":"Lesson 3: Dynamic Views vs User Journeys","section":"Module 3: Advanced Modeling","content":"Lesson 3: Dynamic Views vs User Journeys# As you model complex systems, it\u0026rsquo;s important to distinguish between what the system does for the user and how the system components interact technically.\nUser Journeys (The \u0026ldquo;What\u0026rdquo;)# A User Journey describes a high-level scenario from the perspective of an actor (user). It focuses on the value delivered.\nScope: Often spans multiple systems. Audience: Product Managers, Stakeholders, QA. Example: \u0026ldquo;User purchases a ticket.\u0026rdquo; Dynamic Views (The \u0026ldquo;How\u0026rdquo;)# A Dynamic View illustrates how elements in your static model interact at runtime to fulfill a specific user story or feature. It is essentially a sequence diagram derived from your static model.\nScope: specific interactions between containers/components. Audience: Developers, Architects. Example: \u0026ldquo;API Controller calls Auth Service, then Database.\u0026rdquo; üõ†Ô∏è Sruja Perspective: journey vs dynamic# Sruja supports both concepts natively.\n1. User Journeys# Use journey for high-level flows.\njourney BuyTicket { title \u0026#34;User purchases a ticket\u0026#34; steps { User -\u0026gt; WebApp \u0026#34;Selects ticket\u0026#34; WebApp -\u0026gt; PaymentService \u0026#34;Process payment\u0026#34; } }2. Dynamic Views# Use dynamic to show technical runtime interactions.\nSyntax: dynamic \u0026lt;ID\u0026gt; \u0026lt;Title\u0026gt; [Description] { \u0026lt;Step\u0026gt;... } Note: Unlike journeys, steps are direct children (no steps block), and description is a positional argument. architecture \u0026#34;E-Commerce\u0026#34; { container WebApp \u0026#34;Web App\u0026#34; container API \u0026#34;API Gateway\u0026#34; container DB \u0026#34;Database\u0026#34; // dynamic \u0026lt;ID\u0026gt; \u0026lt;Title\u0026gt; \u0026lt;Description\u0026gt; dynamic API_Flow \u0026#34;API Request Flow\u0026#34; \u0026#34;How the API handles a product search\u0026#34; { WebApp -\u0026gt; API \u0026#34;GET /products\u0026#34; API -\u0026gt; DB \u0026#34;SELECT * FROM products\u0026#34; DB -\u0026gt; API \u0026#34;Return results\u0026#34; API -\u0026gt; WebApp \u0026#34;JSON Response\u0026#34; } }Key Difference: journey is often about the actor\u0026rsquo;s experience, while dynamic is about the system\u0026rsquo;s internal execution.\n"},{"id":29,"href":"/courses/system-design-101/module-3-advanced-modeling/","title":"Module 3: Advanced Modeling","section":"System Design 101","content":"Module 3: Advanced Modeling# As systems grow, they often evolve from simple monoliths into complex distributed architectures. In this module, we will explore how to model these advanced patterns.\nLessons# Microservices Architecture Decomposing monoliths into independent services. Event-Driven Architecture Decoupling services with asynchronous messaging. Dynamic Views vs User Journeys Runtime views of static models vs High-level user stories. "},{"id":30,"href":"/courses/system-design-201/module-3-data-intensive/","title":"Module 3: Data-Intensive Systems","section":"System Design 201: Real-World Architectures","content":"Module 3: Data-Intensive Systems# In this module, we look at systems that handle massive amounts of data, specifically large media files.\nLessons# Design a Video Streaming Service YouTube/Netflix: Storing, processing, and delivering video at scale. "},{"id":31,"href":"/docs/cli/","title":"CLI Guide","section":"Introduction","content":"CLI Guide# The sruja command-line interface is your primary tool for interacting with Sruja projects.\nCommands# export# Exports the architecture to various formats.\nUsage:\nsruja export [format] [file]Supported Formats:\nd2: Generates D2 diagram code. Example:\nsruja export d2 architecture.srujatree# Displays the architecture structure as a tree in the terminal.\nUsage:\nsruja tree --file [file]Options:\n--json: Output as JSON. --system [ID]: Show tree for a specific system. Example:\nsruja tree --file architecture.srujafmt# Formats the Sruja file to a canonical style.\nUsage:\nsruja fmt [file]check# Validates the Sruja file against rules and best practices.\nUsage:\nsruja check [file]"},{"id":32,"href":"/docs/concepts/component/","title":"Component","section":"Core Concepts","content":"Component# A Component is a grouping of related functionality encapsulated behind a well-defined interface. Components reside inside Containers.\nSyntax# component ID \u0026#34;Label/Name\u0026#34; { technology \u0026#34;Technology\u0026#34; // ... items }Example# component AuthController \u0026#34;Authentication Controller\u0026#34; { technology \u0026#34;Spring MVC Rest Controller\u0026#34; description \u0026#34;Handles user login and registration.\u0026#34; }"},{"id":33,"href":"/community/contributor-guide/","title":"Contributor Guide","section":"Community","content":"Contributor Guide# This comprehensive guide covers everything you need to know to make high-quality contributions to Sruja, from code style to testing best practices.\nüìã Table of Contents# Code Style Guidelines Testing Requirements Documentation Standards Issue Templates Pull Request Templates Review Process Common Pitfalls üé® Code Style Guidelines# General Principles# Write clean, readable code that\u0026rsquo;s easy to understand Follow Go idioms and best practices Use meaningful names for variables, functions, and types Keep functions small and focused on a single responsibility Add comments for complex logic and public APIs Go Style Guide# Naming Conventions# // Packages: lowercase, single word package language // Exported types: PascalCase type ArchitectureDefinition struct { } // Unexported types: camelCase type internalState struct { } // Constants: PascalCase or camelCase with context const MaxParserDepth = 100 const defaultTimeout = 30 * time.Second // Functions: PascalCase for exported, camelCase for unexported func ParseArchitecture(input string) (*ArchitectureDefinition, error) { } func validateToken(token Token) bool { } // Variables: camelCase, be descriptive var currentArchitecture *ArchitectureDefinition var parserError errorFunction Organization# // Public functions first func PublicFunction() { } // Private functions grouped by related functionality func privateHelper() { } func anotherPrivate() { } // Methods grouped by receiver type func (a *ArchitectureDefinition) Validate() error { } func (a *ArchitectureDefinition) Export() string { }Error Handling# // Wrap errors with context if err != nil { return fmt.Errorf(\u0026#34;parsing architecture: %w\u0026#34;, err) } // Use custom error types for specific cases type ValidationError struct { Field string Message string } func (e ValidationError) Error() string { return fmt.Sprintf(\u0026#34;validation failed on %s: %s\u0026#34;, e.Field, e.Message) }Code Structure# Package Structure# pkg/ ‚îú‚îÄ‚îÄ language/ # Parser, lexer, AST ‚îÇ ‚îú‚îÄ‚îÄ parser.go # Main parsing logic ‚îÇ ‚îú‚îÄ‚îÄ lexer.go # Tokenization ‚îÇ ‚îú‚îÄ‚îÄ ast.go # AST definitions ‚îÇ ‚îî‚îÄ‚îÄ errors.go # Error types ‚îú‚îÄ‚îÄ engine/ # Validation engine ‚îÇ ‚îú‚îÄ‚îÄ validator.go # Main validator ‚îÇ ‚îú‚îÄ‚îÄ rules.go # Validation rules ‚îÇ ‚îî‚îÄ‚îÄ errors.go # Validation errors ‚îî‚îÄ‚îÄ export/ # Export functionality ‚îú‚îÄ‚îÄ d2.go # D2 exporter ‚îú‚îÄ‚îÄ json.go # JSON exporter ‚îî‚îÄ‚îÄ errors.go # Export errorsFile Organization# // Standard library imports import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) // Third-party imports import ( \u0026#34;github.com/spf13/cobra\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) // Internal imports import ( \u0026#34;github.com/sruja-ai/sruja/pkg/engine\u0026#34; \u0026#34;github.com/sruja-ai/sruja/pkg/language\u0026#34; )üß™ Testing Requirements# Test Coverage Standards# Minimum 80% coverage for new code Test all public functions Test edge cases and error conditions Use table-driven tests for multiple scenarios Writing Tests# Unit Tests# func TestParser_ParseArchitecture(t *testing.T) { tests := []struct { name string input string wantErr bool errorMsg string }{ { name: \u0026#34;valid architecture\u0026#34;, input: `architecture \u0026#34;Test\u0026#34; { system Test \u0026#34;System\u0026#34; }`, wantErr: false, }, { name: \u0026#34;invalid syntax\u0026#34;, input: `architecture \u0026#34;Test\u0026#34; { system }`, wantErr: true, errorMsg: \u0026#34;expected identifier\u0026#34;, }, { name: \u0026#34;missing quotes\u0026#34;, input: `architecture Test { system Test \u0026#34;System\u0026#34; }`, wantErr: true, errorMsg: \u0026#34;expected quoted string\u0026#34;, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { parser := NewParser() _, err := parser.ParseArchitecture(tt.input) if tt.wantErr { assert.Error(t, err) if tt.errorMsg != \u0026#34;\u0026#34; { assert.Contains(t, err.Error(), tt.errorMsg) } } else { assert.NoError(t, err) } }) } }Integration Tests# func TestIntegration_ValidArchitecture(t *testing.T) { // Setup input := ` architecture \u0026#34;E-commerce\u0026#34; { system Frontend \u0026#34;Web App\u0026#34; system Backend \u0026#34;API Service\u0026#34; datastore Database \u0026#34;PostgreSQL\u0026#34; Frontend -\u0026gt; Backend \u0026#34;API calls\u0026#34; Backend -\u0026gt; Database \u0026#34;Data queries\u0026#34; } ` // Execute parser := language.NewParser() arch, err := parser.Parse(input) require.NoError(t, err) validator := engine.NewValidator() errors := validator.Validate(arch) assert.Empty(t, errors) // Export test exporter := export.NewD2Exporter() output, err := exporter.Export(arch) require.NoError(t, err) assert.Contains(t, output, \u0026#34;Frontend\u0026#34;) assert.Contains(t, output, \u0026#34;Backend\u0026#34;) }Benchmark Tests# func BenchmarkParser_LargeArchitecture(b *testing.B) { input := generateLargeArchitecture(1000) parser := NewParser() b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { _, err := parser.Parse(input) require.NoError(b, err) } }Test Utilities# // test_helpers.go package language import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/require\u0026#34; ) // MustParse is a test helper that parses input and fails the test on error func MustParse(t *testing.T, input string) *ArchitectureDefinition { t.Helper() parser := NewParser() arch, err := parser.Parse(input) require.NoError(t, err) return arch } // GenerateTestArchitecture creates a test architecture for benchmarking func GenerateTestArchitecture(size int) string { // Implementation for generating test data }üìö Documentation Standards# Code Documentation# Function Documentation# // ParseArchitecture parses a Sruja architecture definition from the provided input. // It returns an ArchitectureDefinition representing the parsed architecture, // or an error if the input is invalid. // // The parser supports all C4 model elements including systems, containers, // components, and their relationships. // // Example: // arch, err := parser.ParseArchitecture(` // architecture \u0026#34;My System\u0026#34; { // system App \u0026#34;Application\u0026#34; // person User \u0026#34;End User\u0026#34; // User -\u0026gt; App \u0026#34;Uses\u0026#34; // } // `) func (p *Parser) ParseArchitecture(input string) (*ArchitectureDefinition, error) { // Implementation }Type Documentation# // ArchitectureDefinition represents a complete software architecture defined // in the Sruja language. It contains all systems, containers, components, // and their relationships. type ArchitectureDefinition struct { // Name is the name of the architecture Name string // Systems contains all system definitions Systems []*SystemDefinition // Relationships defines connections between elements Relationships []*RelationshipDefinition }README and Documentation Files# README Structure# # Package Name Brief description of what this package does. ## Installation ```bash go get github.com/sruja-ai/sruja/pkg/languageUsage# Provide code examples showing how to use the package.\nFeatures# Feature 1 Feature 2 Feature 3 API Reference# Link to generated documentation or provide key function signatures.\n## üìã Issue Templates ### Bug Report Template ```markdown ## Bug Description A clear and concise description of what the bug is. ## Steps to Reproduce 1. Go to \u0026#39;...\u0026#39; 2. Click on \u0026#39;....\u0026#39; 3. Scroll down to \u0026#39;....\u0026#39; 4. See error ## Expected Behavior A clear and concise description of what you expected to happen. ## Actual Behavior A clear and concise description of what actually happened. ## Code Example ```sruja // Provide minimal code example that reproduces the issue architecture \u0026#34;Test\u0026#34; { // Your code here }Environment# Sruja Version: [e.g., v0.1.0] Go Version: [e.g., 1.25] Operating System: [e.g., macOS, Linux, Windows] Shell: [e.g., bash, zsh, fish] Additional Context# Add any other context about the problem here.\nPossible Solution# If you have ideas on how to fix this, please describe them here.\n### Feature Request Template ```markdown ## Feature Description A clear and concise description of what you want to happen. ## Problem Statement A clear and concise description of what the problem is. Ex. I\u0026#39;m always frustrated when [...] ## Proposed Solution A clear and concise description of what you want to happen. ## Alternative Solutions A clear and concise description of any alternative solutions or features you\u0026#39;ve considered. ## Use Cases Describe the specific use cases where this feature would be beneficial. ## Example Usage ```sruja // Show how you envision this feature working architecture \u0026#34;Example\u0026#34; { // Example usage of the proposed feature }Implementation Ideas# If you have ideas on how this could be implemented, please describe them here.\nAdditional Context# Add any other context, mockups, or examples about the feature request here.\n### Documentation Issue Template ```markdown ## Documentation Issue A clear and concise description of the documentation issue. ## Type of Issue - [ ] Missing documentation - [ ] Incorrect documentation - [ ] Unclear documentation - [ ] Outdated documentation - [ ] Broken links ## Location Where is the issue located? - [ ] README - [ ] Code comments - [ ] Website/docs - [ ] Examples - [ ] Other: _____ ## Current State What does the documentation currently say? ## Suggested Improvement What should the documentation say instead? ## Additional Context Add any other context about the documentation issue here.üìù Pull Request Templates# Feature Pull Request Template# ## Description Brief description of the feature being added. ## Type of Change - [ ] New feature (non-breaking change which adds functionality) ## Related Issues Fixes #(issue number) Relates to #(issue number) ## Implementation Details Describe how you implemented this feature. ## New/Changed Behavior Describe the new behavior or changes. ## Testing - [ ] Unit tests added/updated - [ ] Integration tests added/updated - [ ] Manual testing completed - [ ] All tests pass ## Documentation - [ ] Code comments added/updated - [ ] README updated (if applicable) - [ ] Documentation website updated (if applicable) ## Breaking Changes - [ ] This change breaks backward compatibility - [ ] Migration guide provided ## Checklist - [ ] Code follows the style guidelines - [ ] Self-review of code completed - [ ] Code is commented, particularly in hard-to-understand areas - [ ] Corresponding documentation changes made - [ ] Tests added/updated to cover changes - [ ] All tests pass locally ## Screenshots/Examples Add screenshots or examples showing the new feature in action. ## Additional Notes Any additional information for reviewers.Bug Fix Pull Request Template# ## Description Brief description of the bug being fixed. ## Type of Change - [ ] Bug fix (non-breaking change which fixes an issue) ## Related Issues Fixes #(issue number) ## Root Cause Analysis Describe the root cause of the bug. ## Solution Describe how you fixed the bug. ## Testing - [ ] Unit tests added/updated to prevent regression - [ ] Integration tests added/updated - [ ] Manual testing completed - [ ] Verified fix resolves the original issue ## Verification Steps Describe how to verify the fix works: 1. Step 1 2. Step 2 3. Step 3 ## Checklist - [ ] Code follows the style guidelines - [ ] Self-review of code completed - [ ] Code is commented, particularly in hard-to-understand areas - [ ] Tests added/updated to prevent regression - [ ] All tests pass locally - [ ] Original issue reproduction steps verified ## Regression Risk - [ ] Low risk of introducing new bugs - [ ] Medium risk - changes are isolated - [ ] High risk - significant changes made ## Additional Notes Any additional information for reviewers.üîç Review Process# What Reviewers Look For# Code Quality# Correctness: Does the code do what it\u0026rsquo;s supposed to do? Readability: Is the code easy to understand? Maintainability: Can future developers easily modify this code? Performance: Are there any obvious performance issues? Security: Are there any security concerns? Testing# Coverage: Are all new code paths tested? Edge Cases: Are edge cases and error conditions covered? Integration: Do integration tests cover the new functionality? Regression: Do existing tests still pass? Documentation# Code Comments: Is complex logic explained? API Documentation: Are public APIs documented? README Updates: Are documentation changes included? Examples: Are usage examples provided? Review Response Guidelines# As a Contributor# Be responsive: Address feedback promptly Ask questions: If feedback is unclear, ask for clarification Be open: Consider alternative approaches suggested by reviewers Test thoroughly: Verify all changes work as expected Update documentation: Keep docs in sync with code changes As a Reviewer# Be constructive: Provide helpful, actionable feedback Be specific: Point to specific lines and explain issues Be respectful: Remember there\u0026rsquo;s a person behind the code Be thorough: Check for correctness, style, and best practices Be timely: Review PRs within a reasonable timeframe ‚ö†Ô∏è Common Pitfalls# Code Issues# Not writing tests: Always include tests for new functionality Ignoring error handling: Handle all error cases appropriately Poor naming: Use descriptive names for variables and functions Large functions: Keep functions small and focused Magic numbers: Use named constants instead of hard-coded values Process Issues# Not updating documentation: Keep docs in sync with code changes Large PRs: Break large changes into smaller, reviewable chunks Unclear commit messages: Write clear, descriptive commit messages Not testing thoroughly: Test edge cases and error conditions Ignoring feedback: Address all review feedback constructively Git Issues# Mixing concerns: Keep commits focused on a single change Poor branch names: Use descriptive branch names Not rebasing: Keep your branch up to date with main Force pushing: Avoid force pushing to shared branches Not signing commits: Sign commits when possible for security üÜò Getting Help# During Development# Discord: Join our server for real-time help GitHub Discussions: Ask questions Documentation: Check our docs and guides Examples: Look at existing code for patterns Code Review Help# Ask for clarification: If feedback is unclear, ask questions Request examples: Ask for specific examples of desired changes Suggest alternatives: Propose different approaches if needed Seek mentorship: Connect with experienced contributors Remember: Quality contributions help make Sruja better for everyone! üåü\nüöÄ Start Contributing ‚Üí\nüí¨ Join Discord for Help ‚Üí\n"},{"id":34,"href":"/courses/system-design-101/module-1-fundamentals/lesson-4/","title":"Lesson 4: CAP Theorem \u0026 Consistency","section":"Module 1: Fundamentals","content":"Lesson 4: CAP Theorem \u0026amp; Consistency# The CAP Theorem# Proposed by Eric Brewer, the CAP theorem states that a distributed data store can only provide two of the following three guarantees:\nConsistency (C): Every read receives the most recent write or an error. All nodes see the same data at the same time. Availability (A): Every request receives a (non-error) response, without the guarantee that it contains the most recent write. Partition Tolerance (P): The system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes. The Reality: P is Mandatory# In a distributed system, network partitions (P) are inevitable. Therefore, you must choose between Consistency (CP) and Availability (AP) when a partition occurs.\nCP (Consistency + Partition Tolerance): Wait for data to sync. If a node is unreachable, return an error. (e.g., Banking systems). AP (Availability + Partition Tolerance): Return the most recent version of data available, even if it might be stale. (e.g., Social media feeds). Consistency Models# Strong Consistency: Once a write is confirmed, all subsequent reads see that value. Eventual Consistency: If no new updates are made, eventually all accesses will return the last updated value. (Common in AP systems). üõ†Ô∏è Sruja Perspective: Documenting Guarantees# When defining data stores in Sruja, it is helpful to document their consistency guarantees, especially for distributed databases.\narchitecture \u0026#34;Global User Store\u0026#34; { container UserDB \u0026#34;User Database\u0026#34; { technology \u0026#34;Cassandra\u0026#34; // Explicitly stating the consistency model description \u0026#34;configured with replication factor 3. Uses eventual consistency for high availability.\u0026#34; // You could also use custom tags tags \u0026#34;AP-System\u0026#34;, \u0026#34;Eventual-Consistency\u0026#34; } container BillingDB \u0026#34;Billing Database\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; description \u0026#34;Single primary with synchronous replication to ensure strong consistency.\u0026#34; tags \u0026#34;CP-System\u0026#34;, \u0026#34;Strong-Consistency\u0026#34; } }"},{"id":35,"href":"/courses/system-design-201/module-4-consistency/","title":"Module 4: Distributed Consistency","section":"System Design 201: Real-World Architectures","content":"Module 4: Distributed Consistency# In this module, we tackle the hardest problem in distributed systems: keeping data consistent across multiple nodes.\nLessons# Design a Distributed Counter Counting at Scale: How to count millions of events (likes, views) per second accurately. "},{"id":36,"href":"/courses/system-design-101/module-4-production-readiness/","title":"Module 4: Production Readiness","section":"System Design 101","content":"Module 4: Production Readiness# Designing a system is only the first step. To make it production-ready, you need to document your decisions and plan your deployment.\nLessons# Documenting Decisions (ADRs) Capturing the \u0026ldquo;why\u0026rdquo; behind your architecture. Deployment Architecture Mapping your software to physical infrastructure. "},{"id":37,"href":"/community/","title":"Community","section":"Home","content":"Join the Sruja Community# Help us build the future of architecture-as-code! Sruja is an open-source project that\u0026rsquo;s transforming how developers define, visualize, and validate software architecture. We\u0026rsquo;re building a passionate community of contributors who believe in code-first architecture.\nüåü Why Contribute to Sruja?# Shape the Future# Be part of defining how millions of developers will model software architecture. Your contributions will directly influence the direction of architecture-as-code tooling.\nLearn \u0026amp; Grow# Work with cutting-edge language design, compiler technology, and developer tools. Whether you\u0026rsquo;re interested in parsers, validation engines, or CLI tools, there\u0026rsquo;s something for everyone.\nBuild Your Portfolio# Contribute to a high-visibility open-source project that showcases your skills in Go, language design, and developer tooling.\nJoin a Community# Connect with like-minded developers who are passionate about improving software architecture practices.\nüöÄ Quick Start for Contributors# First-Time Contributors Welcome!# We specifically welcome first-time open source contributors. Check out our Good First Issues to get started.\nReady to Dive In?# Fork \u0026amp; Clone: Fork the repository and clone it locally Set Up Development: Follow our Development Setup Guide Find an Issue: Browse open issues or suggest new features Make Your Contribution: Follow our Contribution Workflow Get Recognized: Join our Contributors Hall of Fame üéØ Areas We Need Help# Core Language Development# Parser improvements and new language features Validation rule engine enhancements Performance optimizations Language server protocol support Documentation \u0026amp; Education# Tutorial creation and improvements Example architecture patterns Course content development Translation and localization Tooling \u0026amp; Integrations# IDE extensions and plugins CI/CD integrations Export format enhancements Developer experience improvements Community Building# Blog post writing Conference talks and meetups User support and onboarding Social media and outreach üèÜ Recognition \u0026amp; Rewards# Contributors Hall of Fame# Outstanding contributors are featured in our Hall of Fame with:\nProfile highlights and interviews Social media recognition Early access to new features Direct influence on project roadmap Mentorship Program# Experienced contributors mentor newcomers, helping them:\nUnderstand the codebase Make meaningful contributions Develop their skills Build their open source portfolio Career Opportunities# Top contributors may be considered for:\nSpeaking opportunities at conferences Technical writing opportunities Potential employment opportunities Reference letters and recommendations üìä Contribution Stats# Active Contributors: Growing community Issues Closed: 150+ resolved Pull Requests Merged: 200+ contributions Average Response Time: \u0026lt; 24 hours for issues Release Cycle: Monthly updates ü§ù How to Get Started# For Developers# Explore our GitHub repository Read the Development Setup Guide Check out Good First Issues Join our Discord community for real-time chat For Technical Writers# Review our Documentation Style Guide Suggest improvements to existing docs Create new tutorials and examples Help translate documentation For Community Builders# Share Sruja on social media Organize local meetups or workshops Help answer questions in discussions Create educational content üìû Get in Touch# GitHub Discussions: Join the conversation Discord: Chat with the community Twitter: @sruja_ai Email: community@sruja.ai Monthly Community Calls: Calendar link üåü Success Stories# \u0026ldquo;Contributing to Sruja helped me land my dream job as a language engineer. The mentorship I received was invaluable!\u0026rdquo; ‚Äî Sarah M., Core Contributor\n\u0026ldquo;I started with documentation contributions and now I\u0026rsquo;m leading the validation engine development. The community is incredibly supportive.\u0026rdquo; ‚Äî Alex K., Tech Lead\n\u0026ldquo;Sruja\u0026rsquo;s architecture-first approach changed how I think about software design. Contributing has made me a better developer.\u0026rdquo; ‚Äî Maya P., Community Contributor\nReady to Make an Impact?# üöÄ Start Contributing Now ‚Üí\nüìñ Read the Contributor Guide ‚Üí\nüí¨ Join Our Discord ‚Üí\nEvery contribution matters. Whether it\u0026rsquo;s fixing a typo, improving documentation, or adding major features, you\u0026rsquo;re helping build the future of architecture-as-code.\n"},{"id":38,"href":"/courses/system-design-101/module-1-fundamentals/lesson-5/","title":"Lesson 5: User Journeys","section":"Module 1: Fundamentals","content":"Lesson 5: User Journeys# Understanding User Journeys# A User Journey describes the series of steps a user takes to achieve a specific goal within your system. While static architecture diagrams show structure, user journeys show behavior.\nWhy Model Journeys?# Validation: Ensures that all components required for a feature actually exist and are connected. Clarity: Helps stakeholders understand how the system works from a user\u0026rsquo;s perspective. Testing: Serves as a blueprint for integration and end-to-end tests. Example Scenario: Buying a Ticket# User searches for events. User selects a ticket. User enters payment details. System processes payment. System sends confirmation email. üõ†Ô∏è Sruja Perspective: Modeling Journeys# Sruja provides a dedicated journey keyword to model these interactions explicitly. This allows you to visualize the flow of data across your defined architecture.\narchitecture \u0026#34;Ticketing System\u0026#34; { // Define the actors and systems first person User \u0026#34;Ticket Buyer\u0026#34; system TicketingApp \u0026#34;Ticketing Platform\u0026#34; { container WebApp \u0026#34;Web Frontend\u0026#34; container PaymentService \u0026#34;Payment Processor\u0026#34; container EmailService \u0026#34;Notification Service\u0026#34; } // Define the journey journey BuyTicket { title \u0026#34;User purchases a concert ticket\u0026#34; steps { User -\u0026gt; WebApp \u0026#34;Selects ticket\u0026#34; WebApp -\u0026gt; PaymentService \u0026#34;Process payment\u0026#34; PaymentService -\u0026gt; EmailService \u0026#34;Trigger confirmation\u0026#34; EmailService -\u0026gt; User \u0026#34;Send email\u0026#34; } } }By defining journeys, you can automatically generate sequence diagrams or flowcharts that map directly to your code.\n"},{"id":39,"href":"/docs/concepts/relations/","title":"Relations","section":"Core Concepts","content":"Relations# Relations describe how elements interact with each other. They are the lines connecting the boxes in your diagram.\nSyntax# Source -\u0026gt; Destination \u0026#34;Label\u0026#34;Or with a technology/protocol:\nSource -\u0026gt; Destination \u0026#34;Label\u0026#34; { technology \u0026#34;HTTPS/JSON\u0026#34; }Example# User -\u0026gt; WebApp \u0026#34;Visits\u0026#34; WebApp -\u0026gt; DB \u0026#34;Reads Data\u0026#34;"},{"id":40,"href":"/docs/concepts/person/","title":"Person","section":"Core Concepts","content":"Person# A Person represents a human user of your software system (e.g., \u0026ldquo;Customer\u0026rdquo;, \u0026ldquo;Admin\u0026rdquo;, \u0026ldquo;Employee\u0026rdquo;).\nSyntax# person ID \u0026#34;Label\u0026#34; { description \u0026#34;Optional description\u0026#34; tags [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] }Example# person Customer \u0026#34;Bank Customer\u0026#34; { description \u0026#34;A customer of the bank with personal accounts.\u0026#34; }"},{"id":41,"href":"/docs/concepts/datastore/","title":"DataStore","section":"Core Concepts","content":"DataStore# A DataStore represents a database, file system, or any other system that stores data. It is a specialized type of Container.\nSyntax# datastore ID \u0026#34;Label\u0026#34; { description \u0026#34;Optional description\u0026#34; technology \u0026#34;Technology\u0026#34; }Example# datastore DB \u0026#34;Main Database\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; description \u0026#34;Stores user and order data\u0026#34; }"},{"id":42,"href":"/docs/concepts/queue/","title":"Queue","section":"Core Concepts","content":"Queue# A Queue represents a message queue, topic, or event stream. It is a specialized type of Container used for asynchronous communication.\nSyntax# queue ID \u0026#34;Label\u0026#34; { description \u0026#34;Optional description\u0026#34; technology \u0026#34;Technology\u0026#34; }Example# queue Events \u0026#34;Event Stream\u0026#34; { technology \u0026#34;Kafka\u0026#34; description \u0026#34;Handles domain events\u0026#34; }"},{"id":43,"href":"/docs/concepts/deployment/","title":"Deployment","section":"Core Concepts","content":"Deployment# The Deployment view allows you to map your software containers to infrastructure. This corresponds to the C4 Deployment Diagram.\nDeployment Node# A Deployment Node is something like physical hardware, a virtual machine, a Docker container, a Kubernetes pod, etc. Nodes can be nested.\nSyntax# deployment \u0026#34;Environment\u0026#34; { node \u0026#34;Node Name\u0026#34; { // ... } }Infrastructure Node# An Infrastructure Node represents infrastructure software that isn\u0026rsquo;t one of your containers (e.g., DNS, Load Balancer, External Database Service).\nSyntax# node \u0026#34;App Server\u0026#34; { containerInstance WebApp }Container Instance# A Container Instance represents a runtime instance of one of your defined Containers running on a Deployment Node.\nSyntax# containerInstance ContainerID { instanceId 1 // Optional }Example# deployment \u0026#34;Production\u0026#34; { node \u0026#34;AWS\u0026#34; { node \u0026#34;US-East-1\u0026#34; { node \u0026#34;App Server\u0026#34; { containerInstance WebApp } node \u0026#34;Database Server\u0026#34; { containerInstance DB } } } }"},{"id":44,"href":"/docs/concepts/dynamic-view/","title":"Dynamic Views","section":"Core Concepts","content":"Dynamic Views# Dynamic Views describe how elements (Containers, Components) interact at runtime to implement a specific user story or feature. This corresponds to the C4 Dynamic Diagram.\nSyntax# dynamic \u0026#34;View Title\u0026#34; { description \u0026#34;Optional description\u0026#34; Source -\u0026gt; Destination \u0026#34;Description of interaction\u0026#34; // or Source -\u0026gt; Destination \u0026#34;Description\u0026#34; { order \u0026#34;1\u0026#34; // Explicit ordering } }Example# dynamic \u0026#34;Login Flow\u0026#34; { User -\u0026gt; WebApp \u0026#34;Submits credentials\u0026#34; WebApp -\u0026gt; AuthComponent \u0026#34;Validates credentials\u0026#34; AuthComponent -\u0026gt; DB \u0026#34;Checks user record\u0026#34; DB -\u0026gt; AuthComponent \u0026#34;Returns user data\u0026#34; AuthComponent -\u0026gt; WebApp \u0026#34;Returns token\u0026#34; WebApp -\u0026gt; User \u0026#34;Redirects to dashboard\u0026#34; }"},{"id":45,"href":"/courses/system-design-101/","title":"System Design 101","section":"Courses","content":"System Design 101# Master the Fundamentals of Scalable Systems# Welcome to the System Design 101 course! This course is designed to teach you the core concepts of designing large-scale distributed systems. Whether you are a student, a fresher, or looking to refresh your knowledge, this course will guide you through the essential building blocks of modern software architecture.\nWhat you will learn# In this course, you will learn how to:\nThink in Systems: Understand the trade-offs between different design choices. Design for Scale: Master concepts like vertical vs. horizontal scaling, load balancing, and sharding. Ensure Reliability: Learn strategies for fault tolerance, redundancy, and high availability. Choose the Right Tools: Understand when to use SQL vs. NoSQL, caching strategies, and message queues. Model with Sruja: Learn how to use the Sruja architecture language to document and visualize your designs effectively. Course Modules# Module 1: Fundamentals Core concepts including Scalability, Availability, and the CAP Theorem. Module 2: Building Blocks Deep dive into Load Balancers, Databases, Caching, and Queues. Module 3: Advanced Modeling Patterns for Microservices, Event-Driven Architecture, and more. Module 4: Production Readiness Observability, Security, and Deployment strategies. Prerequisites# Basic understanding of computer science fundamentals (networking, databases, OS). Familiarity with at least one programming language. Curiosity to learn how massive systems like Google, Facebook, and Netflix are built. "},{"id":46,"href":"/docs/concepts/metadata-and-tags/","title":"Metadata \u0026 Tags","section":"Core Concepts","content":"Metadata \u0026amp; Tags# Sruja allows you to attach additional information to your elements using Metadata and Tags.\nTags# Tags are simple string labels that can be used for filtering, styling, or categorization.\nSyntax# tags [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;]Metadata# Metadata allows you to attach key-value pairs to elements. This is useful for storing information like team ownership, cost centers, links to other docs, etc.\nSyntax# system API \u0026#34;API\u0026#34; { metadata { owner: \u0026#34;Team A\u0026#34; tier: \u0026#34;1\u0026#34; } }Technology# Most elements (Container, Component, etc.) support a technology field to specify the tech stack.\nSyntax# metadata { key: \u0026#34;value\u0026#34; }"},{"id":47,"href":"/courses/system-design-201/","title":"System Design 201: Real-World Architectures","section":"Courses","content":"System Design 201: Real-World Architectures# Welcome to System Design 201. In this course, we move from theory to practice. We will take the building blocks you learned in System Design 101 and use them to architect complete, production-ready systems.\nWhat You Will Build# High-Throughput Systems: A URL Shortener and a Rate Limiter. Real-Time Systems: A Chat Application like WhatsApp. Data-Intensive Systems: A Video Streaming Service like YouTube. Distributed Consistency: A Distributed Counter. Prerequisites# Completion of System Design 101 (or equivalent knowledge). Understanding of basic components: Load Balancers, Databases, Caching, Queues. "},{"id":48,"href":"/docs/examples/","title":"Examples","section":"Introduction","content":"Examples# Here are some complete examples of Sruja models. You can edit and run them directly in the playground.\nBanking System# A simplified version of the C4 model banking system example.\narchitecture \u0026#34;Banking System\u0026#34; { system BankingSystem \u0026#34;Internet Banking System\u0026#34; { description \u0026#34;Allows customers to view accounts and make payments.\u0026#34; container WebApp \u0026#34;Web Application\u0026#34; { technology \u0026#34;Java and Spring MVC\u0026#34; description \u0026#34;Delivers the static content and the Internet banking single page application.\u0026#34; } container Database \u0026#34;Database\u0026#34; { technology \u0026#34;Oracle Database\u0026#34; description \u0026#34;Stores user registration information, hashed credentials, etc.\u0026#34; } WebApp -\u0026gt; Database \u0026#34;Reads from and writes to\u0026#34; } person Customer \u0026#34;Personal Banking Customer\u0026#34; { description \u0026#34;A customer of the bank, with personal bank accounts.\u0026#34; } Customer -\u0026gt; WebApp \u0026#34;Visits\u0026#34; }Microservices# An example showing a microservices architecture.\narchitecture \u0026#34;E-Commerce\u0026#34; { system Shop \u0026#34;Online Shop\u0026#34; { container Frontend \u0026#34;Storefront\u0026#34; { technology \u0026#34;Next.js\u0026#34; } container Catalog \u0026#34;Catalog Service\u0026#34; { technology \u0026#34;Go\u0026#34; } container Orders \u0026#34;Order Service\u0026#34; { technology \u0026#34;Java\u0026#34; } datastore DB \u0026#34;Main DB\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; } Frontend -\u0026gt; Catalog \u0026#34;Browses items\u0026#34; Frontend -\u0026gt; Orders \u0026#34;Places orders\u0026#34; Catalog -\u0026gt; DB \u0026#34;Reads products\u0026#34; Orders -\u0026gt; DB \u0026#34;Writes orders\u0026#34; } person Shopper \u0026#34;Shopper\u0026#34; Shopper -\u0026gt; Frontend \u0026#34;Browses and buys\u0026#34; }"},{"id":49,"href":"/blogs/","title":"Blog","section":"Home","content":"Blog# Stay updated with the latest news, releases, and articles about Sruja.\nNo posts yet.\n"},{"id":50,"href":"/courses/","title":"Courses","section":"Home","content":"Available Courses# Explore our comprehensive courses to master software architecture with Sruja.\nüéì System Design 101 Master the C4 Model with Sruja. A complete guide to designing scalable systems.\nüèóÔ∏è System Design 201 Real-World Architectures. Design TinyURL, WhatsApp, Netflix, and more.\n"},{"id":51,"href":"/docs/","title":"Introduction","section":"Home","content":"Sruja: Architecture as Code# Sruja is a modern, developer-friendly language for defining software architecture. It allows you to describe your systems, containers, and components using a clean, C4-model-based DSL, and then generate diagrams, documentation, and more.\nWhy Sruja?# Code-First# Treat your architecture like code. Version control it, review it, and evolve it. Sruja files are plain text, making them easy to diff and merge. This allows you to integrate architectural decision-making into your existing development workflows (Pull Requests, Code Reviews).\nC4 Model# Built-in support for the C4 model (System, Container, Component) ensures a standardized way to describe software. You don\u0026rsquo;t need to invent your own boxes and arrows; Sruja provides the primitives you need to describe software systems at different levels of abstraction.\nDiagrams as Code# Generate beautiful diagrams (via D2) automatically from your model. No more dragging boxes around in Visio or Lucidchart. When your code changes, your diagrams update automatically. This ensures your documentation never goes stale.\nValidation# Ensure your architecture follows best practices with built-in validation rules. Sruja can check for things like:\nOrphaned elements (defined but not connected). Circular dependencies. Missing descriptions or technology tags. Compliance with architectural policies. Key Features# Simple DSL# The Sruja DSL is designed to be easy to read and write. It uses a familiar C-style syntax with braces for grouping.\nsystem \u0026#34;MySystem\u0026#34; { container \u0026#34;WebApp\u0026#34; { technology \u0026#34;Go\u0026#34; } }D2 Export# Sruja exports directly to D2, a modern diagram scripting language. D2 handles the layout and routing, producing high-quality SVG diagrams that look professional and are easy to read.\nValidation Engine# Catch architectural smells early. The validation engine runs every time you build or check your model, providing immediate feedback on the health of your architecture.\nExtensible# Built for the future. Sruja is designed to be extensible, allowing for new export formats, custom validation rules, and integration with other tools in your ecosystem.\nGetting Started# Ready to dive in? Check out the Getting Started guide to install Sruja and build your first model.\nCommunity# Join the community to discuss architecture, share models, and contribute to Sruja.\n"},{"id":52,"href":"/tutorials/","title":"Tutorials","section":"Home","content":"Tutorials# Step-by-step guides to help you master Sruja.\nBasics# Getting Started More tutorials coming soon.\n"}]