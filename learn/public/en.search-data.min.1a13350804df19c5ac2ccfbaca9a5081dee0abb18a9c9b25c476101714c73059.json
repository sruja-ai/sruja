[{"id":0,"href":"/docs/concepts/architecture/","title":"Architecture","section":"Core Concepts","content":"Architecture# The architecture block is the root element of any Sruja model. It represents the entire scope of what you are modeling.\nSyntax# architecture \u0026#34;My System Name\u0026#34; { // ... define systems, persons, etc. here }Purpose# Scope Boundary: Everything inside is part of the model. Naming: Gives a name to the overall architecture. "},{"id":1,"href":"/docs/getting-started/","title":"Getting Started","section":"Introduction","content":"Getting Started with Sruja# This guide will help you install Sruja and create your first architecture model.\nInstallation# Automated Install (Recommended)# curl -fsSL https://raw.githubusercontent.com/sruja-ai/sruja/main/scripts/install.sh | bashManual Download# Download the latest release for your operating system from the GitHub Releases page.\nFrom Source (Go)# If you have Go installed, you can still build from source:\ngo install github.com/sruja-ai/sruja/cmd/sruja@latestVerify the installation:\nsruja --versionYour First Project# Create a file: Create a new file named architecture.sruja.\nWrite your model:\narchitecture \u0026#34;My System\u0026#34; { system App \u0026#34;My App\u0026#34; { container Web \u0026#34;Web Server\u0026#34; datastore DB \u0026#34;Database\u0026#34; } person User \u0026#34;User\u0026#34; User -\u0026gt; Web \u0026#34;Visits\u0026#34; Web -\u0026gt; DB \u0026#34;Reads/Writes\u0026#34; } Run Loading WASM... Visualize: Export to D2 to see the diagram.\nsruja export d2 architecture.sruja \u0026gt; architecture.d2You can then render architecture.d2 using the D2 CLI or online playground.\n"},{"id":2,"href":"/courses/system-design-201/module-2-real-time/lesson-1/","title":"Lesson 1: Design a Chat Application","section":"Module 2: Real-Time Systems","content":"Lesson 1: Design a Chat Application# Goal: Design a real-time chat service like WhatsApp or Slack that supports 1-on-1 and Group messaging.\nRequirements# Functional# Send/Receive messages in real-time. See user status (Online/Offline). Message history (persistent storage). Non-Functional# Low Latency: Messages must appear instantly. Consistency: Messages must be delivered in order. Availability: High uptime. Core Design# 1. Communication Protocol# HTTP is request/response (pull). For chat, we need push.\nWebSockets: Keeps a persistent connection open between client and server. 2. Message Flow# User A sends message to Chat Server. Chat Server finds which server User B is connected to (using a Session Store like Redis). Chat Server pushes message to User B. 3. Storage# Chat History: Write-heavy. Cassandra or HBase (Wide-column stores) are good for time-series data. User Status: Key-Value store (Redis) with TTL. üõ†Ô∏è Sruja Perspective: Modeling Real-Time Flows# We can use Sruja to model the WebSocket connections and the async message processing.\narchitecture \u0026#34;Chat System\u0026#34; { system ChatApp \u0026#34;WhatsApp Clone\u0026#34; { container ChatServer \u0026#34;Chat Server\u0026#34; { technology \u0026#34;Node.js (Socket.io)\u0026#34; description \u0026#34;Handles WebSocket connections\u0026#34; scale { min 10 max 100 metric \u0026#34;connections \u0026gt; 10k\u0026#34; } } datastore SessionStore \u0026#34;Session Store\u0026#34; { technology \u0026#34;Redis\u0026#34; description \u0026#34;Maps UserID -\u0026gt; WebSocketServerID\u0026#34; } datastore MessageDB \u0026#34;Message History\u0026#34; { technology \u0026#34;Cassandra\u0026#34; description \u0026#34;Stores chat logs\u0026#34; } queue MessageQueue \u0026#34;Message Queue\u0026#34; { technology \u0026#34;Kafka\u0026#34; description \u0026#34;Buffers messages for group chat fan-out\u0026#34; } } person UserA \u0026#34;Alice\u0026#34; person UserB \u0026#34;Bob\u0026#34; // Dynamic view of 1-on-1 chat dynamic ChatServer \u0026#34;Send Message Flow\u0026#34; { UserA -\u0026gt; ChatServer \u0026#34;Send \u0026#39;Hello\u0026#39;\u0026#34; ChatServer -\u0026gt; MessageDB \u0026#34;Persist message\u0026#34; ChatServer -\u0026gt; SessionStore \u0026#34;Lookup Bob\u0026#39;s connection\u0026#34; SessionStore -\u0026gt; ChatServer \u0026#34;Bob is on Server-2\u0026#34; ChatServer -\u0026gt; UserB \u0026#34;Push \u0026#39;Hello\u0026#39;\u0026#34; } }"},{"id":3,"href":"/courses/system-design-201/module-4-consistency/lesson-1/","title":"Lesson 1: Design a Distributed Counter","section":"Module 4: Distributed Consistency","content":"Lesson 1: Design a Distributed Counter# Goal: Design a system to count events (e.g., YouTube views, Facebook likes) at a massive scale (e.g., 1 million writes/sec).\nThe Problem with a Single Database# A standard SQL database (like PostgreSQL) can handle ~2k-5k writes/sec. If we try to update a single row (UPDATE videos SET views = views + 1 WHERE id = 123) for every view, the database will lock the row and become a bottleneck.\nSolutions# 1. Sharding (Write Splitting)# Instead of one counter, have $N$ counters for the same video.\nRandomly pick a counter from $1$ to $N$ and increment it. Total Views = Sum of all $N$ counters. 2. Write-Behind (Batching)# Don\u0026rsquo;t write to the DB immediately.\nStore counts in memory (Redis) or a log (Kafka). A background worker aggregates them and updates the DB every few seconds. Trade-off: If the server crashes before flushing, you lose a few seconds of data (Eventual Consistency). üõ†Ô∏è Sruja Perspective: Modeling Write Flows# We can use Sruja to model the \u0026ldquo;Write-Behind\u0026rdquo; architecture.\narchitecture \u0026#34;Distributed Counter\u0026#34; { system CounterService \u0026#34;View Counter\u0026#34; { container API \u0026#34;Ingestion API\u0026#34; { technology \u0026#34;Go\u0026#34; description \u0026#34;Receives \u0026#39;view\u0026#39; events\u0026#34; } queue EventLog \u0026#34;Kafka\u0026#34; { description \u0026#34;Buffers raw view events\u0026#34; } container Worker \u0026#34;Aggregator\u0026#34; { technology \u0026#34;Python\u0026#34; description \u0026#34;Reads batch of events, sums them, updates DB\u0026#34; scale { min 5 } } datastore DB \u0026#34;Counter DB\u0026#34; { technology \u0026#34;Cassandra\u0026#34; description \u0026#34;Stores final counts (Counter Columns)\u0026#34; } container Cache \u0026#34;Read Cache\u0026#34; { technology \u0026#34;Redis\u0026#34; description \u0026#34;Caches total counts for fast reads\u0026#34; } } person User \u0026#34;Viewer\u0026#34; // Write Path (Eventual Consistency) journey TrackView { User -\u0026gt; API \u0026#34;POST /view\u0026#34; API -\u0026gt; EventLog \u0026#34;Produce Event\u0026#34; API -\u0026gt; User \u0026#34;202 Accepted\u0026#34; // Async processing EventLog -\u0026gt; Worker \u0026#34;Consume Batch\u0026#34; Worker -\u0026gt; DB \u0026#34;UPDATE views += batch_size\u0026#34; Worker -\u0026gt; Cache \u0026#34;Invalidate/Update\u0026#34; } }"},{"id":4,"href":"/courses/system-design-201/module-1-high-throughput/lesson-1/","title":"Lesson 1: Design a URL Shortener","section":"Module 1: High-Throughput Systems","content":"Lesson 1: Design a URL Shortener# Goal: Design a service like TinyURL that takes a long URL and converts it into a short alias (e.g., http://tiny.url/xyz).\nRequirements# Functional# shorten(long_url) -\u0026gt; short_url redirect(short_url) -\u0026gt; long_url Custom aliases (optional). Non-Functional# Highly Available: If the service is down, URL redirection stops working. Low Latency: Redirection must happen in milliseconds. Read-Heavy: 100:1 read-to-write ratio. Core Design# 1. Database Choice# Since we need fast lookups and the data model is simple (Key-Value), a NoSQL Key-Value Store (like DynamoDB or Redis) is ideal.\nKey: short_alias Value: long_url 2. Hashing Algorithm# How do we generate the alias?\nMD5/SHA256: Too long. Base62 Encoding: Converts a unique ID (from a counter or database ID) into a string of characters [a-z, A-Z, 0-9]. üõ†Ô∏è Sruja Perspective: Modeling the Flow# We can use Sruja to model the system components and the user journey for redirection.\narchitecture \u0026#34;URL Shortener\u0026#34; { // Define the system boundary system TinyURL \u0026#34;TinyURL Service\u0026#34; { container WebServer \u0026#34;API Server\u0026#34; { technology \u0026#34;Go\u0026#34; scale { min 3 max 20 metric \u0026#34;cpu \u0026gt; 70%\u0026#34; } } datastore DB \u0026#34;UrlStore\u0026#34; { technology \u0026#34;DynamoDB\u0026#34; description \u0026#34;Stores mapping: short_alias -\u0026gt; long_url\u0026#34; } container Cache \u0026#34;Cache\u0026#34; { technology \u0026#34;Redis\u0026#34; description \u0026#34;Caches popular redirects\u0026#34; } } person User \u0026#34;User\u0026#34; // Define the redirection journey journey RedirectFlow { title \u0026#34;User clicks a short link\u0026#34; steps { User -\u0026gt; WebServer \u0026#34;GET /xyz\u0026#34; WebServer -\u0026gt; Cache \u0026#34;Check cache for \u0026#39;xyz\u0026#39;\u0026#34; Cache -\u0026gt; WebServer \u0026#34;Miss\u0026#34; WebServer -\u0026gt; DB \u0026#34;Get long_url for \u0026#39;xyz\u0026#39;\u0026#34; DB -\u0026gt; WebServer \u0026#34;Return \u0026#39;http://example.com\u0026#39;\u0026#34; WebServer -\u0026gt; User \u0026#34;301 Redirect to \u0026#39;http://example.com\u0026#39;\u0026#34; } } }"},{"id":5,"href":"/courses/system-design-201/module-3-data-intensive/lesson-1/","title":"Lesson 1: Design a Video Streaming Service","section":"Module 3: Data-Intensive Systems","content":"Lesson 1: Design a Video Streaming Service# Goal: Design a video sharing platform like YouTube or Netflix where users can upload and watch videos.\nRequirements# Functional# Upload videos. Watch videos (streaming). Support multiple resolutions (360p, 720p, 1080p). Non-Functional# Reliability: No buffering. Availability: Videos are always accessible. Scalability: Handle millions of concurrent viewers. Core Design# 1. Storage (Blob Store)# Videos are large binary files (BLOBs). Databases are bad for this.\nObject Storage: AWS S3, Google Cloud Storage. Metadata: Store title, description, and S3 URL in a SQL/NoSQL DB. 2. Processing (Transcoding)# Raw uploads are huge. We need to convert them into different formats and resolutions.\nTranscoding Service: Breaks video into chunks and encodes them (H.264, VP9). 3. Delivery (CDN)# Serving video from a single server is too slow for global users.\nContent Delivery Network (CDN): Caches video chunks in edge servers close to the user. 4. Adaptive Bitrate Streaming (HLS/DASH)# The player automatically switches quality based on the user\u0026rsquo;s internet speed.\nüõ†Ô∏è Sruja Perspective: Modeling Infrastructure# We can use Sruja\u0026rsquo;s deployment nodes to visualize the global distribution of content.\narchitecture \u0026#34;Video Streaming\u0026#34; { system YouTube \u0026#34;Video Platform\u0026#34; { container WebApp \u0026#34;Web App\u0026#34; container API \u0026#34;API Server\u0026#34; container Transcoder \u0026#34;Transcoding Service\u0026#34; { description \u0026#34;Converts raw video to HLS format\u0026#34; scale { min 50 } } datastore S3 \u0026#34;Blob Storage\u0026#34; { description \u0026#34;Stores raw and processed video files\u0026#34; } datastore MetadataDB \u0026#34;Metadata DB\u0026#34; } // Deployment View deployment \u0026#34;Global Infrastructure\u0026#34; { node \u0026#34;Origin Data Center\u0026#34; { containerInstance WebApp containerInstance API containerInstance Transcoder containerInstance S3 } node \u0026#34;CDN (Edge Locations)\u0026#34; { description \u0026#34;Cloudflare / Akamai\u0026#34; // Represents cached content node \u0026#34;US-East Edge\u0026#34; node \u0026#34;Europe Edge\u0026#34; node \u0026#34;Asia Edge\u0026#34; } } person User \u0026#34;Viewer\u0026#34; // Streaming Flow journey WatchVideo { User -\u0026gt; WebApp \u0026#34;Get Video Page\u0026#34; WebApp -\u0026gt; API \u0026#34;Get Metadata (Title, URL)\u0026#34; API -\u0026gt; MetadataDB \u0026#34;Query\u0026#34; API -\u0026gt; User \u0026#34;Return Video Manifest URL\u0026#34; User -\u0026gt; \u0026#34;CDN (Edge Locations)\u0026#34; \u0026#34;Request Video Chunk (1080p)\u0026#34; \u0026#34;CDN (Edge Locations)\u0026#34; -\u0026gt; User \u0026#34;Stream Chunk\u0026#34; } }"},{"id":6,"href":"/courses/system-design-101/module-4-production-readiness/lesson-1/","title":"Lesson 1: Documenting Decisions (ADRs)","section":"Module 4: Production Readiness","content":"Lesson 1: Documenting Decisions (ADRs)# What is an ADR?# An Architecture Decision Record (ADR) is a document that captures an important architectural decision made along with its context and consequences.\nWhy use ADRs?# Context: Explains why a decision was made (e.g., \u0026ldquo;Why did we choose Postgres over Mongo?\u0026rdquo;). Onboarding: Helps new team members understand the history of the system. Alignment: Ensures everyone agrees on the path forward. Structure of an ADR# Title: Short summary. Status: Proposed, Accepted, Deprecated. Context: The problem we are solving. Decision: What we are doing. Consequences: The pros and cons of this decision. üõ†Ô∏è Sruja Perspective: Native ADR Support# Sruja treats ADRs as first-class citizens. You can define them directly in your architecture file.\narchitecture \u0026#34;Payment System\u0026#34; { // Define an ADR adr ADR001 \u0026#34;Use Stripe for Payments\u0026#34; { status \u0026#34;Accepted\u0026#34; context \u0026#34;We need a reliable payment processor that supports global currencies.\u0026#34; decision \u0026#34;We will use Stripe as our primary payment gateway.\u0026#34; consequences \u0026#34;Vendor lock-in, but faster time to market.\u0026#34; } system PaymentService \u0026#34;Payment Service\u0026#34; { // Link the ADR to the component it affects adr ADR001 description \u0026#34;Handles credit card processing.\u0026#34; } }This ensures that your documentation lives right next to the code it describes, making it harder to ignore or lose.\n"},{"id":7,"href":"/courses/system-design-101/module-2-building-blocks/lesson-1/","title":"Lesson 1: Load Balancers","section":"Module 2: Building Blocks","content":"Lesson 1: Load Balancers# What is a Load Balancer?# A load balancer sits between clients and servers, distributing incoming network traffic across a group of backend servers. This ensures that no single server bears too much load.\nTypes of Load Balancing# Layer 4 (Transport Layer)# Decisions based on IP address and TCP/UDP ports. Faster, less CPU intensive. Does not inspect the content of the request. Layer 7 (Application Layer)# Decisions based on the content of the message (URL, HTTP headers, cookies). Can route traffic to different services based on URL (e.g., /images to image servers). More CPU intensive but smarter. Algorithms# Round Robin: Requests are distributed sequentially. Least Connections: Sends request to the server with the fewest active connections. IP Hash: The client\u0026rsquo;s IP address is used to determine which server receives the request (useful for session stickiness). üõ†Ô∏è Sruja Perspective: Modeling Load Balancers# In Sruja, a load balancer is typically modeled as a container or component that sits in front of your application servers.\narchitecture \u0026#34;Web Application\u0026#34; { container LB \u0026#34;Nginx Load Balancer\u0026#34; { technology \u0026#34;Nginx\u0026#34; tags \u0026#34;load-balancer\u0026#34; description \u0026#34;Layer 7 load balancer routing traffic based on URL paths.\u0026#34; } container AppServer \u0026#34;App Server\u0026#34; { technology \u0026#34;Python, Django\u0026#34; tags \u0026#34;scaled\u0026#34; } // Traffic flow LB -\u0026gt; AppServer \u0026#34;Distributes requests (Round Robin)\u0026#34; }"},{"id":8,"href":"/courses/system-design-101/module-3-advanced-modeling/lesson-1/","title":"Lesson 1: Microservices Architecture","section":"Module 3: Advanced Modeling","content":"Lesson 1: Microservices Architecture# Monolith vs. Microservices# Monolithic Architecture# A single application where all functionality is packaged together.\nPros: Simple to develop, deploy, and test initially. Cons: Hard to scale specific parts, tight coupling, single point of failure. Microservices Architecture# A collection of small, independent services that communicate over a network.\nPros: Independent scaling, technology diversity, fault isolation. Cons: Distributed system complexity, network latency, data consistency challenges. Defining Service Boundaries# The hardest part of microservices is deciding where to draw the lines. Common strategies include:\nBusiness Capability: Group by what the business does (e.g., Billing, Shipping). Subdomain: Group by Domain-Driven Design (DDD) subdomains. üõ†Ô∏è Sruja Perspective: Modeling Microservices# In Sruja, microservices are typically modeled as separate container items within a system, or even as separate system items if they are large enough.\narchitecture \u0026#34;E-Commerce Platform\u0026#34; { system OrderSystem \u0026#34;Order Management\u0026#34; { container OrderService \u0026#34;Order Service\u0026#34; { technology \u0026#34;Go\u0026#34; description \u0026#34;Handles order placement and tracking.\u0026#34; } } system InventorySystem \u0026#34;Inventory Management\u0026#34; { container InventoryService \u0026#34;Inventory Service\u0026#34; { technology \u0026#34;Java\u0026#34; description \u0026#34;Tracks stock levels.\u0026#34; } } // Inter-service communication OrderSystem -\u0026gt; InventorySystem \u0026#34;Reserves stock\u0026#34; }"},{"id":9,"href":"/courses/system-design-101/module-1-fundamentals/lesson-1/","title":"Lesson 1: What is System Design?","section":"Module 1: Fundamentals","content":"Lesson 1: What is System Design?# Defining System Design# System design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It is the bridge between business requirements and the final code.\nAt its core, system design is about managing complexity and making trade-offs. There is rarely a single \u0026ldquo;correct\u0026rdquo; design; instead, there are different designs that optimize for different goals (e.g., speed of development vs. system performance).\nRequirements Analysis# Every system design interview or real-world project starts with clarifying requirements. These are generally categorized into two types:\n1. Functional Requirements# These define what the system should do. They describe the specific behaviors or functions.\nExample: \u0026ldquo;Users should be able to post a tweet.\u0026rdquo; Example: \u0026ldquo;The system should send a notification when a new follower is added.\u0026rdquo; 2. Non-Functional Requirements (NFRs)# These define how the system should perform. They act as constraints on the design.\nScalability: Can the system handle 10 million daily active users? Availability: Will the system be up 99.99% of the time? Latency: Should the API respond within 200ms? Consistency: Do all users need to see the same data at the same time? The Art of Trade-offs# \u0026ldquo;Good\u0026rdquo; system design is all about choosing the right trade-offs.\nConsistency vs. Availability: You often can\u0026rsquo;t have both perfectly (CAP Theorem). Latency vs. Throughput: Optimizing for one might hurt the other. Cost vs. Performance: Faster hardware is more expensive. üõ†Ô∏è Sruja Perspective: Documenting Requirements# While Sruja is primarily for modeling architecture, it is also an excellent place to capture your requirements right alongside your design.\nIn Sruja, you can use the description field or comments to document high-level requirements.\narchitecture \u0026#34;Twitter Clone\u0026#34; { // Native Requirement Support requirement R1 functional \u0026#34;Users can post tweets\u0026#34; requirement R2 performance \u0026#34;Must handle 10k writes/second\u0026#34; system Twitter \u0026#34;Social Media Platform\u0026#34; { description \u0026#34;Allows users to post short messages and follow others.\u0026#34; } }By using the requirement keyword, you make requirements a first-class citizen of your architecture. These can be validated and tracked by the Sruja CLI.\n"},{"id":10,"href":"/courses/system-design-101/module-1-fundamentals/","title":"Module 1: Fundamentals","section":"System Design 101","content":"Module 1: Fundamentals# Before diving into specific technologies like databases or load balancers, it\u0026rsquo;s crucial to understand the fundamental principles that guide system design. In this module, we will explore the core concepts that every system architect must know.\nLessons# What is System Design? Learn about functional and non-functional requirements and the art of trade-offs. Scalability \u0026amp; Performance Understand the difference between vertical and horizontal scaling, and latency vs. throughput. Availability \u0026amp; Reliability Explore redundancy, failover strategies, and SLAs. CAP Theorem \u0026amp; Consistency Dive into the trade-offs between Consistency, Availability, and Partition Tolerance. User Journeys Learn how to model user flows and validate your architecture with scenarios. "},{"id":11,"href":"/courses/system-design-201/module-1-high-throughput/","title":"Module 1: High-Throughput Systems","section":"System Design 201: Real-World Architectures","content":"Module 1: High-Throughput Systems# In this module, we focus on systems that need to handle a massive number of requests per second with low latency.\nLessons# Design a URL Shortener TinyURL: Handling high read/write ratios and redirection. Design a Rate Limiter Protection: Preventing abuse and managing traffic spikes. "},{"id":12,"href":"/docs/concepts/","title":"Core Concepts","section":"Introduction","content":"Core Concepts# Sruja is built around the C4 Model for visualizing software architecture. It defines a hierarchy of abstractions:\nArchitecture: The root context. System: The highest level of abstraction. A software system. Container: Applications or data stores within a system (e.g., API, Web App, Database). Component: Modules or major structural building blocks within a container. Elements# Architecture System Container Component Person DataStore Queue Relations Deployment Dynamic Views "},{"id":13,"href":"/courses/system-design-101/module-2-building-blocks/lesson-2/","title":"Lesson 2: Databases","section":"Module 2: Building Blocks","content":"Lesson 2: Databases# SQL vs. NoSQL# SQL (Relational Databases)# Structure: Structured data with predefined schemas (Tables, Rows, Columns). Query Language: SQL (Structured Query Language). ACID Compliance: Strong guarantees for Atomicity, Consistency, Isolation, Durability. Examples: MySQL, PostgreSQL, Oracle. Best for: Complex queries, financial transactions. NoSQL (Non-Relational Databases)# Structure: Flexible schemas (Key-Value, Document, Graph, Column-Family). Scalability: Designed for horizontal scaling. Examples: MongoDB (Document), Redis (Key-Value), Cassandra (Column). Best for: Rapidly changing data, massive scale, unstructured data. Scaling Databases# Replication# Copying data to multiple servers.\nMaster-Slave: Writes go to Master, Reads go to Slaves. Good for read-heavy systems. Master-Master: Writes can go to any node. Complex conflict resolution needed. Sharding# Partitioning data across multiple servers (e.g., Users A-M on Server 1, N-Z on Server 2).\nPros: Handles massive data volumes. Cons: Complex joins, rebalancing data is hard. üõ†Ô∏è Sruja Perspective: Modeling Databases# Sruja allows you to define the type of database and its role in the system.\narchitecture \u0026#34;User Management\u0026#34; { container UserDB \u0026#34;User Database\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; tags \u0026#34;relational\u0026#34;, \u0026#34;primary\u0026#34; description \u0026#34;Stores user profiles and authentication data.\u0026#34; } container SessionStore \u0026#34;Session Cache\u0026#34; { technology \u0026#34;Redis\u0026#34; tags \u0026#34;key-value\u0026#34;, \u0026#34;cache\u0026#34; description \u0026#34;Stores active user sessions for fast access.\u0026#34; } }"},{"id":14,"href":"/courses/system-design-101/module-4-production-readiness/lesson-2/","title":"Lesson 2: Deployment Architecture","section":"Module 4: Production Readiness","content":"Lesson 2: Deployment Architecture# Logical vs. Physical Architecture# Logical Architecture: The software components and how they interact (Containers, Components). Physical Architecture: Where those components actually run (Servers, VMs, Kubernetes Pods). Deployment Strategies# On-Premises# Running on your own hardware in a data center.\nPros: Total control, security. Cons: High maintenance, capital expense. Cloud (AWS, GCP, Azure)# Renting infrastructure from a provider.\nPros: Pay-as-you-go, infinite scale. Cons: Vendor lock-in, variable costs. Containers \u0026amp; Orchestration# Packaging code with dependencies (Docker) and managing them at scale (Kubernetes).\nüõ†Ô∏è Sruja Perspective: Deployment Nodes# Sruja allows you to map your logical containers to physical deployment nodes.\narchitecture \u0026#34;Web App\u0026#34; { container WebServer \u0026#34;Nginx\u0026#34; container AppServer \u0026#34;Python App\u0026#34; container Database \u0026#34;Postgres\u0026#34; // Define the deployment environment deployment \u0026#34;Production\u0026#34; { node \u0026#34;AWS\u0026#34; { node \u0026#34;US-East-1\u0026#34; { node \u0026#34;EC2 Instance\u0026#34; { // Map the logical container to this node containerInstance WebServer containerInstance AppServer } node \u0026#34;RDS\u0026#34; { containerInstance Database } } } } }This mapping allows you to visualize exactly where your code is running in production.\n"},{"id":15,"href":"/courses/system-design-201/module-1-high-throughput/lesson-2/","title":"Lesson 2: Design a Rate Limiter","section":"Module 1: High-Throughput Systems","content":"Lesson 2: Design a Rate Limiter# Goal: Design a system to limit the number of requests a client can send to an API within a time window (e.g., 10 requests per second).\nWhy Rate Limit?# Prevent Abuse: Stop DDoS attacks or malicious bots. Fairness: Ensure one user doesn\u0026rsquo;t hog all resources. Cost Control: Prevent auto-scaling bills from exploding. Algorithms# Token Bucket# A \u0026ldquo;bucket\u0026rdquo; holds tokens. Tokens are added at a fixed rate (e.g., 10 tokens/sec). Each request consumes a token. If the bucket is empty, the request is dropped (429 Too Many Requests). Leaky Bucket# Requests enter a queue (bucket) and are processed at a constant rate. If the queue is full, new requests are dropped. Architecture Location# Where does the rate limiter live?\nClient-side: Unreliable (can be forged). Server-side: Inside the application code. Middleware: In a centralized API Gateway (Best practice). üõ†Ô∏è Sruja Perspective: Middleware Modeling# In Sruja, we can model the Rate Limiter as a component within the API Gateway, backed by a fast datastore like Redis.\narchitecture \u0026#34;API Rate Limiter\u0026#34; { system APIGateway \u0026#34;API Gateway\u0026#34; { container GatewayService \u0026#34;Gateway\u0026#34; { technology \u0026#34;Nginx / Kong\u0026#34; component RateLimiter \u0026#34;Rate Limiter Middleware\u0026#34; { description \u0026#34;Implements Token Bucket algorithm\u0026#34; } } datastore Redis \u0026#34;Rate Limit Store\u0026#34; { technology \u0026#34;Redis\u0026#34; description \u0026#34;Stores token counts per user/IP\u0026#34; } } container Backend \u0026#34;Backend Service\u0026#34; person Client \u0026#34;Client\u0026#34; // Dynamic view of a request being limited dynamic GatewayService \u0026#34;Rate Limit Check\u0026#34; { Client -\u0026gt; GatewayService \u0026#34;API Request\u0026#34; GatewayService -\u0026gt; RateLimiter \u0026#34;Check Limit\u0026#34; RateLimiter -\u0026gt; Redis \u0026#34;DECR user_123_tokens\u0026#34; Redis -\u0026gt; RateLimiter \u0026#34;Result: -1 (Empty)\u0026#34; RateLimiter -\u0026gt; GatewayService \u0026#34;Deny\u0026#34; GatewayService -\u0026gt; Client \u0026#34;429 Too Many Requests\u0026#34; } }"},{"id":16,"href":"/courses/system-design-101/module-3-advanced-modeling/lesson-2/","title":"Lesson 2: Event-Driven Architecture","section":"Module 3: Advanced Modeling","content":"Lesson 2: Event-Driven Architecture# Synchronous vs. Asynchronous# Synchronous (Request/Response): Client waits for the server to respond (e.g., HTTP REST). Asynchronous (Event-Driven): Client sends a message and continues work. The receiver processes it later. Core Concepts# Message Queues (Point-to-Point)# A message is sent to a queue and processed by exactly one consumer.\nUse Case: Background jobs (e.g., image resizing). Pub/Sub (Publish/Subscribe)# A message (event) is published to a topic. Multiple subscribers can receive a copy.\nUse Case: notifying multiple services (e.g., \u0026ldquo;UserSignedUp\u0026rdquo; -\u0026gt; EmailService, AnalyticsService). üõ†Ô∏è Sruja Perspective: Modeling Events# Sruja supports queue as a first-class citizen to model asynchronous communication.\narchitecture \u0026#34;Notification System\u0026#34; { container AuthService \u0026#34;Auth Service\u0026#34; { technology \u0026#34;Node.js\u0026#34; } // Define a queue or topic queue UserEvents \u0026#34;User Events Topic\u0026#34; { technology \u0026#34;Kafka\u0026#34; description \u0026#34;Events related to user lifecycle (signup, login).\u0026#34; } container EmailService \u0026#34;Email Service\u0026#34; { technology \u0026#34;Python\u0026#34; } container AnalyticsService \u0026#34;Analytics Service\u0026#34; { technology \u0026#34;Spark\u0026#34; } // Pub/Sub flow AuthService -\u0026gt; UserEvents \u0026#34;Publishes \u0026#39;UserSignedUp\u0026#39;\u0026#34; UserEvents -\u0026gt; EmailService \u0026#34;Consumes\u0026#34; UserEvents -\u0026gt; AnalyticsService \u0026#34;Consumes\u0026#34; }"},{"id":17,"href":"/courses/system-design-101/module-1-fundamentals/lesson-2/","title":"Lesson 2: Scalability \u0026 Performance","section":"Module 1: Fundamentals","content":"Lesson 2: Scalability \u0026amp; Performance# What is Scalability?# Scalability is the ability of a system to handle increased load without performance degradation. It\u0026rsquo;s not just about \u0026ldquo;handling more users\u0026rdquo;; it\u0026rsquo;s about doing so cost-effectively and reliably.\nVertical Scaling (Scaling Up)# Adding more power (CPU, RAM) to an existing server.\nPros: Simple to implement. Cons: Hardware limits, single point of failure, expensive at the high end. Horizontal Scaling (Scaling Out)# Adding more servers to the pool of resources.\nPros: Theoretically infinite scale, better fault tolerance. Cons: Increased complexity (load balancing, data consistency). Performance Metrics# Latency# The time it takes for a system to process a request.\nGoal: Minimize latency (e.g., \u0026ldquo;API response \u0026lt; 100ms\u0026rdquo;). Throughput# The number of requests a system can handle per unit of time.\nGoal: Maximize throughput (e.g., \u0026ldquo;Handle 10,000 requests per second\u0026rdquo;). üõ†Ô∏è Sruja Perspective: Modeling Scalability# In Sruja, you can represent horizontal scaling using the native scale block. This allows you to define minimum and maximum replicas and the scaling metric.\narchitecture \u0026#34;E-Commerce Site\u0026#34; { container WebServer \u0026#34;Web App\u0026#34; { technology \u0026#34;Go, Gin\u0026#34; // Define horizontal scaling properties scale { min 3 max 10 metric \u0026#34;cpu \u0026gt; 80%\u0026#34; } } container Database \u0026#34;Primary DB\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; // Vertical scaling example description \u0026#34;Running on a high-memory instance (AWS r5.2xlarge).\u0026#34; } }"},{"id":18,"href":"/courses/system-design-101/module-2-building-blocks/","title":"Module 2: Building Blocks","section":"System Design 101","content":"Module 2: Building Blocks# A distributed system is built from several key components. In this module, we will explore the most common building blocks and how to use them effectively.\nLessons# Load Balancers Distributing traffic across multiple servers. Databases Choosing between SQL and NoSQL, and scaling data. Caching Improving performance with in-memory data stores. "},{"id":19,"href":"/courses/system-design-201/module-2-real-time/","title":"Module 2: Real-Time Systems","section":"System Design 201: Real-World Architectures","content":"Module 2: Real-Time Systems# In this module, we explore systems where data needs to be pushed to the client instantly, rather than pulled.\nLessons# Design a Chat Application WhatsApp/Slack: Handling persistent connections and message delivery. "},{"id":20,"href":"/docs/concepts/system/","title":"System","section":"Core Concepts","content":"System# A System represents a software system, which is the highest level of abstraction in the C4 model. A system delivers value to its users, whether they are human or other systems.\nSyntax# system ID \u0026#34;Label/Name\u0026#34; { description \u0026#34;Optional description\u0026#34; // ... contains containers }Example# system BankingSystem \u0026#34;Internet Banking System\u0026#34; { description \u0026#34;Allows customers to view accounts and make payments.\u0026#34; }"},{"id":21,"href":"/docs/concepts/container/","title":"Container","section":"Core Concepts","content":"Container# A Container represents an application or a data store. It is something that needs to be running in order for the overall software system to work.\nNote: In C4, \u0026ldquo;Container\u0026rdquo; does not mean a Docker container. It means a deployable unit like:\nServer-side web application (e.g., Java Spring, ASP.NET Core) Client-side web application (e.g., React, Angular) Mobile app Database schema File system Syntax# container ID \u0026#34;Label/Name\u0026#34; { technology \u0026#34;Technology Stack\u0026#34; tags [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] // ... contains components }Example# container WebApp \u0026#34;Web Application\u0026#34; { technology \u0026#34;Java and Spring MVC\u0026#34; tags [\u0026#34;web\u0026#34;, \u0026#34;frontend\u0026#34;] }"},{"id":22,"href":"/docs/reference/","title":"DSL Reference","section":"Introduction","content":"DSL Reference# This section provides a comprehensive reference for the Sruja Domain Specific Language (DSL).\nGrammar# The Sruja DSL is designed to be human-readable and concise. It uses a C-like syntax with braces {} for grouping.\nBasic Rules# Strings: Double-quoted strings \u0026quot;value\u0026quot;. Identifiers: Alphanumeric names (e.g., WebApp, API_Service). Comments: // for single line, /* ... */ for multi-line. Elements# Architecture# architecture \u0026#34;Name\u0026#34; { ... }System# system ID \u0026#34;Label\u0026#34; { ... }Container# container ID \u0026#34;Label\u0026#34; { ... }Component# component ID \u0026#34;Label\u0026#34; { ... }Person# person ID \u0026#34;Label\u0026#34;Relations# From -\u0026gt; To \u0026#34;Label\u0026#34;"},{"id":23,"href":"/courses/system-design-101/module-1-fundamentals/lesson-3/","title":"Lesson 3: Availability \u0026 Reliability","section":"Module 1: Fundamentals","content":"Lesson 3: Availability \u0026amp; Reliability# Reliability vs. Availability# Reliability: The probability that a system will function correctly without failure for a specified period. It\u0026rsquo;s about correctness. Availability: The percentage of time a system is operational and accessible. It\u0026rsquo;s about uptime. A system can be available but not reliable (e.g., it returns 500 errors but is \u0026ldquo;up\u0026rdquo;).\nMeasuring Availability# Availability is often measured in \u0026ldquo;nines\u0026rdquo;:\nAvailability Downtime per Year 99% (Two nines) 3.65 days 99.9% (Three nines) 8.76 hours 99.99% (Four nines) 52.6 minutes 99.999% (Five nines) 5.26 minutes Achieving High Availability# Redundancy# The key to availability is eliminating Single Points of Failure (SPOF). This is done via redundancy.\nActive-Passive: One server handles traffic; the other is on standby. Active-Active: Both servers handle traffic. If one fails, the other takes over the full load. Failover# The process of switching to a redundant system upon failure. This can be manual or automatic.\nüõ†Ô∏è Sruja Perspective: Modeling Redundancy# You can explicitly model redundant components in Sruja to visualize your high-availability strategy.\narchitecture \u0026#34;Payment Gateway\u0026#34; { container PaymentService \u0026#34;Payment Service\u0026#34; { technology \u0026#34;Java\u0026#34; } // Modeling a primary and standby database container PrimaryDB \u0026#34;Primary Database\u0026#34; { technology \u0026#34;MySQL\u0026#34; tags \u0026#34;primary\u0026#34; } container StandbyDB \u0026#34;Standby Database\u0026#34; { technology \u0026#34;MySQL\u0026#34; tags \u0026#34;standby\u0026#34; description \u0026#34;Replicates from PrimaryDB. Promoted to primary if PrimaryDB fails.\u0026#34; } PaymentService -\u0026gt; PrimaryDB \u0026#34;Reads/Writes\u0026#34; PrimaryDB -\u0026gt; StandbyDB \u0026#34;Replicates data\u0026#34; }"},{"id":24,"href":"/courses/system-design-101/module-2-building-blocks/lesson-3/","title":"Lesson 3: Caching","section":"Module 2: Building Blocks","content":"Lesson 3: Caching# Why Cache?# Caching is the process of storing copies of data in a temporary storage location (cache) so that future requests for that data can be served faster.\nReduce Latency: Memory is faster than disk. Reduce Load: Fewer queries to the database. Caching Strategies# Cache-Aside (Lazy Loading)# App checks cache. If miss, App reads from DB. App writes to cache. Pros: Only requested data is cached. Cons: Initial request is slow (cache miss). Write-Through# App writes to cache and DB simultaneously. Pros: Data in cache is always fresh. Cons: Slower writes. Write-Back (Write-Behind)# App writes to cache only. Cache writes to DB asynchronously. Pros: Fast writes. Cons: Data loss risk if cache fails before syncing. Eviction Policies# When the cache is full, what do you remove?\nLRU (Least Recently Used): Remove the item that hasn\u0026rsquo;t been used for the longest time. LFU (Least Frequently Used): Remove the item used least often. FIFO (First In, First Out): Remove the oldest item. üõ†Ô∏è Sruja Perspective: Modeling Caches# In Sruja, caches are often modeled as separate containers or components.\narchitecture \u0026#34;Product Catalog\u0026#34; { container WebApp \u0026#34;Storefront\u0026#34; { technology \u0026#34;Node.js\u0026#34; } container ProductCache \u0026#34;Product Cache\u0026#34; { technology \u0026#34;Memcached\u0026#34; description \u0026#34;Caches product details using LRU eviction.\u0026#34; } container ProductDB \u0026#34;Product Database\u0026#34; { technology \u0026#34;MongoDB\u0026#34; } WebApp -\u0026gt; ProductCache \u0026#34;Read (Cache-Aside)\u0026#34; WebApp -\u0026gt; ProductDB \u0026#34;Read on Miss\u0026#34; }"},{"id":25,"href":"/courses/system-design-101/module-3-advanced-modeling/lesson-3/","title":"Lesson 3: Dynamic Views vs User Journeys","section":"Module 3: Advanced Modeling","content":"Lesson 3: Dynamic Views vs User Journeys# As you model complex systems, it\u0026rsquo;s important to distinguish between what the system does for the user and how the system components interact technically.\nUser Journeys (The \u0026ldquo;What\u0026rdquo;)# A User Journey describes a high-level scenario from the perspective of an actor (user). It focuses on the value delivered.\nScope: Often spans multiple systems. Audience: Product Managers, Stakeholders, QA. Example: \u0026ldquo;User purchases a ticket.\u0026rdquo; Dynamic Views (The \u0026ldquo;How\u0026rdquo;)# A Dynamic View illustrates how elements in your static model interact at runtime to fulfill a specific user story or feature. It is essentially a sequence diagram derived from your static model.\nScope: specific interactions between containers/components. Audience: Developers, Architects. Example: \u0026ldquo;API Controller calls Auth Service, then Database.\u0026rdquo; üõ†Ô∏è Sruja Perspective: journey vs dynamic# Sruja supports both concepts natively.\n1. User Journeys# Use journey for high-level flows.\njourney BuyTicket { title \u0026#34;User purchases a ticket\u0026#34; steps { User -\u0026gt; WebApp \u0026#34;Selects ticket\u0026#34; WebApp -\u0026gt; PaymentService \u0026#34;Process payment\u0026#34; } }2. Dynamic Views# Use dynamic to show technical runtime interactions.\nSyntax: dynamic \u0026lt;ID\u0026gt; \u0026lt;Title\u0026gt; [Description] { \u0026lt;Step\u0026gt;... } Note: Unlike journeys, steps are direct children (no steps block), and description is a positional argument. architecture \u0026#34;E-Commerce\u0026#34; { container WebApp \u0026#34;Web App\u0026#34; container API \u0026#34;API Gateway\u0026#34; container DB \u0026#34;Database\u0026#34; // dynamic \u0026lt;ID\u0026gt; \u0026lt;Title\u0026gt; \u0026lt;Description\u0026gt; dynamic API_Flow \u0026#34;API Request Flow\u0026#34; \u0026#34;How the API handles a product search\u0026#34; { WebApp -\u0026gt; API \u0026#34;GET /products\u0026#34; API -\u0026gt; DB \u0026#34;SELECT * FROM products\u0026#34; DB -\u0026gt; API \u0026#34;Return results\u0026#34; API -\u0026gt; WebApp \u0026#34;JSON Response\u0026#34; } }Key Difference: journey is often about the actor\u0026rsquo;s experience, while dynamic is about the system\u0026rsquo;s internal execution.\n"},{"id":26,"href":"/courses/system-design-101/module-3-advanced-modeling/","title":"Module 3: Advanced Modeling","section":"System Design 101","content":"Module 3: Advanced Modeling# As systems grow, they often evolve from simple monoliths into complex distributed architectures. In this module, we will explore how to model these advanced patterns.\nLessons# Microservices Architecture Decomposing monoliths into independent services. Event-Driven Architecture Decoupling services with asynchronous messaging. Dynamic Views vs User Journeys Runtime views of static models vs High-level user stories. "},{"id":27,"href":"/courses/system-design-201/module-3-data-intensive/","title":"Module 3: Data-Intensive Systems","section":"System Design 201: Real-World Architectures","content":"Module 3: Data-Intensive Systems# In this module, we look at systems that handle massive amounts of data, specifically large media files.\nLessons# Design a Video Streaming Service YouTube/Netflix: Storing, processing, and delivering video at scale. "},{"id":28,"href":"/docs/cli/","title":"CLI Guide","section":"Introduction","content":"CLI Guide# The sruja command-line interface is your primary tool for interacting with Sruja projects.\nCommands# export# Exports the architecture to various formats.\nUsage:\nsruja export [format] [file]Supported Formats:\nd2: Generates D2 diagram code. Example:\nsruja export d2 architecture.srujatree# Displays the architecture structure as a tree in the terminal.\nUsage:\nsruja tree --file [file]Options:\n--json: Output as JSON. --system [ID]: Show tree for a specific system. Example:\nsruja tree --file architecture.srujafmt# Formats the Sruja file to a canonical style.\nUsage:\nsruja fmt [file]check# Validates the Sruja file against rules and best practices.\nUsage:\nsruja check [file]"},{"id":29,"href":"/docs/concepts/component/","title":"Component","section":"Core Concepts","content":"Component# A Component is a grouping of related functionality encapsulated behind a well-defined interface. Components reside inside Containers.\nSyntax# component ID \u0026#34;Label/Name\u0026#34; { technology \u0026#34;Technology\u0026#34; // ... items }Example# component AuthController \u0026#34;Authentication Controller\u0026#34; { technology \u0026#34;Spring MVC Rest Controller\u0026#34; description \u0026#34;Handles user login and registration.\u0026#34; }"},{"id":30,"href":"/courses/system-design-101/module-1-fundamentals/lesson-4/","title":"Lesson 4: CAP Theorem \u0026 Consistency","section":"Module 1: Fundamentals","content":"Lesson 4: CAP Theorem \u0026amp; Consistency# The CAP Theorem# Proposed by Eric Brewer, the CAP theorem states that a distributed data store can only provide two of the following three guarantees:\nConsistency (C): Every read receives the most recent write or an error. All nodes see the same data at the same time. Availability (A): Every request receives a (non-error) response, without the guarantee that it contains the most recent write. Partition Tolerance (P): The system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes. The Reality: P is Mandatory# In a distributed system, network partitions (P) are inevitable. Therefore, you must choose between Consistency (CP) and Availability (AP) when a partition occurs.\nCP (Consistency + Partition Tolerance): Wait for data to sync. If a node is unreachable, return an error. (e.g., Banking systems). AP (Availability + Partition Tolerance): Return the most recent version of data available, even if it might be stale. (e.g., Social media feeds). Consistency Models# Strong Consistency: Once a write is confirmed, all subsequent reads see that value. Eventual Consistency: If no new updates are made, eventually all accesses will return the last updated value. (Common in AP systems). üõ†Ô∏è Sruja Perspective: Documenting Guarantees# When defining data stores in Sruja, it is helpful to document their consistency guarantees, especially for distributed databases.\narchitecture \u0026#34;Global User Store\u0026#34; { container UserDB \u0026#34;User Database\u0026#34; { technology \u0026#34;Cassandra\u0026#34; // Explicitly stating the consistency model description \u0026#34;configured with replication factor 3. Uses eventual consistency for high availability.\u0026#34; // You could also use custom tags tags \u0026#34;AP-System\u0026#34;, \u0026#34;Eventual-Consistency\u0026#34; } container BillingDB \u0026#34;Billing Database\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; description \u0026#34;Single primary with synchronous replication to ensure strong consistency.\u0026#34; tags \u0026#34;CP-System\u0026#34;, \u0026#34;Strong-Consistency\u0026#34; } }"},{"id":31,"href":"/courses/system-design-201/module-4-consistency/","title":"Module 4: Distributed Consistency","section":"System Design 201: Real-World Architectures","content":"Module 4: Distributed Consistency# In this module, we tackle the hardest problem in distributed systems: keeping data consistent across multiple nodes.\nLessons# Design a Distributed Counter Counting at Scale: How to count millions of events (likes, views) per second accurately. "},{"id":32,"href":"/courses/system-design-101/module-4-production-readiness/","title":"Module 4: Production Readiness","section":"System Design 101","content":"Module 4: Production Readiness# Designing a system is only the first step. To make it production-ready, you need to document your decisions and plan your deployment.\nLessons# Documenting Decisions (ADRs) Capturing the \u0026ldquo;why\u0026rdquo; behind your architecture. Deployment Architecture Mapping your software to physical infrastructure. "},{"id":33,"href":"/courses/system-design-101/module-1-fundamentals/lesson-5/","title":"Lesson 5: User Journeys","section":"Module 1: Fundamentals","content":"Lesson 5: User Journeys# Understanding User Journeys# A User Journey describes the series of steps a user takes to achieve a specific goal within your system. While static architecture diagrams show structure, user journeys show behavior.\nWhy Model Journeys?# Validation: Ensures that all components required for a feature actually exist and are connected. Clarity: Helps stakeholders understand how the system works from a user\u0026rsquo;s perspective. Testing: Serves as a blueprint for integration and end-to-end tests. Example Scenario: Buying a Ticket# User searches for events. User selects a ticket. User enters payment details. System processes payment. System sends confirmation email. üõ†Ô∏è Sruja Perspective: Modeling Journeys# Sruja provides a dedicated journey keyword to model these interactions explicitly. This allows you to visualize the flow of data across your defined architecture.\narchitecture \u0026#34;Ticketing System\u0026#34; { // Define the actors and systems first person User \u0026#34;Ticket Buyer\u0026#34; system TicketingApp \u0026#34;Ticketing Platform\u0026#34; { container WebApp \u0026#34;Web Frontend\u0026#34; container PaymentService \u0026#34;Payment Processor\u0026#34; container EmailService \u0026#34;Notification Service\u0026#34; } // Define the journey journey BuyTicket { title \u0026#34;User purchases a concert ticket\u0026#34; steps { User -\u0026gt; WebApp \u0026#34;Selects ticket\u0026#34; WebApp -\u0026gt; PaymentService \u0026#34;Process payment\u0026#34; PaymentService -\u0026gt; EmailService \u0026#34;Trigger confirmation\u0026#34; EmailService -\u0026gt; User \u0026#34;Send email\u0026#34; } } }By defining journeys, you can automatically generate sequence diagrams or flowcharts that map directly to your code.\n"},{"id":34,"href":"/docs/concepts/relations/","title":"Relations","section":"Core Concepts","content":"Relations# Relations describe how elements interact with each other. They are the lines connecting the boxes in your diagram.\nSyntax# Source -\u0026gt; Destination \u0026#34;Label\u0026#34;Or with a technology/protocol:\nSource -\u0026gt; Destination \u0026#34;Label\u0026#34; { technology \u0026#34;HTTPS/JSON\u0026#34; }Example# User -\u0026gt; WebApp \u0026#34;Visits\u0026#34; WebApp -\u0026gt; DB \u0026#34;Reads Data\u0026#34;"},{"id":35,"href":"/docs/concepts/person/","title":"Person","section":"Core Concepts","content":"Person# A Person represents a human user of your software system (e.g., \u0026ldquo;Customer\u0026rdquo;, \u0026ldquo;Admin\u0026rdquo;, \u0026ldquo;Employee\u0026rdquo;).\nSyntax# person ID \u0026#34;Label\u0026#34; { description \u0026#34;Optional description\u0026#34; tags [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] }Example# person Customer \u0026#34;Bank Customer\u0026#34; { description \u0026#34;A customer of the bank with personal accounts.\u0026#34; }"},{"id":36,"href":"/docs/concepts/datastore/","title":"DataStore","section":"Core Concepts","content":"DataStore# A DataStore represents a database, file system, or any other system that stores data. It is a specialized type of Container.\nSyntax# datastore ID \u0026#34;Label\u0026#34; { description \u0026#34;Optional description\u0026#34; technology \u0026#34;Technology\u0026#34; }Example# datastore DB \u0026#34;Main Database\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; description \u0026#34;Stores user and order data\u0026#34; }"},{"id":37,"href":"/docs/concepts/queue/","title":"Queue","section":"Core Concepts","content":"Queue# A Queue represents a message queue, topic, or event stream. It is a specialized type of Container used for asynchronous communication.\nSyntax# queue ID \u0026#34;Label\u0026#34; { description \u0026#34;Optional description\u0026#34; technology \u0026#34;Technology\u0026#34; }Example# queue Events \u0026#34;Event Stream\u0026#34; { technology \u0026#34;Kafka\u0026#34; description \u0026#34;Handles domain events\u0026#34; }"},{"id":38,"href":"/docs/concepts/deployment/","title":"Deployment","section":"Core Concepts","content":"Deployment# The Deployment view allows you to map your software containers to infrastructure. This corresponds to the C4 Deployment Diagram.\nDeployment Node# A Deployment Node is something like physical hardware, a virtual machine, a Docker container, a Kubernetes pod, etc. Nodes can be nested.\nSyntax# deployment \u0026#34;Environment\u0026#34; { node \u0026#34;Node Name\u0026#34; { // ... } }Infrastructure Node# An Infrastructure Node represents infrastructure software that isn\u0026rsquo;t one of your containers (e.g., DNS, Load Balancer, External Database Service).\nSyntax# node \u0026#34;App Server\u0026#34; { containerInstance WebApp }Container Instance# A Container Instance represents a runtime instance of one of your defined Containers running on a Deployment Node.\nSyntax# containerInstance ContainerID { instanceId 1 // Optional }Example# deployment \u0026#34;Production\u0026#34; { node \u0026#34;AWS\u0026#34; { node \u0026#34;US-East-1\u0026#34; { node \u0026#34;App Server\u0026#34; { containerInstance WebApp } node \u0026#34;Database Server\u0026#34; { containerInstance DB } } } }"},{"id":39,"href":"/docs/concepts/dynamic-view/","title":"Dynamic Views","section":"Core Concepts","content":"Dynamic Views# Dynamic Views describe how elements (Containers, Components) interact at runtime to implement a specific user story or feature. This corresponds to the C4 Dynamic Diagram.\nSyntax# dynamic \u0026#34;View Title\u0026#34; { description \u0026#34;Optional description\u0026#34; Source -\u0026gt; Destination \u0026#34;Description of interaction\u0026#34; // or Source -\u0026gt; Destination \u0026#34;Description\u0026#34; { order \u0026#34;1\u0026#34; // Explicit ordering } }Example# dynamic \u0026#34;Login Flow\u0026#34; { User -\u0026gt; WebApp \u0026#34;Submits credentials\u0026#34; WebApp -\u0026gt; AuthComponent \u0026#34;Validates credentials\u0026#34; AuthComponent -\u0026gt; DB \u0026#34;Checks user record\u0026#34; DB -\u0026gt; AuthComponent \u0026#34;Returns user data\u0026#34; AuthComponent -\u0026gt; WebApp \u0026#34;Returns token\u0026#34; WebApp -\u0026gt; User \u0026#34;Redirects to dashboard\u0026#34; }"},{"id":40,"href":"/courses/system-design-101/","title":"System Design 101","section":"Courses","content":"System Design 101# Master the Fundamentals of Scalable Systems# Welcome to the System Design 101 course! This course is designed to teach you the core concepts of designing large-scale distributed systems. Whether you are a student, a fresher, or looking to refresh your knowledge, this course will guide you through the essential building blocks of modern software architecture.\nWhat you will learn# In this course, you will learn how to:\nThink in Systems: Understand the trade-offs between different design choices. Design for Scale: Master concepts like vertical vs. horizontal scaling, load balancing, and sharding. Ensure Reliability: Learn strategies for fault tolerance, redundancy, and high availability. Choose the Right Tools: Understand when to use SQL vs. NoSQL, caching strategies, and message queues. Model with Sruja: Learn how to use the Sruja architecture language to document and visualize your designs effectively. Course Modules# Module 1: Fundamentals Core concepts including Scalability, Availability, and the CAP Theorem. Module 2: Building Blocks Deep dive into Load Balancers, Databases, Caching, and Queues. Module 3: Advanced Modeling Patterns for Microservices, Event-Driven Architecture, and more. Module 4: Production Readiness Observability, Security, and Deployment strategies. Prerequisites# Basic understanding of computer science fundamentals (networking, databases, OS). Familiarity with at least one programming language. Curiosity to learn how massive systems like Google, Facebook, and Netflix are built. "},{"id":41,"href":"/docs/concepts/metadata-and-tags/","title":"Metadata \u0026 Tags","section":"Core Concepts","content":"Metadata \u0026amp; Tags# Sruja allows you to attach additional information to your elements using Metadata and Tags.\nTags# Tags are simple string labels that can be used for filtering, styling, or categorization.\nSyntax# tags [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;]Metadata# Metadata allows you to attach key-value pairs to elements. This is useful for storing information like team ownership, cost centers, links to other docs, etc.\nSyntax# system API \u0026#34;API\u0026#34; { metadata { owner: \u0026#34;Team A\u0026#34; tier: \u0026#34;1\u0026#34; } }Technology# Most elements (Container, Component, etc.) support a technology field to specify the tech stack.\nSyntax# metadata { key: \u0026#34;value\u0026#34; }"},{"id":42,"href":"/courses/system-design-201/","title":"System Design 201: Real-World Architectures","section":"Courses","content":"System Design 201: Real-World Architectures# Welcome to System Design 201. In this course, we move from theory to practice. We will take the building blocks you learned in System Design 101 and use them to architect complete, production-ready systems.\nWhat You Will Build# High-Throughput Systems: A URL Shortener and a Rate Limiter. Real-Time Systems: A Chat Application like WhatsApp. Data-Intensive Systems: A Video Streaming Service like YouTube. Distributed Consistency: A Distributed Counter. Prerequisites# Completion of System Design 101 (or equivalent knowledge). Understanding of basic components: Load Balancers, Databases, Caching, Queues. "},{"id":43,"href":"/docs/examples/","title":"Examples","section":"Introduction","content":"Examples# Here are some complete examples of Sruja models. You can edit and run them directly in the playground.\nBanking System# A simplified version of the C4 model banking system example.\narchitecture \u0026#34;Banking System\u0026#34; { system BankingSystem \u0026#34;Internet Banking System\u0026#34; { description \u0026#34;Allows customers to view accounts and make payments.\u0026#34; container WebApp \u0026#34;Web Application\u0026#34; { technology \u0026#34;Java and Spring MVC\u0026#34; description \u0026#34;Delivers the static content and the Internet banking single page application.\u0026#34; } container Database \u0026#34;Database\u0026#34; { technology \u0026#34;Oracle Database\u0026#34; description \u0026#34;Stores user registration information, hashed credentials, etc.\u0026#34; } WebApp -\u0026gt; Database \u0026#34;Reads from and writes to\u0026#34; } person Customer \u0026#34;Personal Banking Customer\u0026#34; { description \u0026#34;A customer of the bank, with personal bank accounts.\u0026#34; } Customer -\u0026gt; WebApp \u0026#34;Visits\u0026#34; }Microservices# An example showing a microservices architecture.\narchitecture \u0026#34;E-Commerce\u0026#34; { system Shop \u0026#34;Online Shop\u0026#34; { container Frontend \u0026#34;Storefront\u0026#34; { technology \u0026#34;Next.js\u0026#34; } container Catalog \u0026#34;Catalog Service\u0026#34; { technology \u0026#34;Go\u0026#34; } container Orders \u0026#34;Order Service\u0026#34; { technology \u0026#34;Java\u0026#34; } datastore DB \u0026#34;Main DB\u0026#34; { technology \u0026#34;PostgreSQL\u0026#34; } Frontend -\u0026gt; Catalog \u0026#34;Browses items\u0026#34; Frontend -\u0026gt; Orders \u0026#34;Places orders\u0026#34; Catalog -\u0026gt; DB \u0026#34;Reads products\u0026#34; Orders -\u0026gt; DB \u0026#34;Writes orders\u0026#34; } person Shopper \u0026#34;Shopper\u0026#34; Shopper -\u0026gt; Frontend \u0026#34;Browses and buys\u0026#34; }"},{"id":44,"href":"/blogs/","title":"Blog","section":"Home","content":"Blog# Stay updated with the latest news, releases, and articles about Sruja.\nNo posts yet.\n"},{"id":45,"href":"/courses/","title":"Courses","section":"Home","content":"Available Courses# Explore our comprehensive courses to master software architecture with Sruja.\nüéì System Design 101 Master the C4 Model with Sruja. A complete guide to designing scalable systems.\nüèóÔ∏è System Design 201 Real-World Architectures. Design TinyURL, WhatsApp, Netflix, and more.\n"},{"id":46,"href":"/docs/","title":"Introduction","section":"Home","content":"Sruja: Architecture as Code# Sruja is a modern, developer-friendly language for defining software architecture. It allows you to describe your systems, containers, and components using a clean, C4-model-based DSL, and then generate diagrams, documentation, and more.\nWhy Sruja?# Code-First# Treat your architecture like code. Version control it, review it, and evolve it. Sruja files are plain text, making them easy to diff and merge. This allows you to integrate architectural decision-making into your existing development workflows (Pull Requests, Code Reviews).\nC4 Model# Built-in support for the C4 model (System, Container, Component) ensures a standardized way to describe software. You don\u0026rsquo;t need to invent your own boxes and arrows; Sruja provides the primitives you need to describe software systems at different levels of abstraction.\nDiagrams as Code# Generate beautiful diagrams (via D2) automatically from your model. No more dragging boxes around in Visio or Lucidchart. When your code changes, your diagrams update automatically. This ensures your documentation never goes stale.\nValidation# Ensure your architecture follows best practices with built-in validation rules. Sruja can check for things like:\nOrphaned elements (defined but not connected). Circular dependencies. Missing descriptions or technology tags. Compliance with architectural policies. Key Features# Simple DSL# The Sruja DSL is designed to be easy to read and write. It uses a familiar C-style syntax with braces for grouping.\nsystem \u0026#34;MySystem\u0026#34; { container \u0026#34;WebApp\u0026#34; { technology \u0026#34;Go\u0026#34; } }D2 Export# Sruja exports directly to D2, a modern diagram scripting language. D2 handles the layout and routing, producing high-quality SVG diagrams that look professional and are easy to read.\nValidation Engine# Catch architectural smells early. The validation engine runs every time you build or check your model, providing immediate feedback on the health of your architecture.\nExtensible# Built for the future. Sruja is designed to be extensible, allowing for new export formats, custom validation rules, and integration with other tools in your ecosystem.\nGetting Started# Ready to dive in? Check out the Getting Started guide to install Sruja and build your first model.\nCommunity# Join the community to discuss architecture, share models, and contribute to Sruja.\n"},{"id":47,"href":"/tutorials/","title":"Tutorials","section":"Home","content":"Tutorials# Step-by-step guides to help you master Sruja.\nBasics# Getting Started More tutorials coming soon.\n"}]