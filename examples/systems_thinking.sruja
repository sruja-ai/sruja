architecture "Systems Thinking Example" {
    // ============================================================================
    // 1. PARTS AND RELATIONSHIPS
    // ============================================================================
    // Systems thinking starts with understanding how components connect and interact
    
    person Customer "End User"
    person Admin "System Administrator"
    
    system ECommerce "E-Commerce System" {
        container WebApp "Web Application" {
            technology "React"
        }
        
        container API "API Service" {
            technology "Go"
        }
        
        container Database "PostgreSQL Database" {
            technology "PostgreSQL 14"
        }
    }
    
    // Events show what happens in the system (declared at architecture level via context)
    // Events show what happens in the system (declared at architecture level via context)
    // context Events {
    //     event OrderPlaced {
    //         orderId string
    //         customerId string
    //         total float
    //     }
    //     
    //     event PaymentProcessed {
    //         orderId string
    //         amount float
    //         status string
    //     }
    // }
    
    system PaymentGateway "Third-party Payment Service" {
        metadata {
            tags ["external"]
        }
    }
    
    // Relationships show how parts interact
    Customer -> WebApp "Uses"
    WebApp -> API "Calls"
    API -> Database "Reads/Writes"
    API -> PaymentGateway "Processes payments"
    
    // ============================================================================
    // 2. BOUNDARIES
    // ============================================================================
    // system defines what's inside, person and external define what's outside
    
    // Inside boundary: ECommerce system contains WebApp, API, Database
    // Outside boundary: Customer, Admin, PaymentGateway are external
    
    // ============================================================================
    // 3. FLOWS
    // ============================================================================
    // Flows show how information/data moves through the system
    
    // Data Flow Diagram (DFD) style
    // Data Flow Diagram (DFD) style
    // flow OrderProcess "Order Processing Flow" {
    //     Customer -> WebApp "Submits Order"
    //     WebApp -> API "Sends Order Data"
    //     API -> Database "Saves Order"
    //     API -> PaymentGateway "Charges Payment"
    //     PaymentGateway -> API "Returns Confirmation"
    //     API -> Database "Updates Order Status"
    //     API -> WebApp "Returns Result"
    //     WebApp -> Customer "Shows Confirmation"
    // }
    
    // User Story/Scenario style
    // User Story/Scenario style
    // story Checkout "User Checkout Flow" {
    //     Customer -> "Cart Page" "adds items to cart"
    //     "Cart Page" -> WebApp "clicks checkout"
    //     WebApp -> API "validates cart"
    //     API -> Database "checks inventory"
    //     Database -> API "returns stock status"
    //     API -> PaymentGateway "processes payment"
    //     PaymentGateway -> API "confirms payment"
    //     API -> Database "creates order"
    //     API -> WebApp "returns order confirmation"
    //     WebApp -> Customer "displays success message"
    // }
    
    // Simple relationship flow (unidirectional to avoid cycles)
    Customer -> WebApp "Browses Products"
    WebApp -> API "Fetches Products"
    API -> Database "Queries Products"
    
    // ============================================================================
    // 4. FEEDBACK LOOPS
    // ============================================================================
    // Feedback loops show how actions create reactions
    
    // Simple feedback: User action triggers system response
    // Cycles are valid - this is a natural feedback loop
    Customer -> WebApp "Submits Form"
    WebApp -> API "Validates"
    API -> WebApp "Returns Validation Result"
    WebApp -> Customer "Shows Feedback"
    // The feedback affects customer's next action (feedback loop)
    
    // System feedback: Component A affects Component B, which affects A
    // Cycles are valid - this models event-driven or mutual dependency patterns
    API -> Database "Updates Inventory"
    Database -> API "Notifies Low Stock"
    API -> Admin "Sends Alert"
    Admin -> API "Adjusts Inventory"
    // This creates a feedback loop: API <-> Database <-> Admin
    // Cycles are natural in event-driven architectures and mutual dependencies
    
    // ============================================================================
    // 5. CONTEXT
    // ============================================================================
    // Context shows the environment the system operates in
    
    // Additional persons for context
    person Support "Customer Support"
    
    // Additional external systems show what the system depends on
    system EmailService "Email Notifications" {
        metadata {
            tags ["external"]
        }
    }
    
    system AnalyticsService "Usage Analytics" {
        metadata {
            tags ["external"]
        }
    }
    
    // Relationships show context interactions
    Customer -> ECommerce "Uses"
    Admin -> ECommerce "Manages"
    Support -> ECommerce "Monitors"
    ECommerce -> PaymentGateway "Depends on"
    ECommerce -> EmailService "Sends notifications"
    ECommerce -> AnalyticsService "Tracks usage"
    
    // ============================================================================
    // REQUIREMENTS AND ADRs
    // ============================================================================
    
    requirement R1 functional "System must handle 10k concurrent users"
    requirement R2 constraint "Must use PostgreSQL for data persistence"
    requirement R3 performance "API response time must be < 100ms"
    
    adr ADR001 "Use microservices architecture for scalability"
    adr ADR002 "Use PostgreSQL for strong consistency requirements"
}
