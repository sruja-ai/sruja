// examples/real_world_implied_relationships.sruja
// Real-world example: Microservices E-commerce Platform
// Demonstrates how implied relationships reduce boilerplate in complex architectures

architecture "Microservices E-commerce Platform" {
  // External actors
  person Customer "Customer"
  person Admin "Administrator"
  person SupportAgent "Support Agent"
  
  // Main system with multiple services
  system ECommerce "E-Commerce Platform" {
    // Frontend services
    container WebApp "Web Application" {
      technology "React, TypeScript"
      component ProductCatalog "Product Catalog"
      component ShoppingCart "Shopping Cart"
      component Checkout "Checkout Flow"
    }
    
    container MobileApp "Mobile Application" {
      technology "React Native"
      component ProductBrowser "Product Browser"
      component CartManager "Cart Manager"
    }
    
    // Backend services
    container ProductService "Product Service" {
      technology "Go, gRPC"
      component ProductAPI "Product API"
      component SearchEngine "Search Engine"
    }
    
    container OrderService "Order Service" {
      technology "Java, Spring Boot"
      component OrderAPI "Order API"
      component OrderProcessor "Order Processor"
    }
    
    container PaymentService "Payment Service" {
      technology "Node.js, Express"
      component PaymentAPI "Payment API"
      component PaymentGateway "Payment Gateway"
    }
    
    container UserService "User Service" {
      technology "Python, FastAPI"
      component AuthAPI "Authentication API"
      component ProfileAPI "Profile API"
    }
    
    // Data stores
    datastore ProductDB "Product Database" {
      technology "PostgreSQL"
    }
    
    datastore OrderDB "Order Database" {
      technology "PostgreSQL"
    }
    
    datastore UserDB "User Database" {
      technology "MongoDB"
    }
    
    datastore Cache "Redis Cache" {
      technology "Redis"
    }
    
    // Message queue
    queue EventQueue "Event Queue" {
      technology "Kafka"
    }
  }
  
  // External services
  system PaymentProvider "Payment Provider" {
    metadata {
      tags ["external"]
    }
  }
  
  system EmailService "Email Service" {
    metadata {
      tags ["external"]
    }
  }
  
  system AnalyticsService "Analytics Service" {
    metadata {
      tags ["external"]
    }
  }
  
  // Relationships - With implied relationships, we only need to define
  // relationships to specific containers/components, and parent relationships
  // are automatically inferred
  
  // Customer interactions - only define specific container relationships
  Customer -> ECommerce.WebApp "Browses products"
  Customer -> ECommerce.WebApp.ProductCatalog "Views products"
  Customer -> ECommerce.WebApp.ShoppingCart "Adds items"
  Customer -> ECommerce.WebApp.Checkout "Completes purchase"
  Customer -> ECommerce.MobileApp "Uses mobile app"
  
  // Service-to-service communication
  ECommerce.WebApp -> ECommerce.ProductService "Fetches products"
  ECommerce.WebApp -> ECommerce.OrderService "Creates orders"
  ECommerce.WebApp -> ECommerce.PaymentService "Processes payments"
  ECommerce.WebApp -> ECommerce.UserService "Authenticates users"
  
  ECommerce.MobileApp -> ECommerce.ProductService "Fetches products"
  ECommerce.MobileApp -> ECommerce.OrderService "Creates orders"
  
  // Service to database relationships
  ECommerce.ProductService -> ECommerce.ProductDB "Reads/Writes"
  ECommerce.ProductService -> ECommerce.Cache "Caches products"
  ECommerce.OrderService -> ECommerce.OrderDB "Reads/Writes"
  ECommerce.UserService -> ECommerce.UserDB "Reads/Writes"
  
  // Event-driven communication
  ECommerce.OrderService -> ECommerce.EventQueue "Publishes order events"
  ECommerce.PaymentService -> ECommerce.EventQueue "Publishes payment events"
  
  // External service integrations
  ECommerce.PaymentService -> PaymentProvider "Processes payments"
  ECommerce.OrderService -> EmailService "Sends order confirmations"
  ECommerce.UserService -> EmailService "Sends verification emails"
  ECommerce.WebApp -> AnalyticsService "Tracks user behavior"
  
  // Admin and support interactions
  Admin -> ECommerce.OrderService "Manages orders"
  Admin -> ECommerce.ProductService "Manages products"
  SupportAgent -> ECommerce.OrderService "Views order details"
  SupportAgent -> ECommerce.UserService "Views user profiles"
  
  // The following relationships are automatically inferred:
  //   Customer -> ECommerce (from Customer -> ECommerce.WebApp.*)
  //   Customer -> ECommerce (from Customer -> ECommerce.MobileApp)
  //   ECommerce.WebApp -> ECommerce (from ECommerce.WebApp -> ECommerce.*Service)
  //   ECommerce.ProductService -> ECommerce (from ECommerce.ProductService -> ECommerce.ProductDB)
  //   Admin -> ECommerce (from Admin -> ECommerce.OrderService)
  //   SupportAgent -> ECommerce (from SupportAgent -> ECommerce.*Service)
  //   ECommerce -> PaymentProvider (from ECommerce.PaymentService -> PaymentProvider)
  //   ECommerce -> EmailService (from ECommerce.*Service -> EmailService)
  //   ECommerce -> AnalyticsService (from ECommerce.WebApp -> AnalyticsService)
  
  requirement R1 functional "Must handle 100k concurrent users"
  requirement R2 performance "API response time < 200ms (p95)"
  requirement R3 availability "99.9% uptime SLA"
  requirement R4 security "PCI-DSS compliant for payment processing"
  
  adr ADR001 "Microservices Architecture" {
    status "accepted"
    context "Need independent scaling and deployment"
    decision "Adopt microservices architecture with service mesh"
    consequences "Gain: Independent scaling, deployment. Trade-off: Increased complexity, network latency"
  }
  
  adr ADR002 "Event-Driven Communication" {
    status "accepted"
    context "Services need to communicate asynchronously"
    decision "Use Kafka for event streaming"
    consequences "Gain: Loose coupling, scalability. Trade-off: Eventual consistency, complexity"
  }
}
