# Architecture Contract Testing Engine (ACTE)

**Status**: Advanced Engine  
**Pillars**: Operational Excellence

[â† Back to Engines](../README.md)

## Overview

The Architecture Contract Testing Engine (ACTE) automatically generates, validates, and enforces contracts between services, APIs, events, and user journeys â€” ensuring that architecture models match real implementations.

**This eliminates "integration hell" and matches enterprise contract-testing needs (Pact, schema registry, etc.) but driven by architecture DSL instead of manual definitions.**

## Purpose

ACTE ensures:

- âœ… API contracts are validated
- âœ… Event schemas are compatible
- âœ… Service interactions match architecture
- âœ… Domain policies are validated
- âœ… End-to-end behavior matches modeled flows
- âœ… Breaking changes are caught early

## What ACTE Tests

### API Contract Tests
- HTTP routes
- gRPC endpoints
- GraphQL schema
- Event payload schemas
- Request/response properties
- Status codes
- Error objects
- Authentication + authorization contracts

### Schema Compatibility Tests
- backward compatibility
- forward compatibility
- strict type checking
- enumeration and constraints
- optional vs required fields
- JSON Schema evolution

### Service Interaction Tests
Derived from architecture model:

- allowed dependencies
- forbidden dependencies
- call direction
- sync vs async constraints
- max fan-out rules
- call frequency limits (contracts + SLOs)

### Event-Driven System Tests
Validates:

- event names
- payload structure
- topic naming conventions
- producer/consumer matching
- ordering policies
- idempotency guarantees

### Domain-Level Tests
- bounded context integrity
- domain isolation
- cross-domain communication contracts
- domain ownership resolution

### Behavior Contract Tests (from User Journeys)
- sequences of calls
- expected data flow
- fallback behavior
- retries
- alternative paths
- error handling paths

## Inputs to the Engine

ACTE consumes:

### Architecture DSL (model â†’ IR)
Defines:

- services
- APIs
- events
- schemas
- dependencies
- domains
- bounded contexts
- user flows

### Source Code (optional)
Extracts:

- TypeScript/Java DTOs
- OpenAPI specs
- GraphQL SDL
- Protobuf declarations
- test fixtures

Extraction is done via:

- static analysis
- annotation parsing
- reflection metadata (optional)

### Runtime Observability Data (optional)
- traces
- span schemas
- endpoints seen in real traffic
- event payloads

Used for drift-based testing.

## Outputs of the Engine

### Test Artifacts
Generated:

- API contract tests
- schema compatibility tests
- interaction tests
- event tests
- sequence tests
- resilience behavior tests

### Test Results
With:

- diffs
- violations
- breaking-change alerts
- recommendations

### API Docs
Autogenerated OpenAPI/GraphQL schemas if missing.

### Integration Test Runner
Local or CI runnable.

## Architecture

```
ArchitectureContractTestingEngine
 â”œâ”€â”€ ContractExtractor
 â”œâ”€â”€ ContractCompiler
 â”œâ”€â”€ InteractionMatrixBuilder
 â”œâ”€â”€ SchemaDefinitionBuilder
 â”œâ”€â”€ SchemaComparator
 â”œâ”€â”€ APIStubGenerator
 â”œâ”€â”€ PactGenerator
 â”œâ”€â”€ EventContractTester
 â”œâ”€â”€ UserJourneyTester
 â”œâ”€â”€ CompatibilityChecker
 â”œâ”€â”€ TestRunner
 â”œâ”€â”€ ReportGenerator
 â”œâ”€â”€ MCP Server
 â””â”€â”€ CI/CD Integrator
```

## Test Generation Pipeline

### Step 1 â€” Contract Extraction
From code + architecture model:

- API signatures
- message schemas
- event definitions
- expected flows

### Step 2 â€” Build Interaction Matrix
Matrix format:

```
Service â†’ Service
Allowed?
Type?
Sync/Async?
Expected Schema?
Policy Constraints?
```

### Step 3 â€” Generate Tests
Types:

- API request/response tests
- service-to-service contract tests
- event producer/consumer tests
- journey sequence tests

### Step 4 â€” Auto-Stubbing
Generates:

- mock services
- mock endpoints
- mock event producers

### Step 5 â€” Run Tests in CI
Fail if:

- breaking change
- schema mismatch
- unmodeled API
- unexpected dependency

### Step 6 â€” Publish Results
Into:

- Review engine
- Drift engine
- Simulation engine
- Knowledge graph

## MCP API

```
contract.extract(service)
contract.generateTests(service)
contract.run(service)
contract.diff(service, versionA, versionB)
contract.listViolations()
contract.explain(violationId)
contract.compatibilityCheck(schemaA, schemaB)
contract.simulateInteraction(source, target)
```

## UI Features

### Contract Health Dashboard
Visualize:

- API completeness
- schema drift
- interaction violations

### Test Suite Viewer
Browse generated tests + results.

### Interaction Graph Overlay
Highlight invalid links.

### Schema Diff Viewer
Beautiful diff for:

- JSON
- Protobuf
- GraphQL
- OpenAPI

### Journey Contract Tester
Visual sequence comparison:

- expected vs actual

## Implementation Phases

### Phase 1 â€” Core Extractors
- API extractor
- schema extractor
- dependency extractor

### Phase 2 â€” Contract Compiler + Matrix
- unify code + model
- build interaction matrix

### Phase 3 â€” Test Generators
- OpenAPI tests
- event tests
- schema compat tests

### Phase 4 â€” CI/CD Integration
- GitHub Actions
- GitLab CI
- local testing CLI

### Phase 5 â€” UI + MCP
- results viewer
- violations overlay

### Phase 6 â€” AI Contract Reviewer
(optional)
- AI suggests fixes
- auto-generate ADR for contract change

## Value

- âœ… Eliminates integration failures
- âœ… Prevents breaking changes
- âœ… Guarantees architecture accuracy
- âœ… Strengthens domain boundaries
- âœ… Ensures reliable communication patterns
- âœ… Keeps schemas consistent across teams
- âœ… Enables safe, contract-first development
- âœ… Provides automatic documentation

**This module makes your platform production-grade for large-scale distributed systems.**

## Implementation Status

âœ… Architecture designed  
âœ… Test types specified  
âœ… Pipeline defined  
ğŸ“‹ Implementation in progress

---

*ACTE ensures architecture models match real implementations through automated contract testing.*

