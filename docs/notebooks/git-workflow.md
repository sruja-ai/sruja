# Git-Based Review & Approval Workflow

[← Back to Notebooks Index](./README.md)

## Overview

Sruja Architecture Notebooks use **Git as the foundation for architecture governance**, enabling:

- ✅ Architecture as source of truth
- ✅ Notebooks as code
- ✅ Variants as branches
- ✅ Snapshots as commits
- ✅ Code reviews as architecture reviews
- ✅ Git history as architecture evolution
- ✅ PR approvals as architectural approval process

This creates a **scalable, transparent, and enterprise-ready** architecture governance workflow.

## Core Principle

**Yes — the review + approval workflow for Sruja Architecture Notebooks should be built directly on top of Git** because:

- ✅ Architecture = source of truth
- ✅ Notebooks = code
- ✅ Kernels = deterministic
- ✅ Variants = branches
- ✅ Snapshots = commits
- ✅ Code reviews = architecture reviews
- ✅ Git history = architecture evolution
- ✅ PR approvals = architectural approval process

## Architecture Notebooks Live in Git

Each architecture notebook (`*.ipynb`) and dependent files (`.sruja/*`) live in Git.

**Benefits:**

- ✅ Every architecture change is versioned
- ✅ Every change can be diffed
- ✅ Reviewers can comment on each cell
- ✅ Automated checks can block merges
- ✅ Architecture becomes **Architecture-as-Code**

### Repository Structure

```
architecture-repo/
├── notebooks/
│   ├── billing-system.ipynb
│   ├── payment-service.ipynb
│   └── event-schemas.ipynb
├── .sruja/
│   ├── sruja-ir.json        # Architecture IR (auto-generated)
│   ├── snapshots/           # Snapshot history
│   └── config.json
└── README.md
```

## Git Flow: Architecture Edition

A recommended workflow:

```
main (approved architecture)
│
├── feature/auth-service-redesign
│     ├── notebooks/auth-service.ipynb
│     ├── .sruja/snapshot.json
│     ├── .sruja/sruja-ir.json
│     └── diffs, diagrams
│
└── feature/event-versioning-v2
      ├── notebooks/payments.ipynb
      └── ...
```

Each branch maps to:

- A **variant**
- A **proposal**
- A **change request**

### Branch Naming Conventions

- `feature/` - New features or components
- `refactor/` - Architecture refactoring
- `fix/` - Bug fixes in architecture
- `experiment/` - Experimental variants

## Architectural Review Cycle

### Step 1: Engineer/Architect Creates a Branch

```bash
git checkout -b feature/billing-redesign
```

Creates:

- New notebook cells
- Updated DSL
- Updated IR
- New diagrams
- Validation results

### Step 2: Sruja Kernel Validates Changes

Running notebook executes all cells → kernel ensures:

- ✅ Correctness
- ✅ Rule compliance
- ✅ Contract safety
- ✅ Event flow consistency
- ✅ Diagram validity
- ✅ No broken dependencies

**If invalid → change cannot move forward.**

### Step 3: Architect Pushes Branch

```bash
git add .
git commit -m "Billing redesign, async event flow"
git push origin feature/billing-redesign
```

### Step 4: GitHub/GitLab PR Becomes Architecture Review Document

PR contains:

- ✅ **Notebook diff** - Cell-by-cell changes
- ✅ **JSON IR diff** - Architecture model changes
- ✅ **Diagrams diff** - SVG or Mermaid changes
- ✅ **Snapshot comparison** - Before/after state
- ✅ **Variant differences** - Changes from base
- ✅ **Validation diagnostics** - Errors and warnings
- ✅ **Summary of changes** - Generated by CI

This PR is effectively a **structured architecture decision proposal**.

### Step 5: Reviewers Comment & Approve

Reviewers can comment:

- ✅ Inline on notebook cells
- ✅ On diagrams
- ✅ On IR changes
- ✅ On event flows
- ✅ On contract diffs
- ✅ On variants

Your repo becomes a **living architecture discussion forum**.

## CI/CD: Automated Architecture Checks

Before merging, CI runs automated checks:

### Validation Checks

```yaml
# .github/workflows/architecture-review.yml
- name: Validate Architecture
  run: |
    sruja kernel validate --notebook notebooks/*.ipynb
```

**Checks:**
- ✅ No broken systems
- ✅ No invalid event flows
- ✅ No invalid transitions
- ✅ No contract compatibility issues
- ✅ No missing components
- ✅ No orphan entities
- ✅ No code-architecture drift (via MCP code checks)

### Diff Generation

```yaml
- name: Generate Architecture Diff
  run: |
    sruja kernel diff --base main --head $PR_BRANCH
```

**Generates:**
- Change diagrams
- Side-by-side IR diff
- Summary of breaking changes

### Approval Requirements

```yaml
- name: Check Approval Requirements
  run: |
    sruja kernel approval-required --base main --head $PR_BRANCH
```

**Examples:**
- Event version change → requires domain architect approval
- System boundary refactor → requires platform architect approval
- New data fields w/ PII → requires security approval

**CI produces:**
```
failing: approval_required: security-architect
```

GitHub CODEOWNERS + Sruja rules ensure correct sign-off.

## Approval Rules (Automated)

Sruja Kernel can enforce approval using policies and rules.

### Policy DSL Example

```sruja
policy "PII changes require approval" {
  applies_to: field where metadata.pii = true
  require_approval: "security_team"
}

policy "System boundary changes require approval" {
  applies_to: system.boundary
  require_approval: "platform_architect"
}
```

### Rule DSL Example

```sruja
rule pii_changes {
  when: entity.field.pii_changed
  then: require_approval("security_team")
}

rule breaking_contract_changes {
  when: contract.breaking_change
  then: require_approval("domain_architect")
}
```

**These rules run in CI.** If approval is missing → PR blocked.

## Notebooks as Decision Records

Each merged notebook change:

- ✅ Becomes an ADR (Architecture Decision Record)
- ✅ Retains full conversational history inside notebook
- ✅ Contains diagrams, validators, snapshots
- ✅ Is versioned

**You get full traceability:**

- Who approved
- Which snapshot
- Which variant became main
- Why decisions were made
- How the architecture evolved

### ADR Format

Notebooks can include ADR cells:

```markdown
## ADR-001: Async Payment Processing

**Status:** Approved
**Deciders:** @platform-team, @payment-team
**Date:** 2024-01-01

### Context
...

### Decision
...

### Consequences
...
```

## Variant Support via Git Branches

Variants are modeled in Sruja Kernel, but stored using Git branches.

**Mapping:**

| Sruja Concept | Git Concept     |
|---------------|-----------------|
| Variant       | Feature branch  |
| Snapshot      | Commit          |
| Merge variant | Merge PR        |
| Freeze variant| Tag             |
| Experiment    | Draft PR        |

This keeps the architecture workflow **identical to code workflow**.

### Creating a Variant

```bash
# Create branch (variant)
git checkout -b feature/async-payments

# Make changes in notebook
# ... edit notebooks/payments.ipynb ...

# Commit snapshot
git commit -m "Create async payments variant"

# Push for review
git push origin feature/async-payments
```

### Merging a Variant

```bash
# Merge via PR (same as code)
git checkout main
git merge feature/async-payments
```

The kernel automatically reconciles variants during merge.

## Line-by-Line Notebook Diff

GitHub, GitLab, VS Code, Cursor can show:

- ✅ Cell content diffs
- ✅ JSON IR diff (`sruja-ir.json`)
- ✅ Diagram diffs (SVG diffing)
- ✅ Rule changes
- ✅ Event version changes

**Cursor AI can even summarize the diffs.**

### Diff View Example

```
diff --git a/notebooks/payments.ipynb b/notebooks/payments.ipynb

@@ Cell 5 @@
-system Payment {
+system PaymentV2 {
   container PaymentAPI {
+    component AsyncProcessor {
+      api POST /payments/async
+    }
   }
 }
```

### IR Diff

```
diff --git a/.sruja/sruja-ir.json b/.sruja/sruja-ir.json

@@ -10,6 +10,15 @@
     "components": [
+      {
+        "id": "AsyncProcessor",
+        "name": "AsyncProcessor",
+        "technology": "Go"
+      }
     ]
   }
 }
```

## AI-Assisted Review Using Cursor

Reviewers can say:

> "Summarize all architectural changes in this PR."

**Cursor reads:**
- Notebook changes
- IR diff
- Diagrams
- Diagnostics
- Patches

**Produces:**
- High-level summary
- Risk analysis
- Compliance checks
- Improvement suggestions

**Reviewers do less manual work.**

### Cursor Integration

Cursor AI can:

1. **Summarize PR changes**
   ```
   "What changed in this architecture PR?"
   ```

2. **Identify risks**
   ```
   "Are there any breaking changes?"
   ```

3. **Check compliance**
   ```
   "Does this meet our security policies?"
   ```

4. **Suggest improvements**
   ```
   "How can we improve this design?"
   ```

## Approval Triggers (Automated)

Policies can define approval tiers:

1. **Team approval**
2. **Domain architect approval**
3. **Security architect approval**
4. **CTO approval**
5. **Compliance approval**

**Sruja Kernel evaluates policies, and CI enforces.**

### Examples

```
field customerEmail changed → requires SecurityTeam
event PaymentAuthorized updated → requires DomainOwnerPayments
system APIGateway boundary changed → requires PlatformTeamLead
```

**GitHub CODEOWNERS can enforce these automatically:**

```gitattributes
# CODEOWNERS
*.ipynb                                    @architecture-team
.sruja/sruja-ir.json                       @architecture-team
notebooks/billing-system.ipynb             @billing-team @security-team
notebooks/payment-service.ipynb            @payment-team @platform-team
```

## CI/CD Pipeline Example

Complete GitHub Actions workflow:

```yaml
name: Architecture Review

on:
  pull_request:
    paths:
      - 'notebooks/**'
      - '.sruja/**'

jobs:
  architecture-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2

      - name: Setup Sruja Kernel
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Validate Architecture
        run: |
          sruja kernel validate --notebook notebooks/*.ipynb

      - name: Generate Diff
        run: |
          sruja kernel diff \
            --base ${{ github.base_ref }} \
            --head ${{ github.head_ref }} \
            --output diff-report.json

      - name: Check Approval Requirements
        run: |
          sruja kernel approval-required \
            --base ${{ github.base_ref }} \
            --head ${{ github.head_ref }} \
            --output approvals.json

      - name: Comment PR
        uses: actions/github-script@v6
        with:
          script: |
            const diff = require('./diff-report.json');
            const approvals = require('./approvals.json');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Architecture Review\n\n${diff.summary}\n\n**Required Approvals:**\n${approvals.map(a => `- ${a}`).join('\n')}`
            });

      - name: Block on Missing Approvals
        if: failure()
        run: |
          echo "PR blocked: Missing required approvals"
          exit 1
```

## Summary

**Yes — Sruja Architecture Notebooks stored in Git enable a complete, automated architecture review & approval workflow.**

### Key Benefits

- ✅ **Architectural changes = PRs**
- ✅ **Validation = CI**
- ✅ **Approvals = CODEOWNERS + Sruja Policy**
- ✅ **Diff = IR diff + diagram diff**
- ✅ **Discussion = PR comments + inline cell comments**
- ✅ **Traceability = Git history + snapshots**
- ✅ **Automation = Sruja Kernel + MCP Tools**
- ✅ **AI assistance = Cursor AI**

### Result

This creates a **world-class, fully-governed Architecture-as-Code workflow** that:

- Scales to enterprise teams
- Maintains full audit trail
- Enforces compliance automatically
- Integrates with existing Git workflows
- Provides rich review experience
- Leverages AI for better reviews

## Integration with Existing Engines

The Git-based workflow integrates with Sruja's existing engines:

- **[Architecture Governance Engine](../../pillars/engines/cross-pillar/architecture-governance-engine.md)** - Policy enforcement and governance rules
- **[Change Approval Engine](../../pillars/engines/cross-pillar/change-approval-engine.md)** - Structured approval workflows
- **[AI-Guided Architecture Review Engine](../../pillars/engines/cross-pillar/ai-architecture-review-engine.md)** - Automated architecture reviews

The notebook workflow provides the **Git-based execution layer** for these engines, enabling:

- ✅ Git-native approval workflows
- ✅ PR-based review processes
- ✅ CI/CD integration
- ✅ Automated policy enforcement

## Next Steps

- [Notebook Overview](./overview.md) - Learn about notebooks
- [Architecture Kernel](./kernel.md) - Kernel capabilities
- [Cursor AI Integration](./cursor-ai-integration.md) - AI-assisted workflows

