package markdown

import (
	"fmt"
	"strings"

	"github.com/sruja-ai/sruja/pkg/language"
)

func (e *Exporter) writeTOC(sb *strings.Builder, arch interface{}, prog *language.Program) {
	sb.WriteString("## Table of Contents\n\n")
	sb.WriteString("- [Executive Summary](#executive-summary)\n")
	if e.Options.IncludeMetadata {
		sb.WriteString("- [Document Metadata](#document-metadata)\n")
	}
	sb.WriteString("- [Summary Statistics](#summary-statistics)\n")
	if e.Options.IncludeOverview {
		sb.WriteString("- [Architecture Overview](#architecture-overview)\n")
	}
	if e.Options.IncludeSystems {
		sb.WriteString("- [Technology Stack Summary](#technology-stack-summary)\n")
	}
	archStruct := arch.(*struct {
		Name         string
		Description  *string
		Systems      []*language.System
		Persons      []*language.Person
		Requirements []*language.Requirement
		ADRs         []*language.ADR
	})
	if len(archStruct.Systems) > 0 {
		sb.WriteString("- [System Architecture](#system-architecture)\n")
	}
	if len(archStruct.Persons) > 0 {
		sb.WriteString("- [Actors and User Roles](#actors-and-user-roles)\n")
	}
	if len(archStruct.Requirements) > 0 {
		sb.WriteString("- [Functional Requirements](#functional-requirements)\n")
	}
	if len(archStruct.ADRs) > 0 {
		sb.WriteString("- [Architecture Decision Records](#architecture-decision-records)\n")
	}
	if e.Options.IncludeScenarios {
		scenarios, flows := extractScenariosAndFlowsFromModel(prog)
		if len(scenarios) > 0 || len(flows) > 0 {
			sb.WriteString("- [User Scenarios and Data Flows](#user-scenarios-and-data-flows)\n")
		}
	}
	if e.Options.IncludeGlossary {
		sb.WriteString("- [Glossary](#glossary)\n")
	}
	if e.Options.IncludeRecommendations {
		sb.WriteString("- [Recommendations and Best Practices](#recommendations-and-best-practices)\n")
	}
	sb.WriteString("\n")
}

func (e *Exporter) writeOverview(sb *strings.Builder, prog *language.Program) {
	sb.WriteString("## Architecture Overview\n\n")
	sb.WriteString("This section provides a high-level view of the system architecture, showing the relationships between external actors and system components.\n\n")

	// Generate L1 diagram (System Context) - shows persons and systems only
	l1Diagram := e.generateL1Diagram(prog)
	if l1Diagram != "" {
		sb.WriteString("### System Context Diagram (Level 1)\n\n")
		sb.WriteString("The System Context diagram illustrates the system's boundaries and its interactions with external actors and other systems.\n\n")
		sb.WriteString("```mermaid\n")
		sb.WriteString(l1Diagram)
		sb.WriteString("\n```\n\n")
	}
}

// writeMetadata writes document metadata section
func (e *Exporter) writeMetadata(sb *strings.Builder, prog *language.Program) {
	sb.WriteString("## Document Metadata\n\n")
	sb.WriteString("| Property | Value |\n")
	sb.WriteString("|----------|-------|\n")
	sb.WriteString("| Generated by | Sruja Architecture Documentation Generator |\n")
	sb.WriteString("| Export Date | *(Generated at export time)* |\n")
	sb.WriteString("| Format Version | 1.0 |\n")
	if prog != nil && prog.Model != nil {
		fileCount := 0
		if prog.Model.Pos.Filename != "" {
			fileCount = 1
		}
		fmt.Fprintf(sb, "| Source Files | %d |\n", fileCount)
	}
	sb.WriteString("\n")
}

// writeSummaryStatistics writes summary statistics section
func (e *Exporter) writeSummaryStatistics(sb *strings.Builder, systems []*language.System,
	persons []*language.Person, requirements []*language.Requirement,
	adrs []*language.ADR, prog *language.Program) {
	sb.WriteString("## Summary Statistics\n\n")

	// Count containers, components, data stores, queues
	totalContainers := 0
	totalComponents := 0
	totalDataStores := 0
	totalQueues := 0
	for _, sys := range systems {
		totalContainers += len(sys.Containers)
		totalDataStores += len(sys.DataStores)
		totalQueues += len(sys.Queues)
		for _, cont := range sys.Containers {
			totalComponents += len(cont.Components)
		}
	}

	// Count relations
	relations := extractRelationsFromModel(prog)
	totalRelations := len(relations)

	// Count scenarios and flows
	scenarios, flows := extractScenariosAndFlowsFromModel(prog)
	totalScenarios := len(scenarios)
	totalFlows := len(flows)

	sb.WriteString("| Category | Count |\n")
	sb.WriteString("|----------|-------|\n")
	fmt.Fprintf(sb, "| Systems | %d |\n", len(systems))
	fmt.Fprintf(sb, "| Containers | %d |\n", totalContainers)
	fmt.Fprintf(sb, "| Components | %d |\n", totalComponents)
	fmt.Fprintf(sb, "| Data Stores | %d |\n", totalDataStores)
	fmt.Fprintf(sb, "| Message Queues | %d |\n", totalQueues)
	fmt.Fprintf(sb, "| Actors (Persons) | %d |\n", len(persons))
	fmt.Fprintf(sb, "| Relationships | %d |\n", totalRelations)
	fmt.Fprintf(sb, "| User Scenarios | %d |\n", totalScenarios)
	fmt.Fprintf(sb, "| Data Flows | %d |\n", totalFlows)
	fmt.Fprintf(sb, "| Functional Requirements | %d |\n", len(requirements))
	fmt.Fprintf(sb, "| Architecture Decision Records | %d |\n", len(adrs))
	sb.WriteString("\n")
}

// writeTechnologyStackSummary writes technology stack summary
func (e *Exporter) writeTechnologyStackSummary(sb *strings.Builder, systems []*language.System) {
	techMap := make(map[string][]string) // technology -> []element names

	for _, sys := range systems {
		// Check containers
		for _, cont := range sys.Containers {
			if tech, ok := cont.Properties["technology"]; ok && tech != "" {
				key := fmt.Sprintf("%s.%s", sys.Label, cont.Label)
				techMap[tech] = append(techMap[tech], key)
			}
		}

		// Check data stores
		for _, ds := range sys.DataStores {
			if ds.Technology != nil && *ds.Technology != "" {
				key := fmt.Sprintf("%s.%s", sys.Label, ds.Label)
				techMap[*ds.Technology] = append(techMap[*ds.Technology], key)
			}
		}

		// Check queues
		for _, q := range sys.Queues {
			if q.Technology != nil && *q.Technology != "" {
				key := fmt.Sprintf("%s.%s", sys.Label, q.Label)
				techMap[*q.Technology] = append(techMap[*q.Technology], key)
			}
		}

		// Check components
		for _, cont := range sys.Containers {
			for _, comp := range cont.Components {
				if comp.Technology != nil && *comp.Technology != "" {
					key := fmt.Sprintf("%s.%s.%s", sys.Label, cont.Label, comp.Label)
					techMap[*comp.Technology] = append(techMap[*comp.Technology], key)
				}
			}
		}
	}

	if len(techMap) == 0 {
		return
	}

	sb.WriteString("## Technology Stack Summary\n\n")
	sb.WriteString("This section provides an overview of the technologies used across the architecture.\n\n")
	sb.WriteString("| Technology | Used In |\n")
	sb.WriteString("|------------|----------|\n")

	// Sort technologies alphabetically for consistent output
	techs := make([]string, 0, len(techMap))
	for tech := range techMap {
		techs = append(techs, tech)
	}
	for i := 0; i < len(techs)-1; i++ {
		for j := i + 1; j < len(techs); j++ {
			if techs[i] > techs[j] {
				techs[i], techs[j] = techs[j], techs[i]
			}
		}
	}

	for _, tech := range techs {
		elements := techMap[tech]
		elementsStr := strings.Join(elements, ", ")
		if len(elements) > 3 {
			elementsStr = strings.Join(elements[:3], ", ") + fmt.Sprintf(", ... (%d more)", len(elements)-3)
		}
		fmt.Fprintf(sb, "| **%s** | %s |\n", tech, elementsStr)
	}
	sb.WriteString("\n")
}

// writeGlossary writes glossary section
func (e *Exporter) writeGlossary(sb *strings.Builder, prog *language.Program) {
	// Extract terms from descriptions, titles, and element names
	terms := make(map[string]string)

	if prog == nil || prog.Model == nil {
		return
	}

	// Collect terms from systems
	systems := extractSystemsFromModel(prog)
	for _, sys := range systems {
		if sys.Description != nil {
			extractTermsFromText(*sys.Description, terms)
		}
	}

	// Collect terms from persons
	persons := extractPersonsFromModel(prog)
	for _, p := range persons {
		if p.Description != nil {
			extractTermsFromText(*p.Description, terms)
		}
	}

	// Collect terms from requirements
	requirements := extractRequirementsFromModel(prog)
	for _, req := range requirements {
		if req.Description != nil {
			extractTermsFromText(*req.Description, terms)
		}
	}

	if len(terms) == 0 {
		return
	}

	sb.WriteString("## Glossary\n\n")
	sb.WriteString("This section defines key terms and acronyms used throughout this document.\n\n")

	// Sort terms alphabetically
	termList := make([]string, 0, len(terms))
	for term := range terms {
		termList = append(termList, term)
	}
	for i := 0; i < len(termList)-1; i++ {
		for j := i + 1; j < len(termList); j++ {
			if termList[i] > termList[j] {
				termList[i], termList[j] = termList[j], termList[i]
			}
		}
	}

	for _, term := range termList {
		// Simple glossary format: Term - (Description if we had a dictionary)
		// Since we're just extracting terms, we list them.
		sb.WriteString(fmt.Sprintf("- **%s**\n", term))
	}
	sb.WriteString("\n")
}
