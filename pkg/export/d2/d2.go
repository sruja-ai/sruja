package d2

import (
	"fmt"
	"strings"

	"github.com/sruja-ai/sruja/pkg/language"
)

// Exporter handles exporting Sruja AST to D2 format.
type Exporter struct {
	// Options for export (e.g., styling, layout)
}

// NewExporter creates a new D2 exporter.
func NewExporter() *Exporter {
	return &Exporter{}
}

// Export converts a Sruja architecture to D2 string.
func (e *Exporter) Export(arch *language.Architecture) (string, error) {
	var sb strings.Builder

	// Write header/config
	sb.WriteString("# Generated by Sruja\n")
	sb.WriteString("direction: right\n\n")

	// Check for requirements
	hasRequirements := len(arch.Requirements) > 0
	if !hasRequirements {
		for _, sys := range arch.Systems {
			if len(sys.Requirements) > 0 {
				hasRequirements = true
				break
			}
		}
	}

	// Layers configuration
	hasLayers := hasRequirements || len(arch.Journeys) > 0 || len(arch.Scenarios) > 0
	if hasLayers {
		sb.WriteString("layers: {\n")
		if hasRequirements {
			sb.WriteString("  \"Requirements\"\n")
		}
		for _, j := range arch.Journeys {
			fmt.Fprintf(&sb, "  %s\n", quote(j.Title))
		}
		for _, s := range arch.Scenarios {
			fmt.Fprintf(&sb, "  %s\n", quote(s.Title))
		}
		sb.WriteString("  \"Architecture\"\n")
		sb.WriteString("}\n\n")
	}

	// 1. Systems
	for _, sys := range arch.Systems {
		e.writeSystem(&sb, sys)
	}

	// 2. Persons
	for _, person := range arch.Persons {
		e.writePerson(&sb, person)
	}

	// 3. Relations (Top-level)
	for _, rel := range arch.Relations {
		e.writeRelation(&sb, rel)
	}

	// 4. Deployment Nodes
	for _, node := range arch.DeploymentNodes {
		e.writeDeploymentNode(&sb, node)
	}

	// 5. Requirements (as layer)
	if hasRequirements {
		e.writeRequirementsLayer(&sb, arch)
	}

	// 6. Journeys (as layers)
	for _, j := range arch.Journeys {
		e.writeJourney(&sb, j)
	}

	// 8. Scenarios (as layers)
	for _, s := range arch.Scenarios {
		e.writeScenario(&sb, s)
	}

	// 9. Architecture Layer (Static View)
	if hasLayers {
		sb.WriteString("\"Architecture\": {\n")
		sb.WriteString("  _Title: \"Architecture\" {\n")
		sb.WriteString("    shape: text\n")
		sb.WriteString("    style: {\n")
		sb.WriteString("      font-size: 20\n")
		sb.WriteString("      bold: true\n")
		sb.WriteString("    }\n")
		sb.WriteString("  }\n")
		sb.WriteString("}\n\n")
	}

	return sb.String(), nil
}

func (e *Exporter) writeSystem(sb *strings.Builder, sys *language.System) {
	fmt.Fprintf(sb, "%s: %s {\n", sys.ID, quote(sys.Label))
	sb.WriteString("  shape: package\n")
	if sys.Description != nil {
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(*sys.Description))
	}

	// Containers
	for _, cont := range sys.Containers {
		e.writeContainer(sb, cont)
	}

	// DataStores
	for _, ds := range sys.DataStores {
		e.writeDataStore(sb, ds)
	}

	// Queues
	for _, q := range sys.Queues {
		e.writeQueue(sb, q)
	}

	// Internal Relations
	for _, rel := range sys.Relations {
		e.writeRelation(sb, rel)
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeContainer(sb *strings.Builder, cont *language.Container) {
	fmt.Fprintf(sb, "  %s: %s {\n", cont.ID, quote(cont.Label))
	sb.WriteString("    shape: package\n") // D2 doesn't have explicit container shape, using package
	if cont.Description != nil {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(*cont.Description))
	}

	// Technology as icon or label suffix? For now, just a comment or custom field if D2 supports it
	// D2 supports 'icon' but we need a URL. We can put it in the label for now.

	// Components
	for _, comp := range cont.Components {
		e.writeComponent(sb, comp)
	}

	// Internal Relations
	for _, rel := range cont.Relations {
		e.writeRelation(sb, rel)
	}

	sb.WriteString("  }\n")
}

func (e *Exporter) writeComponent(sb *strings.Builder, comp *language.Component) {
	fmt.Fprintf(sb, "    %s: %s {\n", comp.ID, quote(comp.Label))
	sb.WriteString("      shape: class\n")
	if comp.Description != nil {
		fmt.Fprintf(sb, "      tooltip: %s\n", quote(*comp.Description))
	}
	sb.WriteString("    }\n")
}

func (e *Exporter) writeDataStore(sb *strings.Builder, ds *language.DataStore) {
	fmt.Fprintf(sb, "  %s: %s {\n", ds.ID, quote(ds.Label))
	sb.WriteString("    shape: cylinder\n")
	if ds.Description != nil {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(*ds.Description))
	}
	sb.WriteString("  }\n")
}

func (e *Exporter) writeQueue(sb *strings.Builder, q *language.Queue) {
	fmt.Fprintf(sb, "  %s: %s {\n", q.ID, quote(q.Label))
	sb.WriteString("    shape: queue\n")
	if q.Description != nil {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(*q.Description))
	}
	sb.WriteString("  }\n")
}

func (e *Exporter) writePerson(sb *strings.Builder, p *language.Person) {
	fmt.Fprintf(sb, "%s: %s {\n", p.ID, quote(p.Label))
	sb.WriteString("  shape: person\n")
	sb.WriteString("}\n\n")
}

func (e *Exporter) writeRelation(sb *strings.Builder, rel *language.Relation) {
	// D2 relation: From -> To: Label
	label := ""
	if rel.Verb != nil {
		label = *rel.Verb
	}
	if rel.Label != nil {
		if label != "" {
			label += ": " + *rel.Label
		} else {
			label = *rel.Label
		}
	}

	if label != "" {
		fmt.Fprintf(sb, "%s -> %s: %s\n", rel.From, rel.To, quote(label))
	} else {
		fmt.Fprintf(sb, "%s -> %s\n", rel.From, rel.To)
	}
}

func (e *Exporter) writeDeploymentNode(sb *strings.Builder, node *language.DeploymentNode) {
	fmt.Fprintf(sb, "%s: %s {\n", node.ID, quote(node.Label))
	// Deployment nodes are usually nested boxes
	if node.Description != nil {
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(*node.Description))
	}

	// Children
	for _, child := range node.Children {
		e.writeDeploymentNode(sb, child)
	}

	// Infrastructure
	for _, infra := range node.Infrastructure {
		fmt.Fprintf(sb, "  %s: %s {\n", infra.ID, quote(infra.Label))
		sb.WriteString("    shape: queue\n") // Using queue/cylinder/class as generic infra for now
		if infra.Description != nil {
			fmt.Fprintf(sb, "    tooltip: %s\n", quote(*infra.Description))
		}
		sb.WriteString("  }\n")
	}

	// Container Instances
	for _, instance := range node.ContainerInstances {
		// In D2, we can't easily "reference" an existing container and place it here without moving it.
		// So we create a new node representing the instance.
		id := instance.ContainerID
		if instance.InstanceID != nil {
			id = fmt.Sprintf("%s_%s", id, *instance.InstanceID)
		} else {
			id = fmt.Sprintf("%s_Instance", id)
		}
		fmt.Fprintf(sb, "  %s: %s\n", id, instance.ContainerID) // Alias to original container name?
		// Or better:
		// %s: {
		//   near: %s
		// }
		// But "near" isn't "inside".
		// Let's just create a node with the same label.
		fmt.Fprintf(sb, "  %s: {\n", id)
		fmt.Fprintf(sb, "    label: %s\n", instance.ContainerID) // Ideally look up the container label
		sb.WriteString("  }\n")
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeRequirementsLayer(sb *strings.Builder, arch *language.Architecture) {
	sb.WriteString("\"Requirements\": {\n")

	// Top-level requirements
	for _, req := range arch.Requirements {
		fmt.Fprintf(sb, "  %s: %s {\n", req.ID, quote(fmt.Sprintf("%s: %s", req.Type, req.Description)))
		sb.WriteString("    shape: page\n")
		sb.WriteString("  }\n")
	}

	// System-level requirements
	for _, sys := range arch.Systems {
		for _, req := range sys.Requirements {
			// We want to place this requirement "near" or "inside" the system if possible,
			// but D2 layers are global. We can use dot notation to put it inside the system scope in the layer.
			// e.g. Sys1.Req1
			fmt.Fprintf(sb, "  %s.%s: %s {\n", sys.ID, req.ID, quote(fmt.Sprintf("%s: %s", req.Type, req.Description)))
			sb.WriteString("    shape: page\n")
			sb.WriteString("  }\n")
		}
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeJourney(sb *strings.Builder, j *language.Journey) {
	fmt.Fprintf(sb, "%s: {\n", quote(j.Title))
	// Add title as a text shape
	fmt.Fprintf(sb, "  _Title: %s {\n", quote(j.Title))
	sb.WriteString("    shape: text\n")
	sb.WriteString("    style: {\n")
	sb.WriteString("      font-size: 20\n")
	sb.WriteString("      bold: true\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")

	for i, step := range j.Steps {
		label := ""
		if step.Label != nil {
			label = fmt.Sprintf("%d. %s", i+1, *step.Label)
		} else {
			label = fmt.Sprintf("%d", i+1)
		}
		fmt.Fprintf(sb, "  %s -> %s: %s\n", step.From, step.To, quote(label))
	}
	sb.WriteString("}\n\n")
}

func quote(s string) string {
	return fmt.Sprintf("%q", s)
}

func (e *Exporter) writeScenario(sb *strings.Builder, s *language.Scenario) {
	fmt.Fprintf(sb, "%s: {\n", quote(s.Title))
	// Add title as a text shape
	fmt.Fprintf(sb, "  _Title: %s {\n", quote(s.Title))
	sb.WriteString("    shape: text\n")
	sb.WriteString("    style: {\n")
	sb.WriteString("      font-size: 20\n")
	sb.WriteString("      bold: true\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")

	for i, step := range s.Steps {
		label := ""
		if step.Description != nil {
			label = fmt.Sprintf("%d. %s", i+1, *step.Description)
		} else {
			label = fmt.Sprintf("%d", i+1)
		}
		fmt.Fprintf(sb, "  %s -> %s: %s\n", step.From, step.To, quote(label))
	}
	sb.WriteString("}\n\n")
}
