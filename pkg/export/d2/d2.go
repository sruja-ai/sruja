package d2

import (
	"fmt"
	"strings"

	"github.com/sruja-ai/sruja/pkg/language"
)

// Exporter handles exporting Sruja AST to D2 format.
type Exporter struct {
	// Options for export (e.g., styling, layout)
	// Map of element ID to its fully qualified path in D2
	elementPaths map[string]string
}

// NewExporter creates a new D2 exporter.
func NewExporter() *Exporter {
	return &Exporter{
		elementPaths: make(map[string]string),
	}
}

// Export converts a Sruja architecture to D2 string.
func (e *Exporter) Export(arch *language.Architecture) (string, error) {
	// Build element paths map first
	e.buildElementPaths(arch)

	var sb strings.Builder

	// Write header/config
	sb.WriteString("# Generated by Sruja\n")
	sb.WriteString("direction: right\n\n")

	// Check for requirements
	hasRequirements := len(arch.Requirements) > 0
	if !hasRequirements {
		for _, sys := range arch.Systems {
			if len(sys.Requirements) > 0 {
				hasRequirements = true
				break
			}
		}
	}

	// Layers configuration
	hasLayers := hasRequirements || len(arch.Scenarios) > 0
	if hasLayers {
		sb.WriteString("layers: {\n")
		if hasRequirements {
			sb.WriteString("  \"Requirements\"\n")
		}
		for _, s := range arch.Scenarios {
			fmt.Fprintf(&sb, "  %s\n", quote(s.Title))
		}
		sb.WriteString("  \"Architecture\"\n")
		sb.WriteString("}\n\n")
	}

	// 1. Systems
	for _, sys := range arch.Systems {
		e.writeSystem(&sb, sys)
	}

	// 2. Persons
	for _, person := range arch.Persons {
		e.writePerson(&sb, person)
	}

	// 3. Relations (Top-level)
	for _, rel := range arch.Relations {
		e.writeRelation(&sb, rel, "")
	}

	// 4. Deployment Nodes
	for _, node := range arch.DeploymentNodes {
		e.writeDeploymentNode(&sb, node)
	}

	// 5. Requirements (as layer)
	if hasRequirements {
		e.writeRequirementsLayer(&sb, arch)
	}

	// 6. Scenarios (as layers)
	for _, s := range arch.Scenarios {
		e.writeScenario(&sb, s)
	}

	// 9. Architecture Layer (Static View)
	// We don't need to explicitly define the Architecture layer block if it's empty.
	// Global elements (Systems, Persons) are automatically included.

	return sb.String(), nil
}

func (e *Exporter) writeSystem(sb *strings.Builder, sys *language.System) {
	label := sys.Label
	if sys.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *sys.Description)
	}
	fmt.Fprintf(sb, "%s: %s {\n", sys.ID, quote(label))
	sb.WriteString("  shape: package\n")
	if sys.Description != nil {
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(*sys.Description))
	}

	// Containers
	for _, cont := range sys.Containers {
		e.writeContainer(sb, cont, sys.ID)
	}

	// DataStores
	for _, ds := range sys.DataStores {
		e.writeDataStore(sb, ds)
	}

	// Queues
	for _, q := range sys.Queues {
		e.writeQueue(sb, q)
	}

	// Internal Relations
	for _, rel := range sys.Relations {
		e.writeRelation(sb, rel, sys.ID)
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeContainer(sb *strings.Builder, cont *language.Container, parentPath string) {
	label := cont.Label
	if cont.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *cont.Description)
	}
	fmt.Fprintf(sb, "  %s: %s {\n", cont.ID, quote(label))
	sb.WriteString("    shape: package\n") // D2 doesn't have explicit container shape, using package
	if cont.Description != nil {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(*cont.Description))
	}

	// Technology as icon or label suffix? For now, just a comment or custom field if D2 supports it
	// D2 supports 'icon' but we need a URL. We can put it in the label for now.

	// Components
	for _, comp := range cont.Components {
		e.writeComponent(sb, comp)
	}

	// Internal Relations
	// Use system scope for container relations so sibling containers resolve correctly
	for _, rel := range cont.Relations {
		e.writeRelation(sb, rel, parentPath)
	}

	sb.WriteString("  }\n")
}

func (e *Exporter) writeComponent(sb *strings.Builder, comp *language.Component) {
	label := comp.Label
	if comp.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *comp.Description)
	}
	fmt.Fprintf(sb, "    %s: %s {\n", comp.ID, quote(label))
	sb.WriteString("      shape: class\n")
	if comp.Description != nil {
		fmt.Fprintf(sb, "      tooltip: %s\n", quote(*comp.Description))
	}
	sb.WriteString("    }\n")
}

func (e *Exporter) writeDataStore(sb *strings.Builder, ds *language.DataStore) {
	label := ds.Label
	if ds.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *ds.Description)
	}
	fmt.Fprintf(sb, "  %s: %s {\n", ds.ID, quote(label))
	sb.WriteString("    shape: cylinder\n")
	if ds.Description != nil {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(*ds.Description))
	}
	sb.WriteString("  }\n")
}

func (e *Exporter) writeQueue(sb *strings.Builder, q *language.Queue) {
	label := q.Label
	if q.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *q.Description)
	}
	fmt.Fprintf(sb, "  %s: %s {\n", q.ID, quote(label))
	sb.WriteString("    shape: queue\n")
	if q.Description != nil {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(*q.Description))
	}
	sb.WriteString("  }\n")
}

func (e *Exporter) writePerson(sb *strings.Builder, p *language.Person) {
	fmt.Fprintf(sb, "%s: %s {\n", p.ID, quote(p.Label))
	sb.WriteString("  shape: person\n")
	sb.WriteString("}\n\n")
}

func (e *Exporter) writeRelation(sb *strings.Builder, rel *language.Relation, scope string) {
	// D2 relation: From -> To: Label
	label := ""
	if rel.Verb != nil {
		label = *rel.Verb
	}
	if rel.Label != nil {
		if label != "" {
			label += ": " + *rel.Label
		} else {
			label = *rel.Label
		}
	}

	// Resolve From/To using element paths if available
	from := rel.From
	if path, ok := e.elementPaths[from]; ok {
		from = path
	}

	to := rel.To
	if path, ok := e.elementPaths[to]; ok {
		to = path
	}

	// If scope is provided, try to make paths relative
	if scope != "" {
		prefix := scope + "."
		from = strings.TrimPrefix(from, prefix)
		to = strings.TrimPrefix(to, prefix)
	}

	if label != "" {
		fmt.Fprintf(sb, "%s -> %s: %s\n", from, to, quote(label))
	} else {
		fmt.Fprintf(sb, "%s -> %s\n", from, to)
	}
}

func (e *Exporter) writeDeploymentNode(sb *strings.Builder, node *language.DeploymentNode) {
	label := node.Label
	if node.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *node.Description)
	}
	fmt.Fprintf(sb, "%s: %s {\n", node.ID, quote(label))
	// Deployment nodes are usually nested boxes
	if node.Description != nil {
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(*node.Description))
	}

	// Children
	for _, child := range node.Children {
		e.writeDeploymentNode(sb, child)
	}

	// Infrastructure
	for _, infra := range node.Infrastructure {
		label := infra.Label
		if infra.Description != nil {
			label = fmt.Sprintf("%s\n\n%s", label, *infra.Description)
		}
		fmt.Fprintf(sb, "  %s: %s {\n", infra.ID, quote(label))
		sb.WriteString("    shape: queue\n") // Using queue/cylinder/class as generic infra for now
		if infra.Description != nil {
			fmt.Fprintf(sb, "    tooltip: %s\n", quote(*infra.Description))
		}
		sb.WriteString("  }\n")
	}

	// Container Instances
	for _, instance := range node.ContainerInstances {
		// In D2, we can't easily "reference" an existing container and place it here without moving it.
		// So we create a new node representing the instance.
		id := instance.ContainerID
		if instance.InstanceID != nil {
			id = fmt.Sprintf("%s_%s", id, *instance.InstanceID)
		} else {
			id = fmt.Sprintf("%s_Instance", id)
		}
		fmt.Fprintf(sb, "  %s: %s\n", id, instance.ContainerID) // Alias to original container name?
		// Or better:
		// %s: {
		//   near: %s
		// }
		// But "near" isn't "inside".
		// Let's just create a node with the same label.
		fmt.Fprintf(sb, "  %s: {\n", id)
		fmt.Fprintf(sb, "    label: %s\n", instance.ContainerID) // Ideally look up the container label
		sb.WriteString("  }\n")
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeRequirementsLayer(sb *strings.Builder, arch *language.Architecture) {
	sb.WriteString("\"Requirements\": {\n")

	// Top-level requirements
	for _, req := range arch.Requirements {
		fmt.Fprintf(sb, "  %s: %s {\n", req.ID, quote(fmt.Sprintf("%s: %s", req.Type, req.Description)))
		sb.WriteString("    shape: page\n")
		sb.WriteString("  }\n")
	}

	// System-level requirements
	for _, sys := range arch.Systems {
		for _, req := range sys.Requirements {
			// We want to place this requirement "near" or "inside" the system if possible,
			// but D2 layers are global. We can use dot notation to put it inside the system scope in the layer.
			// e.g. Sys1.Req1
			fmt.Fprintf(sb, "  %s.%s: %s {\n", sys.ID, req.ID, quote(fmt.Sprintf("%s: %s", req.Type, req.Description)))
			sb.WriteString("    shape: page\n")
			sb.WriteString("  }\n")
		}
	}

	sb.WriteString("}\n\n")
}

func quote(s string) string {
	return fmt.Sprintf("%q", s)
}

func (e *Exporter) writeScenario(sb *strings.Builder, s *language.Scenario) {
	fmt.Fprintf(sb, "%s: {\n", quote(s.Title))
	// Add title as a text shape
	fmt.Fprintf(sb, "  _Title: %s {\n", quote(s.Title))
	sb.WriteString("    shape: text\n")
	sb.WriteString("    style: {\n")
	sb.WriteString("      font-size: 20\n")
	sb.WriteString("      bold: true\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")

	for i, step := range s.Steps {
		label := ""
		if step.Description != nil {
			label = fmt.Sprintf("%d. %s", i+1, *step.Description)
		} else {
			label = fmt.Sprintf("%d", i+1)
		}

		// Resolve From/To using element paths
		from := step.From
		if path, ok := e.elementPaths[from]; ok {
			from = path
		}

		to := step.To
		if path, ok := e.elementPaths[to]; ok {
			to = path
		}

		fmt.Fprintf(sb, "  %s -> %s: %s\n", from, to, quote(label))
	}
	sb.WriteString("}\n\n")
}

func (e *Exporter) buildElementPaths(arch *language.Architecture) {
	// Persons
	for _, p := range arch.Persons {
		e.elementPaths[p.ID] = p.ID
	}

	// Systems
	for _, s := range arch.Systems {
		e.elementPaths[s.ID] = s.ID

		// Containers
		for _, c := range s.Containers {
			path := fmt.Sprintf("%s.%s", s.ID, c.ID)
			e.elementPaths[c.ID] = path

			// Components in Containers
			for _, comp := range c.Components {
				compPath := fmt.Sprintf("%s.%s", path, comp.ID)
				e.elementPaths[comp.ID] = compPath
			}
		}

		// Components in Systems (direct)
		for _, comp := range s.Components {
			compPath := fmt.Sprintf("%s.%s", s.ID, comp.ID)
			e.elementPaths[comp.ID] = compPath
		}

		// DataStores
		for _, d := range s.DataStores {
			e.elementPaths[d.ID] = fmt.Sprintf("%s.%s", s.ID, d.ID)
		}

		// Queues
		for _, q := range s.Queues {
			e.elementPaths[q.ID] = fmt.Sprintf("%s.%s", s.ID, q.ID)
		}
	}
}
