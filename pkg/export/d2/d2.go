package d2

import (
	"fmt"
	"strings"

	"github.com/sruja-ai/sruja/pkg/language"
)

// Exporter handles exporting Sruja AST to D2 format.
type Exporter struct {
	// Options for export (e.g., styling, layout)
}

// NewExporter creates a new D2 exporter.
func NewExporter() *Exporter {
	return &Exporter{}
}

// Export converts a Sruja architecture to D2 string.
func (e *Exporter) Export(arch *language.Architecture) (string, error) {
	var sb strings.Builder

	// Write header/config
	sb.WriteString("# Generated by Sruja\n")
	sb.WriteString("direction: right\n\n")

	// 1. Systems
	for _, sys := range arch.Systems {
		e.writeSystem(&sb, sys)
	}

	// 2. Persons
	for _, person := range arch.Persons {
		e.writePerson(&sb, person)
	}

	// 3. Relations (Top-level)
	for _, rel := range arch.Relations {
		e.writeRelation(&sb, rel)
	}

	// 4. Deployment Nodes
	for _, node := range arch.DeploymentNodes {
		e.writeDeploymentNode(&sb, node)
	}

	// 5. Dynamic Views (as scenarios/steps)
	// D2 doesn't have a direct "dynamic view" construct like Structurizr.
	// We can render them as scenarios or just a sequence of connections if we want to visualize one.
	// For now, let's just render them as a separate block/scenario if possible, or just comments.
	// Actually, D2 scenarios are perfect for this.
	for _, view := range arch.DynamicViews {
		e.writeDynamicView(&sb, view)
	}

	return sb.String(), nil
}

func (e *Exporter) writeSystem(sb *strings.Builder, sys *language.System) {
	sb.WriteString(fmt.Sprintf("%s: %s {\n", sys.ID, quote(sys.Label)))
	sb.WriteString("  shape: package\n")
	if sys.Description != nil {
		sb.WriteString(fmt.Sprintf("  tooltip: %s\n", quote(*sys.Description)))
	}

	// Containers
	for _, cont := range sys.Containers {
		e.writeContainer(sb, cont)
	}

	// DataStores
	for _, ds := range sys.DataStores {
		e.writeDataStore(sb, ds)
	}

	// Queues
	for _, q := range sys.Queues {
		e.writeQueue(sb, q)
	}

	// Internal Relations
	for _, rel := range sys.Relations {
		e.writeRelation(sb, rel)
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeContainer(sb *strings.Builder, cont *language.Container) {
	sb.WriteString(fmt.Sprintf("  %s: %s {\n", cont.ID, quote(cont.Label)))
	sb.WriteString("    shape: package\n") // D2 doesn't have explicit container shape, using package
	if cont.Description != nil {
		sb.WriteString(fmt.Sprintf("    tooltip: %s\n", quote(*cont.Description)))
	}

	// Technology as icon or label suffix? For now, just a comment or custom field if D2 supports it
	// D2 supports 'icon' but we need a URL. We can put it in the label for now.

	// Components
	for _, comp := range cont.Components {
		e.writeComponent(sb, comp)
	}

	// Internal Relations
	for _, rel := range cont.Relations {
		e.writeRelation(sb, rel)
	}

	sb.WriteString("  }\n")
}

func (e *Exporter) writeComponent(sb *strings.Builder, comp *language.Component) {
	sb.WriteString(fmt.Sprintf("    %s: %s {\n", comp.ID, quote(comp.Label)))
	sb.WriteString("      shape: class\n")
	if comp.Description != nil {
		sb.WriteString(fmt.Sprintf("      tooltip: %s\n", quote(*comp.Description)))
	}
	sb.WriteString("    }\n")
}

func (e *Exporter) writeDataStore(sb *strings.Builder, ds *language.DataStore) {
	sb.WriteString(fmt.Sprintf("  %s: %s {\n", ds.ID, quote(ds.Label)))
	sb.WriteString("    shape: cylinder\n")
	if ds.Description != nil {
		sb.WriteString(fmt.Sprintf("    tooltip: %s\n", quote(*ds.Description)))
	}
	sb.WriteString("  }\n")
}

func (e *Exporter) writeQueue(sb *strings.Builder, q *language.Queue) {
	sb.WriteString(fmt.Sprintf("  %s: %s {\n", q.ID, quote(q.Label)))
	sb.WriteString("    shape: queue\n")
	if q.Description != nil {
		sb.WriteString(fmt.Sprintf("    tooltip: %s\n", quote(*q.Description)))
	}
	sb.WriteString("  }\n")
}

func (e *Exporter) writePerson(sb *strings.Builder, p *language.Person) {
	sb.WriteString(fmt.Sprintf("%s: %s {\n", p.ID, quote(p.Label)))
	sb.WriteString("  shape: person\n")
	sb.WriteString("}\n\n")
}

func (e *Exporter) writeRelation(sb *strings.Builder, rel *language.Relation) {
	// D2 relation: From -> To: Label
	label := ""
	if rel.Verb != nil {
		label = *rel.Verb
	}
	if rel.Label != nil {
		if label != "" {
			label += ": " + *rel.Label
		} else {
			label = *rel.Label
		}
	}

	if label != "" {
		sb.WriteString(fmt.Sprintf("%s -> %s: %s\n", rel.From, rel.To, quote(label)))
	} else {
		sb.WriteString(fmt.Sprintf("%s -> %s\n", rel.From, rel.To))
	}
}

func (e *Exporter) writeDeploymentNode(sb *strings.Builder, node *language.DeploymentNode) {
	sb.WriteString(fmt.Sprintf("%s: %s {\n", node.ID, quote(node.Label)))
	// Deployment nodes are usually nested boxes
	if node.Description != nil {
		sb.WriteString(fmt.Sprintf("  tooltip: %s\n", quote(*node.Description)))
	}

	// Children
	for _, child := range node.Children {
		e.writeDeploymentNode(sb, child)
	}

	// Infrastructure
	for _, infra := range node.Infrastructure {
		sb.WriteString(fmt.Sprintf("  %s: %s {\n", infra.ID, quote(infra.Label)))
		sb.WriteString("    shape: queue\n") // Using queue/cylinder/class as generic infra for now
		if infra.Description != nil {
			sb.WriteString(fmt.Sprintf("    tooltip: %s\n", quote(*infra.Description)))
		}
		sb.WriteString("  }\n")
	}

	// Container Instances
	for _, instance := range node.ContainerInstances {
		// In D2, we can't easily "reference" an existing container and place it here without moving it.
		// So we create a new node representing the instance.
		id := instance.ContainerID
		if instance.InstanceID != nil {
			id = fmt.Sprintf("%s_%s", id, *instance.InstanceID)
		} else {
			id = fmt.Sprintf("%s_Instance", id)
		}
		sb.WriteString(fmt.Sprintf("  %s: %s\n", id, instance.ContainerID)) // Alias to original container name?
		// Or better:
		// %s: {
		//   near: %s
		// }
		// But "near" isn't "inside".
		// Let's just create a node with the same label.
		sb.WriteString(fmt.Sprintf("  %s: {\n", id))
		sb.WriteString(fmt.Sprintf("    label: %s\n", instance.ContainerID)) // Ideally look up the container label
		sb.WriteString("  }\n")
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeDynamicView(sb *strings.Builder, view *language.DynamicView) {
	sb.WriteString(fmt.Sprintf("scenario: %s {\n", quote(view.Title)))
	for i, step := range view.Steps {
		// D2 scenarios use step references or just connections.
		// But scenarios in D2 are about state changes.
		// Maybe just a group for now?
		// "Dynamic View" is usually a sequence diagram.
		// D2 does sequence diagrams if we set `direction: sequence`.
		// But we can't mix architecture and sequence easily in one file unless we use scenarios.

		// Let's just list the connections with order numbers.
		label := ""
		if step.Description != nil {
			label = fmt.Sprintf("%d. %s", i+1, *step.Description)
		} else {
			label = fmt.Sprintf("%d", i+1)
		}
		sb.WriteString(fmt.Sprintf("  %s -> %s: %s\n", step.From, step.To, quote(label)))
	}
	sb.WriteString("}\n\n")
}

func quote(s string) string {
	return fmt.Sprintf("%q", s)
}
