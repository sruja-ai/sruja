package d2

import (
	"fmt"
	"strings"

	"github.com/sruja-ai/sruja/pkg/language"
)

// Exporter handles exporting Sruja AST to D2 format.
type Exporter struct {
	// Options for export (e.g., styling, layout)
	// Map of element ID to its fully qualified path in D2
	// Map of element ID to its fully qualified path in D2
	elementPaths map[string]string
	// InjectIDTooltips enables injecting SRUJA_ID:<id> into tooltips for SVG post-processing
	InjectIDTooltips bool
	// Scope options for partial export
	ScopeLevel     int    // 1=Context, 2=Container, 3=Component
	ScopeElementID string // ID of the System (for Level 2) or Container (for Level 3)
}

// NewExporter creates a new D2 exporter.
func NewExporter() *Exporter {
	return &Exporter{
		elementPaths: make(map[string]string),
	}
}

// Export converts a Sruja architecture to D2 string.
func (e *Exporter) Export(arch *language.Architecture) (string, error) {
	// Build element paths map first
	e.buildElementPaths(arch)

	var sb strings.Builder

	if e.ScopeLevel == 0 {
		e.writeFullExport(&sb, arch)
	} else {
		switch e.ScopeLevel {
		case 1:
			e.writeLevel1(&sb, arch)
		case 2:
			if err := e.writeLevel2(&sb, arch, e.ScopeElementID); err != nil {
				return "", err
			}
		case 3:
			if err := e.writeLevel3(&sb, arch, e.ScopeElementID); err != nil {
				return "", err
			}
		}
	}

	return sb.String(), nil
}

func (e *Exporter) writeFullExport(sb *strings.Builder, arch *language.Architecture) {
	// Write header/config
	sb.WriteString("# Generated by Sruja\n")
	sb.WriteString("direction: right\n\n")

	// Check for requirements
	hasRequirements := len(arch.Requirements) > 0
	if !hasRequirements {
		for _, sys := range arch.Systems {
			if len(sys.Requirements) > 0 {
				hasRequirements = true
				break
			}
		}
	}

	// Layers configuration
	hasLayers := hasRequirements || len(arch.Scenarios) > 0
	if hasLayers {
		sb.WriteString("layers: {\n")
		if hasRequirements {
			sb.WriteString("  \"Requirements\"\n")
		}
		for _, s := range arch.Scenarios {
			fmt.Fprintf(sb, "  %s\n", quote(s.Title))
		}
		sb.WriteString("  \"Architecture\"\n")
		sb.WriteString("}\n\n")
	}

	// 1. Systems
	for _, sys := range arch.Systems {
		e.writeSystem(sb, sys)
	}

	// 1.5 Domains (DDD)
	for _, domain := range arch.Domains {
		e.writeDomain(sb, domain)
	}

	// 1.6 Contexts (DDD - top level)
	// Note: Contexts inside domains are handled by writeDomain
	// We only need to handle top-level contexts here if any (though usually they are in domains)
	// But since we flatten contexts in post-process, we need to be careful not to duplicate.
	// Let's rely on Domains iteration for now. If there are top-level contexts without domain,
	// we might need to handle them.
	// For now, let's assume contexts are mostly inside domains or we iterate over top-level items.
	// Actually, `arch.Contexts` contains ALL contexts (flattened).
	// But `arch.Domains` contains domains which contain contexts.
	// If we iterate `arch.Domains`, we get the hierarchy.
	// If we have top-level contexts, they won't be in `arch.Domains`.
	// Let's iterate `arch.Contexts` but check if they are already rendered?
	// Or better: Iterate `arch.Items` again? No, that's raw AST.
	// Let's stick to `arch.Domains` for now as that's the requested feature.
	// If there are orphan contexts, we can add them later.

	// 2. Persons
	for _, person := range arch.Persons {
		e.writePerson(sb, person)
	}

	// 3. Relations (Top-level)
	for _, rel := range arch.Relations {
		e.writeRelation(sb, rel, "")
	}

	// 4. Deployment Nodes
	for _, node := range arch.DeploymentNodes {
		e.writeDeploymentNode(sb, node)
	}

	// 5. Requirements (as layer)
	if hasRequirements {
		e.writeRequirementsLayer(sb, arch)
	}

	// 6. Scenarios (as layers)
	for _, s := range arch.Scenarios {
		e.writeScenario(sb, s)
	}

	// 7. Flows (as layers)
	for _, sys := range arch.Systems {
		for _, f := range sys.Flows {
			e.writeFlow(sb, f)
		}
	}

	// 8. ADRs (as layers)
	hasADRs := len(arch.ADRs) > 0
	if !hasADRs {
		for _, sys := range arch.Systems {
			if len(sys.ADRs) > 0 {
				hasADRs = true
				break
			}
		}
	}

	if hasADRs {
		sb.WriteString("\"Decisions\": {\n")
		for _, adr := range arch.ADRs {
			e.writeADR(sb, adr)
		}
		for _, sys := range arch.Systems {
			for _, adr := range sys.ADRs {
				e.writeADR(sb, adr)
			}
		}
		sb.WriteString("}\n\n")
	}

	// 9. Architecture Layer (Static View)
	// We don't need to explicitly define the Architecture layer block if it's empty.
	// Global elements (Systems, Persons) are automatically included.
}

// writeLevel1 writes Level 1 (System Context) - shows systems, persons, and their relations
func (e *Exporter) writeLevel1(sb *strings.Builder, arch *language.Architecture) {
	sb.WriteString("# Generated by Sruja - Level 1: System Context\n")
	sb.WriteString("direction: right\n\n")

	// Persons
	for _, person := range arch.Persons {
		e.writePerson(sb, person)
	}

	// Systems (as boxes, not showing internal structure)
	for _, sys := range arch.Systems {
		label := sys.Label
		if sys.Description != nil {
			label = fmt.Sprintf("%s\n\n%s", label, *sys.Description)
		}
		fmt.Fprintf(sb, "%s: %s {\n", sys.ID, quote(label))
		sb.WriteString("  shape: package\n")
		if sys.Description != nil {
			desc := *sys.Description
			if e.InjectIDTooltips {
				desc = fmt.Sprintf("SRUJA_ID:%s|%s", sys.ID, desc)
			}
			fmt.Fprintf(sb, "  tooltip: %s\n", quote(desc))
		} else if e.InjectIDTooltips {
			fmt.Fprintf(sb, "  tooltip: %s\n", quote(fmt.Sprintf("SRUJA_ID:%s", sys.ID)))
		}
		sb.WriteString("}\n\n")
	}

	// External Systems (if any - would need to be tracked separately)
	// For now, we assume all systems are internal

	// Top-level Relations (between persons, systems, external systems)
	for _, rel := range arch.Relations {
		e.writeRelation(sb, rel, "")
	}
}

// writeLevel2 writes Level 2 (Container) - shows containers within a specific system
func (e *Exporter) writeLevel2(sb *strings.Builder, arch *language.Architecture, systemID string) error {
	// Find the target system
	var targetSys *language.System
	for _, sys := range arch.Systems {
		if sys.ID == systemID {
			targetSys = sys
			break
		}
	}
	if targetSys == nil {
		return fmt.Errorf("system %s not found", systemID)
	}

	fmt.Fprintf(sb, "# Generated by Sruja - Level 2: Containers for %s\n", systemID)
	sb.WriteString("direction: right\n\n")

	// Write the system boundary
	label := targetSys.Label
	if targetSys.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *targetSys.Description)
	}
	fmt.Fprintf(sb, "%s: %s {\n", targetSys.ID, quote(label))
	sb.WriteString("  shape: package\n")
	if targetSys.Description != nil {
		desc := *targetSys.Description
		if e.InjectIDTooltips {
			desc = fmt.Sprintf("SRUJA_ID:%s|%s", targetSys.ID, desc)
		}
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(desc))
	} else if e.InjectIDTooltips {
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(fmt.Sprintf("SRUJA_ID:%s", targetSys.ID)))
	}

	// Containers
	for _, cont := range targetSys.Containers {
		e.writeContainer(sb, cont, targetSys.ID)
	}

	// DataStores
	for _, ds := range targetSys.DataStores {
		e.writeDataStore(sb, ds)
	}

	// Queues
	for _, q := range targetSys.Queues {
		e.writeQueue(sb, q)
	}

	// System-level Relations (between containers, datastores, queues)
	for _, rel := range targetSys.Relations {
		e.writeRelation(sb, rel, targetSys.ID)
	}

	sb.WriteString("}\n\n")

	// Persons and external systems (for context)
	for _, person := range arch.Persons {
		e.writePerson(sb, person)
	}

	// Relations from/to persons and external systems
	for _, rel := range arch.Relations {
		// Only include relations that involve this system
		if rel.From == systemID || rel.To == systemID {
			e.writeRelation(sb, rel, "")
		}
	}

	return nil
}

// writeLevel3 writes Level 3 (Component) - shows components within a specific container
func (e *Exporter) writeLevel3(sb *strings.Builder, arch *language.Architecture, containerID string) error {
	// Find the target container and its parent system
	var targetCont *language.Container
	var parentSys *language.System
	for _, sys := range arch.Systems {
		for _, cont := range sys.Containers {
			if cont.ID == containerID {
				targetCont = cont
				parentSys = sys
				break
			}
		}
		if targetCont != nil {
			break
		}
	}
	if targetCont == nil {
		return fmt.Errorf("container %s not found", containerID)
	}
	if parentSys == nil {
		return fmt.Errorf("parent system for container %s not found", containerID)
	}

	fmt.Fprintf(sb, "# Generated by Sruja - Level 3: Components for %s.%s\n", parentSys.ID, containerID)
	sb.WriteString("direction: right\n\n")

	// Write the system boundary
	sysLabel := parentSys.Label
	if parentSys.Description != nil {
		sysLabel = fmt.Sprintf("%s\n\n%s", sysLabel, *parentSys.Description)
	}
	fmt.Fprintf(sb, "%s: %s {\n", parentSys.ID, quote(sysLabel))
	sb.WriteString("  shape: package\n")

	// Write the container boundary
	contLabel := targetCont.Label
	if targetCont.Description != nil {
		contLabel = fmt.Sprintf("%s\n\n%s", contLabel, *targetCont.Description)
	}
	fmt.Fprintf(sb, "  %s: %s {\n", targetCont.ID, quote(contLabel))
	sb.WriteString("    shape: package\n")
	if targetCont.Description != nil {
		desc := *targetCont.Description
		if e.InjectIDTooltips {
			desc = fmt.Sprintf("SRUJA_ID:%s|%s", targetCont.ID, desc)
		}
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(desc))
	} else if e.InjectIDTooltips {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(fmt.Sprintf("SRUJA_ID:%s", targetCont.ID)))
	}

	// Components
	for _, comp := range targetCont.Components {
		e.writeComponent(sb, comp)
	}

	// Container-level Relations (between components)
	for _, rel := range targetCont.Relations {
		e.writeRelation(sb, rel, fmt.Sprintf("%s.%s", parentSys.ID, targetCont.ID))
	}

	sb.WriteString("  }\n") // Close container
	sb.WriteString("}\n\n") // Close system

	// External context (other containers, datastores, queues in the same system)
	for _, cont := range parentSys.Containers {
		if cont.ID != containerID {
			// Show as external reference
			label := cont.Label
			if cont.Description != nil {
				label = fmt.Sprintf("%s\n\n%s", label, *cont.Description)
			}
			fmt.Fprintf(sb, "%s.%s: %s {\n", parentSys.ID, cont.ID, quote(label))
			sb.WriteString("  shape: package\n")
			sb.WriteString("  style.opacity: 0.5\n") // Dimmed to show it's external context
			sb.WriteString("}\n\n")
		}
	}

	// Relations to/from external containers
	for _, rel := range parentSys.Relations {
		// Include relations that involve this container
		if rel.From == containerID || rel.To == containerID {
			e.writeRelation(sb, rel, parentSys.ID)
		}
	}

	return nil
}

func (e *Exporter) writeSystem(sb *strings.Builder, sys *language.System) {
	label := sys.Label
	if sys.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *sys.Description)
	}
	fmt.Fprintf(sb, "%s: %s {\n", sys.ID, quote(label))
	sb.WriteString("  shape: package\n")
	if sys.Description != nil {
		desc := *sys.Description
		if e.InjectIDTooltips {
			desc = fmt.Sprintf("SRUJA_ID:%s|%s", sys.ID, desc)
		}
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(desc))
	} else if e.InjectIDTooltips {
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(fmt.Sprintf("SRUJA_ID:%s", sys.ID)))
	}

	// Containers
	for _, cont := range sys.Containers {
		e.writeContainer(sb, cont, sys.ID)
	}

	// DataStores
	for _, ds := range sys.DataStores {
		e.writeDataStore(sb, ds)
	}

	// Queues
	for _, q := range sys.Queues {
		e.writeQueue(sb, q)
	}

	// Internal Relations
	for _, rel := range sys.Relations {
		e.writeRelation(sb, rel, sys.ID)
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeContainer(sb *strings.Builder, cont *language.Container, parentPath string) {
	label := cont.Label
	if cont.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *cont.Description)
	}
	fmt.Fprintf(sb, "  %s: %s {\n", cont.ID, quote(label))
	sb.WriteString("    shape: package\n") // D2 doesn't have explicit container shape, using package
	if cont.Description != nil {
		desc := *cont.Description
		if e.InjectIDTooltips {
			desc = fmt.Sprintf("SRUJA_ID:%s|%s", cont.ID, desc)
		}
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(desc))
	} else if e.InjectIDTooltips {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(fmt.Sprintf("SRUJA_ID:%s", cont.ID)))
	}

	// Technology as icon or label suffix? For now, just a comment or custom field if D2 supports it
	// D2 supports 'icon' but we need a URL. We can put it in the label for now.

	// Components
	for _, comp := range cont.Components {
		e.writeComponent(sb, comp)
	}

	// Internal Relations
	// Use system scope for container relations so sibling containers resolve correctly
	for _, rel := range cont.Relations {
		e.writeRelation(sb, rel, parentPath)
	}

	sb.WriteString("  }\n")
}

func (e *Exporter) writeComponent(sb *strings.Builder, comp *language.Component) {
	label := comp.Label
	if comp.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *comp.Description)
	}
	fmt.Fprintf(sb, "    %s: %s {\n", comp.ID, quote(label))
	sb.WriteString("      shape: class\n")
	if comp.Description != nil {
		desc := *comp.Description
		if e.InjectIDTooltips {
			desc = fmt.Sprintf("SRUJA_ID:%s|%s", comp.ID, desc)
		}
		fmt.Fprintf(sb, "      tooltip: %s\n", quote(desc))
	} else if e.InjectIDTooltips {
		fmt.Fprintf(sb, "      tooltip: %s\n", quote(fmt.Sprintf("SRUJA_ID:%s", comp.ID)))
	}
	sb.WriteString("    }\n")
}

func (e *Exporter) writeDataStore(sb *strings.Builder, ds *language.DataStore) {
	label := ds.Label
	if ds.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *ds.Description)
	}
	fmt.Fprintf(sb, "  %s: %s {\n", ds.ID, quote(label))
	sb.WriteString("    shape: cylinder\n")
	if ds.Description != nil {
		desc := *ds.Description
		if e.InjectIDTooltips {
			desc = fmt.Sprintf("SRUJA_ID:%s|%s", ds.ID, desc)
		}
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(desc))
	} else if e.InjectIDTooltips {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(fmt.Sprintf("SRUJA_ID:%s", ds.ID)))
	}
	sb.WriteString("  }\n")
}

func (e *Exporter) writeQueue(sb *strings.Builder, q *language.Queue) {
	label := q.Label
	if q.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *q.Description)
	}
	fmt.Fprintf(sb, "  %s: %s {\n", q.ID, quote(label))
	sb.WriteString("    shape: queue\n")
	if q.Description != nil {
		desc := *q.Description
		if e.InjectIDTooltips {
			desc = fmt.Sprintf("SRUJA_ID:%s|%s", q.ID, desc)
		}
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(desc))
	} else if e.InjectIDTooltips {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(fmt.Sprintf("SRUJA_ID:%s", q.ID)))
	}
	sb.WriteString("  }\n")
}

func (e *Exporter) writePerson(sb *strings.Builder, p *language.Person) {
	fmt.Fprintf(sb, "%s: %s {\n", p.ID, quote(p.Label))
	sb.WriteString("  shape: person\n")
	sb.WriteString("}\n\n")
}

func (e *Exporter) writeRelation(sb *strings.Builder, rel *language.Relation, scope string) {
	// D2 relation: From -> To: Label
	label := ""
	if rel.Verb != nil {
		label = *rel.Verb
	}
	if rel.Label != nil {
		if label != "" {
			label += ": " + *rel.Label
		} else {
			label = *rel.Label
		}
	}

	// Resolve From/To using element paths if available
	from := rel.From
	if path, ok := e.elementPaths[from]; ok {
		from = path
	}

	to := rel.To
	if path, ok := e.elementPaths[to]; ok {
		to = path
	}

	// If scope is provided, try to make paths relative
	if scope != "" {
		prefix := scope + "."
		from = strings.TrimPrefix(from, prefix)
		to = strings.TrimPrefix(to, prefix)
	}

	if label != "" {
		fmt.Fprintf(sb, "%s -> %s: %s\n", from, to, quote(label))
	} else {
		fmt.Fprintf(sb, "%s -> %s\n", from, to)
	}
}

func (e *Exporter) writeDeploymentNode(sb *strings.Builder, node *language.DeploymentNode) {
	label := node.Label
	if node.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *node.Description)
	}
	fmt.Fprintf(sb, "%s: %s {\n", node.ID, quote(label))
	// Deployment nodes are usually nested boxes
	if node.Description != nil {
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(*node.Description))
	}

	// Children
	for _, child := range node.Children {
		e.writeDeploymentNode(sb, child)
	}

	// Infrastructure
	for _, infra := range node.Infrastructure {
		label := infra.Label
		if infra.Description != nil {
			label = fmt.Sprintf("%s\n\n%s", label, *infra.Description)
		}
		fmt.Fprintf(sb, "  %s: %s {\n", infra.ID, quote(label))
		sb.WriteString("    shape: queue\n") // Using queue/cylinder/class as generic infra for now
		if infra.Description != nil {
			fmt.Fprintf(sb, "    tooltip: %s\n", quote(*infra.Description))
		}
		sb.WriteString("  }\n")
	}

	// Container Instances
	for _, instance := range node.ContainerInstances {
		// In D2, we can't easily "reference" an existing container and place it here without moving it.
		// So we create a new node representing the instance.
		id := instance.ContainerID
		if instance.InstanceID != nil {
			id = fmt.Sprintf("%s_%s", id, *instance.InstanceID)
		} else {
			id = fmt.Sprintf("%s_Instance", id)
		}
		fmt.Fprintf(sb, "  %s: %s\n", id, instance.ContainerID) // Alias to original container name?
		// Or better:
		// %s: {
		//   near: %s
		// }
		// But "near" isn't "inside".
		// Let's just create a node with the same label.
		fmt.Fprintf(sb, "  %s: {\n", id)
		fmt.Fprintf(sb, "    label: %s\n", instance.ContainerID) // Ideally look up the container label
		sb.WriteString("  }\n")
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeRequirementsLayer(sb *strings.Builder, arch *language.Architecture) {
	sb.WriteString("\"Requirements\": {\n")

	// Top-level requirements
	for _, req := range arch.Requirements {
		reqType := "Requirement"
		if req.Type != nil {
			reqType = *req.Type
		}
		desc := ""
		if req.Description != nil {
			desc = *req.Description
		}
		fmt.Fprintf(sb, "  %s: %s {\n", req.ID, quote(fmt.Sprintf("%s: %s", reqType, desc)))
		sb.WriteString("    shape: page\n")
		sb.WriteString("  }\n")
	}

	// System-level requirements
	for _, sys := range arch.Systems {
		for _, req := range sys.Requirements {
			reqType := "Requirement"
			if req.Type != nil {
				reqType = *req.Type
			}
			// We want to place this requirement "near" or "inside" the system if possible,
			// but D2 layers are global. We can use dot notation to put it inside the system scope in the layer.
			// e.g. Sys1.Req1
			desc := ""
			if req.Description != nil {
				desc = *req.Description
			}
			fmt.Fprintf(sb, "  %s.%s: %s {\n", sys.ID, req.ID, quote(fmt.Sprintf("%s: %s", reqType, desc)))
			sb.WriteString("    shape: page\n")
			sb.WriteString("  }\n")
		}
	}

	sb.WriteString("}\n\n")
}

func quote(s string) string {
	return fmt.Sprintf("%q", s)
}

func (e *Exporter) writeScenario(sb *strings.Builder, s *language.Scenario) {
	fmt.Fprintf(sb, "%s: {\n", quote(s.Title))
	// Add title as a text shape
	fmt.Fprintf(sb, "  _Title: %s {\n", quote(s.Title))
	sb.WriteString("    shape: text\n")
	sb.WriteString("    style: {\n")
	sb.WriteString("      font-size: 20\n")
	sb.WriteString("      bold: true\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")
	sb.WriteString("  shape: sequence_diagram\n")

	for i, step := range s.Steps {
		// Resolve From/To using element paths
		from := step.From
		if path, ok := e.elementPaths[from]; ok {
			from = path
		} else {
			// If not a resolved path (e.g. ad-hoc string), quote it
			from = quote(from)
		}

		label := ""
		if step.Description != nil {
			label = fmt.Sprintf("%d. %s", i+1, *step.Description)
		} else {
			label = fmt.Sprintf("%d", i+1)
		}

		for _, prop := range step.Props {
			label += fmt.Sprintf("\\n(%s: %s)", prop.Key, prop.Value)
		}

		to := ""
		if step.To != nil {
			to = *step.To
			if path, ok := e.elementPaths[to]; ok {
				to = path
			} else {
				to = quote(to)
			}
		}

		if to != "" {
			fmt.Fprintf(sb, "  %s -> %s: %s\n", from, to, quote(label))
		} else {
			fmt.Fprintf(sb, "  %s: %s\n", from, quote(label))
		}
	}
	sb.WriteString("}\n\n")
}

func (e *Exporter) writeFlow(sb *strings.Builder, f *language.Flow) {
	fmt.Fprintf(sb, "%s: {\n", quote(f.Title))
	// Add title as a text shape
	fmt.Fprintf(sb, "  _Title: %s {\n", quote(f.Title))
	sb.WriteString("    shape: text\n")
	sb.WriteString("    style: {\n")
	sb.WriteString("      font-size: 20\n")
	sb.WriteString("      bold: true\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")

	for i, step := range f.Steps {
		label := ""
		if step.Data != nil {
			label = *step.Data
		} else {
			label = fmt.Sprintf("Flow %d", i+1)
		}

		// Resolve From/To using element paths
		from := step.From
		if path, ok := e.elementPaths[from]; ok {
			from = path
		}

		to := step.To
		if path, ok := e.elementPaths[to]; ok {
			to = path
		}

		fmt.Fprintf(sb, "  %s -> %s: %s\n", from, to, quote(label))
	}
	sb.WriteString("}\n\n")
}

func (e *Exporter) writeADR(sb *strings.Builder, adr *language.ADR) {
	label := ""
	if adr.Title != nil {
		label = *adr.Title
	} else {
		label = adr.ID
	}

	if adr.Body != nil {
		if adr.Body.Status != nil {
			label += fmt.Sprintf("\nStatus: %s", *adr.Body.Status)
		}
		if adr.Body.Decision != nil {
			label += fmt.Sprintf("\nDecision: %s", *adr.Body.Decision)
		}
		if adr.Body.Reason != nil {
			label += fmt.Sprintf("\nReason: %s", *adr.Body.Reason)
		}
	}

	fmt.Fprintf(sb, "  %s: %s {\n", adr.ID, quote(label))
	sb.WriteString("    shape: page\n")
	sb.WriteString("  }\n")
}

func (e *Exporter) buildElementPaths(arch *language.Architecture) {
	// Persons
	for _, p := range arch.Persons {
		e.elementPaths[p.ID] = p.ID
	}

	// Systems
	for _, s := range arch.Systems {
		e.elementPaths[s.ID] = s.ID

		// Containers
		for _, c := range s.Containers {
			path := fmt.Sprintf("%s.%s", s.ID, c.ID)
			e.elementPaths[c.ID] = path

			// Components in Containers
			for _, comp := range c.Components {
				compPath := fmt.Sprintf("%s.%s", path, comp.ID)
				e.elementPaths[comp.ID] = compPath
			}
		}

		// Components in Systems (direct)
		for _, comp := range s.Components {
			compPath := fmt.Sprintf("%s.%s", s.ID, comp.ID)
			e.elementPaths[comp.ID] = compPath
		}

		// DataStores
		for _, d := range s.DataStores {
			e.elementPaths[d.ID] = fmt.Sprintf("%s.%s", s.ID, d.ID)
		}

		// Queues
		for _, q := range s.Queues {
			e.elementPaths[q.ID] = fmt.Sprintf("%s.%s", s.ID, q.ID)
		}
	}

	// Domains
	for _, d := range arch.Domains {
		e.elementPaths[d.ID] = d.ID
		for _, c := range d.Contexts {
			e.elementPaths[c.ID] = fmt.Sprintf("%s.%s", d.ID, c.ID)
		}
	}
}

func (e *Exporter) writeDomain(sb *strings.Builder, d *language.DomainBlock) {
	label := d.Label
	if d.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *d.Description)
	}
	fmt.Fprintf(sb, "%s: %s {\n", d.ID, quote(label))
	sb.WriteString("  shape: package\n")
	if d.Description != nil {
		fmt.Fprintf(sb, "  tooltip: %s\n", quote(*d.Description))
	}

	// Contexts
	for _, ctx := range d.Contexts {
		e.writeContext(sb, ctx)
	}

	sb.WriteString("}\n\n")
}

func (e *Exporter) writeContext(sb *strings.Builder, c *language.ContextBlock) {
	label := c.Label
	if c.Description != nil {
		label = fmt.Sprintf("%s\n\n%s", label, *c.Description)
	}
	fmt.Fprintf(sb, "  %s: %s {\n", c.ID, quote(label))
	sb.WriteString("    shape: package\n")
	if c.Description != nil {
		fmt.Fprintf(sb, "    tooltip: %s\n", quote(*c.Description))
	}
	sb.WriteString("  }\n")
}
